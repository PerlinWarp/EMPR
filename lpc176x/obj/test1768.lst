
obj/test1768.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005d1f  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000004  10000000  00005d20  00010000  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00004914  10000004  00005d24  00010004  2**2
                  ALLOC
  3 .stack        00000800  10004918  0000a638  00010004  2**3
                  ALLOC
  4 .ARM.attributes 00000031  00000000  00000000  00010004  2**0
                  CONTENTS, READONLY
  5 .comment      0000002a  00000000  00000000  00010035  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000100  00000000  00000000  0001005f  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubnames 0000047f  00000000  00000000  0001015f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   0000449a  00000000  00000000  000105de  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00000cd9  00000000  00000000  00014a78  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00001d68  00000000  00000000  00015751  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00000ca4  00000000  00000000  000174bc  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00000a53  00000000  00000000  00018160  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00005ec9  00000000  00000000  00018bb3  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_pubtypes 0000033d  00000000  00000000  0001ea7c  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 000000c0  00000000  00000000  0001edb9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <vector>:
       0:	18 51 00 10 43 14 00 00 15 15 00 00 15 15 00 00     .Q..C...........
      10:	15 15 00 00 15 15 00 00 15 15 00 00 00 00 00 00     ................
	...
      2c:	41 14 00 00 15 15 00 00 00 00 00 00 15 15 00 00     A...............
      3c:	ad 03 00 00 17 15 00 00 17 15 00 00 17 15 00 00     ................
      4c:	17 15 00 00 c9 17 00 00 19 15 00 00 17 15 00 00     ................
      5c:	17 15 00 00 17 15 00 00 17 15 00 00 17 15 00 00     ................
      6c:	17 15 00 00 17 15 00 00 17 15 00 00 17 15 00 00     ................
      7c:	17 15 00 00 17 15 00 00 17 15 00 00 17 15 00 00     ................
      8c:	17 15 00 00 17 15 00 00 17 15 00 00 17 15 00 00     ................
      9c:	17 15 00 00 17 15 00 00 17 15 00 00 17 15 00 00     ................
      ac:	17 15 00 00 17 15 00 00 17 15 00 00 17 15 00 00     ................
      bc:	17 15 00 00 17 15 00 00 17 15 00 00 17 15 00 00     ................
	...

00000300 <put_rc>:



static
void put_rc (FRESULT rc)
{
     300:	4601      	mov	r1, r0
		"INVALID_NAME\0" "DENIED\0" "EXIST\0" "INVALID_OBJECT\0" "WRITE_PROTECTED\0"
		"INVALID_DRIVE\0" "NOT_ENABLED\0" "NO_FILE_SYSTEM\0" "MKFS_ABORTED\0" "TIMEOUT\0"
		"LOCKED\0" "NOT_ENOUGH_CORE\0" "TOO_MANY_OPEN_FILES\0" "INVALID_PARAMETER\0";
	FRESULT i;

	for (i = 0; i != rc && *str; i++) {
     302:	2300      	movs	r3, #0

static
void put_rc (FRESULT rc)
{
	const char *str =
		"OK\0" "DISK_ERR\0" "INT_ERR\0" "NOT_READY\0" "NO_FILE\0" "NO_PATH\0"
     304:	4a07      	ldr	r2, [pc, #28]	; (324 <put_rc+0x24>)
		"INVALID_NAME\0" "DENIED\0" "EXIST\0" "INVALID_OBJECT\0" "WRITE_PROTECTED\0"
		"INVALID_DRIVE\0" "NOT_ENABLED\0" "NO_FILE_SYSTEM\0" "MKFS_ABORTED\0" "TIMEOUT\0"
		"LOCKED\0" "NOT_ENOUGH_CORE\0" "TOO_MANY_OPEN_FILES\0" "INVALID_PARAMETER\0";
	FRESULT i;

	for (i = 0; i != rc && *str; i++) {
     306:	e005      	b.n	314 <put_rc+0x14>
		while (*str++) ;
     308:	f812 0b01 	ldrb.w	r0, [r2], #1
     30c:	2800      	cmp	r0, #0
     30e:	d1fb      	bne.n	308 <put_rc+0x8>
		"INVALID_NAME\0" "DENIED\0" "EXIST\0" "INVALID_OBJECT\0" "WRITE_PROTECTED\0"
		"INVALID_DRIVE\0" "NOT_ENABLED\0" "NO_FILE_SYSTEM\0" "MKFS_ABORTED\0" "TIMEOUT\0"
		"LOCKED\0" "NOT_ENOUGH_CORE\0" "TOO_MANY_OPEN_FILES\0" "INVALID_PARAMETER\0";
	FRESULT i;

	for (i = 0; i != rc && *str; i++) {
     310:	3301      	adds	r3, #1
     312:	b2db      	uxtb	r3, r3
     314:	428b      	cmp	r3, r1
     316:	d002      	beq.n	31e <put_rc+0x1e>
     318:	7810      	ldrb	r0, [r2, #0]
     31a:	2800      	cmp	r0, #0
     31c:	d1f4      	bne.n	308 <put_rc+0x8>
		while (*str++) ;
	}
	xprintf("rc=%u FR_%s\n", (UINT)rc, str);
     31e:	4802      	ldr	r0, [pc, #8]	; (328 <put_rc+0x28>)
     320:	f001 be2c 	b.w	1f7c <xprintf>
     324:	0000517c 	.word	0x0000517c
     328:	00005844 	.word	0x00005844

0000032c <scan_files>:

static
FRESULT scan_files (
	char* path		/* Pointer to the path name working buffer */
)
{
     32c:	b5f0      	push	{r4, r5, r6, r7, lr}
     32e:	4604      	mov	r4, r0
     330:	b08d      	sub	sp, #52	; 0x34
	DIR dirs;
	FRESULT res;
	BYTE i;


	if ((res = f_opendir(&dirs, path)) == FR_OK) {
     332:	4668      	mov	r0, sp
     334:	4621      	mov	r1, r4
     336:	f003 fed9 	bl	40ec <f_opendir>
     33a:	e017      	b.n	36c <scan_files+0x40>
		while (((res = f_readdir(&dirs, &Finfo)) == FR_OK) && Finfo.fname[0]) {
			if (Finfo.fattrib & AM_DIR) {
     33c:	7a3b      	ldrb	r3, [r7, #8]
     33e:	f013 0f10 	tst.w	r3, #16
     342:	d015      	beq.n	370 <scan_files+0x44>
				AccDirs++;
     344:	4b15      	ldr	r3, [pc, #84]	; (39c <scan_files+0x70>)
				i = strlen(path);
     346:	4620      	mov	r0, r4


	if ((res = f_opendir(&dirs, path)) == FR_OK) {
		while (((res = f_readdir(&dirs, &Finfo)) == FR_OK) && Finfo.fname[0]) {
			if (Finfo.fattrib & AM_DIR) {
				AccDirs++;
     348:	881a      	ldrh	r2, [r3, #0]
     34a:	3201      	adds	r2, #1
     34c:	801a      	strh	r2, [r3, #0]
				i = strlen(path);
     34e:	f004 fee5 	bl	511c <strlen>
				path[i] = '/'; strcpy(&path[i+1], Finfo.fname);
     352:	b2c5      	uxtb	r5, r0
     354:	232f      	movs	r3, #47	; 0x2f
     356:	1c68      	adds	r0, r5, #1
     358:	5563      	strb	r3, [r4, r5]
     35a:	f107 0109 	add.w	r1, r7, #9
     35e:	1820      	adds	r0, r4, r0
     360:	f004 fe7e 	bl	5060 <strcpy>
				res = scan_files(path);
     364:	4620      	mov	r0, r4
     366:	f7ff ffe1 	bl	32c <scan_files>
				path[i] = '\0';
     36a:	5566      	strb	r6, [r4, r5]
				if (res != FR_OK) break;
     36c:	b148      	cbz	r0, 382 <scan_files+0x56>
     36e:	e012      	b.n	396 <scan_files+0x6a>
			} else {
			/*	xprintf("%s/%s\n", path, fn); */
				AccFiles++;
     370:	4b0b      	ldr	r3, [pc, #44]	; (3a0 <scan_files+0x74>)
				AccSize += Finfo.fsize;
     372:	6839      	ldr	r1, [r7, #0]
				res = scan_files(path);
				path[i] = '\0';
				if (res != FR_OK) break;
			} else {
			/*	xprintf("%s/%s\n", path, fn); */
				AccFiles++;
     374:	881a      	ldrh	r2, [r3, #0]
     376:	3201      	adds	r2, #1
     378:	801a      	strh	r2, [r3, #0]
				AccSize += Finfo.fsize;
     37a:	4b0a      	ldr	r3, [pc, #40]	; (3a4 <scan_files+0x78>)
     37c:	681a      	ldr	r2, [r3, #0]
     37e:	188a      	adds	r2, r1, r2
     380:	601a      	str	r2, [r3, #0]
	FRESULT res;
	BYTE i;


	if ((res = f_opendir(&dirs, path)) == FR_OK) {
		while (((res = f_readdir(&dirs, &Finfo)) == FR_OK) && Finfo.fname[0]) {
     382:	4668      	mov	r0, sp
     384:	4908      	ldr	r1, [pc, #32]	; (3a8 <scan_files+0x7c>)
     386:	f003 feeb 	bl	4160 <f_readdir>
     38a:	4606      	mov	r6, r0
     38c:	b918      	cbnz	r0, 396 <scan_files+0x6a>
     38e:	4f06      	ldr	r7, [pc, #24]	; (3a8 <scan_files+0x7c>)
     390:	7a7b      	ldrb	r3, [r7, #9]
     392:	2b00      	cmp	r3, #0
     394:	d1d2      	bne.n	33c <scan_files+0x10>
			}
		}
	}

	return res;
}
     396:	b00d      	add	sp, #52	; 0x34
     398:	bdf0      	pop	{r4, r5, r6, r7, pc}
     39a:	bf00      	nop
     39c:	1000490c 	.word	0x1000490c
     3a0:	1000490e 	.word	0x1000490e
     3a4:	100007d8 	.word	0x100007d8
     3a8:	1000036c 	.word	0x1000036c

000003ac <SysTick_Handler>:
void SysTick_Handler (void)
{
	static int led_timer;


	Timer++;	/* Increment performance counter */
     3ac:	4b09      	ldr	r3, [pc, #36]	; (3d4 <SysTick_Handler+0x28>)
     3ae:	681a      	ldr	r2, [r3, #0]
     3b0:	3201      	adds	r2, #1
     3b2:	601a      	str	r2, [r3, #0]

	if (++led_timer >= 500) {
     3b4:	4b08      	ldr	r3, [pc, #32]	; (3d8 <SysTick_Handler+0x2c>)
     3b6:	681a      	ldr	r2, [r3, #0]
     3b8:	3201      	adds	r2, #1
     3ba:	f5b2 7ffa 	cmp.w	r2, #500	; 0x1f4
     3be:	601a      	str	r2, [r3, #0]
     3c0:	db06      	blt.n	3d0 <SysTick_Handler+0x24>
		led_timer = 0;
     3c2:	2200      	movs	r2, #0
     3c4:	601a      	str	r2, [r3, #0]
		FIO0PIN ^= 1 << 22;		/* Toggle LED state */
     3c6:	4b05      	ldr	r3, [pc, #20]	; (3dc <SysTick_Handler+0x30>)
     3c8:	681a      	ldr	r2, [r3, #0]
     3ca:	f482 0280 	eor.w	r2, r2, #4194304	; 0x400000
     3ce:	601a      	str	r2, [r3, #0]
	}

	disk_timerproc();	/* Disk timer process */
     3d0:	f002 bab4 	b.w	293c <disk_timerproc>
     3d4:	100007d4 	.word	0x100007d4
     3d8:	10000004 	.word	0x10000004
     3dc:	2009c014 	.word	0x2009c014

000003e0 <get_fattime>:
/* the system does not support an RTC.                     */
/* This function is not required in read-only cfg.         */


DWORD get_fattime (void)
{
     3e0:	b507      	push	{r0, r1, r2, lr}
	RTC rtc;

	/* Get local time */
	rtc_gettime(&rtc);
     3e2:	4668      	mov	r0, sp
     3e4:	f001 f994 	bl	1710 <rtc_gettime>

	/* Pack date and time into a DWORD variable */
	return	  ((DWORD)(rtc.year - 1980) << 25)
			| ((DWORD)rtc.month << 21)
     3e8:	f89d 0002 	ldrb.w	r0, [sp, #2]
			| ((DWORD)rtc.mday << 16)
     3ec:	f89d 3003 	ldrb.w	r3, [sp, #3]
	/* Get local time */
	rtc_gettime(&rtc);

	/* Pack date and time into a DWORD variable */
	return	  ((DWORD)(rtc.year - 1980) << 25)
			| ((DWORD)rtc.month << 21)
     3f0:	0540      	lsls	r0, r0, #21
     3f2:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
			| ((DWORD)rtc.mday << 16)
			| ((DWORD)rtc.hour << 11)
     3f6:	f89d 3005 	ldrb.w	r3, [sp, #5]
	rtc_gettime(&rtc);

	/* Pack date and time into a DWORD variable */
	return	  ((DWORD)(rtc.year - 1980) << 25)
			| ((DWORD)rtc.month << 21)
			| ((DWORD)rtc.mday << 16)
     3fa:	ea40 20c3 	orr.w	r0, r0, r3, lsl #11
			| ((DWORD)rtc.hour << 11)
			| ((DWORD)rtc.min << 5)
     3fe:	f89d 3006 	ldrb.w	r3, [sp, #6]

	/* Pack date and time into a DWORD variable */
	return	  ((DWORD)(rtc.year - 1980) << 25)
			| ((DWORD)rtc.month << 21)
			| ((DWORD)rtc.mday << 16)
			| ((DWORD)rtc.hour << 11)
     402:	ea40 1043 	orr.w	r0, r0, r3, lsl #5
			| ((DWORD)rtc.min << 5)
			| ((DWORD)rtc.sec >> 1);
     406:	f89d 3007 	ldrb.w	r3, [sp, #7]
	/* Pack date and time into a DWORD variable */
	return	  ((DWORD)(rtc.year - 1980) << 25)
			| ((DWORD)rtc.month << 21)
			| ((DWORD)rtc.mday << 16)
			| ((DWORD)rtc.hour << 11)
			| ((DWORD)rtc.min << 5)
     40a:	ea40 0053 	orr.w	r0, r0, r3, lsr #1

	/* Get local time */
	rtc_gettime(&rtc);

	/* Pack date and time into a DWORD variable */
	return	  ((DWORD)(rtc.year - 1980) << 25)
     40e:	f8bd 3000 	ldrh.w	r3, [sp]
     412:	f5a3 63f6 	sub.w	r3, r3, #1968	; 0x7b0
     416:	3b0c      	subs	r3, #12
			| ((DWORD)rtc.month << 21)
			| ((DWORD)rtc.mday << 16)
			| ((DWORD)rtc.hour << 11)
			| ((DWORD)rtc.min << 5)
			| ((DWORD)rtc.sec >> 1);
}
     418:	ea40 6043 	orr.w	r0, r0, r3, lsl #25
     41c:	bd0e      	pop	{r1, r2, r3, pc}

0000041e <main>:




int main (void)
{
     41e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	RTC rtc;
	static const char *ft[] = {"", "FAT12", "FAT16", "FAT32", "exFAT"};


	/* Set LED port as output */
	FIO0DIR = 1 << 22;
     422:	4b97      	ldr	r3, [pc, #604]	; (680 <main+0x262>)
     424:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
     428:	601a      	str	r2, [r3, #0]

	/* Enable SysTick timer as 1 ms interval timer */
	SYST_RVR = 100000000 / 1000 - 1;
     42a:	4b96      	ldr	r3, [pc, #600]	; (684 <main+0x266>)
     42c:	4a96      	ldr	r2, [pc, #600]	; (688 <main+0x26a>)




int main (void)
{
     42e:	b098      	sub	sp, #96	; 0x60

	/* Set LED port as output */
	FIO0DIR = 1 << 22;

	/* Enable SysTick timer as 1 ms interval timer */
	SYST_RVR = 100000000 / 1000 - 1;
     430:	601a      	str	r2, [r3, #0]
	SYST_CSR = 0x07;
     432:	2207      	movs	r2, #7
     434:	f843 2c04 	str.w	r2, [r3, #-4]

	rtc_initialize();	/* Initiazlize RTC */
     438:	f001 f95c 	bl	16f4 <rtc_initialize>


	/* Initialize UART0 and attach it to xprintf module for console */
	uart0_init();
     43c:	f001 f90a 	bl	1654 <uart0_init>
	xdev_out(uart0_putc);
     440:	4a92      	ldr	r2, [pc, #584]	; (68c <main+0x26e>)
     442:	4b93      	ldr	r3, [pc, #588]	; (690 <main+0x272>)
	xdev_in(uart0_getc);
	xputs("LPC1768 test monitor\n");
     444:	4893      	ldr	r0, [pc, #588]	; (694 <main+0x276>)
	rtc_initialize();	/* Initiazlize RTC */


	/* Initialize UART0 and attach it to xprintf module for console */
	uart0_init();
	xdev_out(uart0_putc);
     446:	601a      	str	r2, [r3, #0]
	xdev_in(uart0_getc);
     448:	4a93      	ldr	r2, [pc, #588]	; (698 <main+0x27a>)
     44a:	4b94      	ldr	r3, [pc, #592]	; (69c <main+0x27e>)
{
	char *ptr, *ptr2;
	long p1, p2, p3;
	BYTE res, b, drv = 0;
	UINT s1, s2, cnt, blen = sizeof Buff;
	DWORD ofs = 0, sect = 0, blk[2];
     44c:	2600      	movs	r6, #0


	/* Initialize UART0 and attach it to xprintf module for console */
	uart0_init();
	xdev_out(uart0_putc);
	xdev_in(uart0_getc);
     44e:	601a      	str	r2, [r3, #0]
	xputs("LPC1768 test monitor\n");
     450:	f001 fca0 	bl	1d94 <xputs>
	xprintf("LFN=%s, CP=%u\n", FF_USE_LFN ? "Enabled" : "Disabled", FF_CODE_PAGE);
     454:	4892      	ldr	r0, [pc, #584]	; (6a0 <main+0x282>)
     456:	4993      	ldr	r1, [pc, #588]	; (6a4 <main+0x286>)
     458:	f44f 7269 	mov.w	r2, #932	; 0x3a4
     45c:	f001 fd8e 	bl	1f7c <xprintf>
int main (void)
{
	char *ptr, *ptr2;
	long p1, p2, p3;
	BYTE res, b, drv = 0;
	UINT s1, s2, cnt, blen = sizeof Buff;
     460:	f44f 4480 	mov.w	r4, #16384	; 0x4000

int main (void)
{
	char *ptr, *ptr2;
	long p1, p2, p3;
	BYTE res, b, drv = 0;
     464:	4635      	mov	r5, r6
	xdev_in(uart0_getc);
	xputs("LPC1768 test monitor\n");
	xprintf("LFN=%s, CP=%u\n", FF_USE_LFN ? "Enabled" : "Disabled", FF_CODE_PAGE);

	for (;;) {
		xputc('>');
     466:	203e      	movs	r0, #62	; 0x3e
		xgets(Line, sizeof Line);

		ptr = Line;
		switch (*ptr++) {
     468:	f8df 823c 	ldr.w	r8, [pc, #572]	; 6a8 <main+0x28a>
	xdev_in(uart0_getc);
	xputs("LPC1768 test monitor\n");
	xprintf("LFN=%s, CP=%u\n", FF_USE_LFN ? "Enabled" : "Disabled", FF_CODE_PAGE);

	for (;;) {
		xputc('>');
     46c:	f001 fc7a 	bl	1d64 <xputc>
		xgets(Line, sizeof Line);
     470:	488d      	ldr	r0, [pc, #564]	; (6a8 <main+0x28a>)
     472:	f44f 7180 	mov.w	r1, #256	; 0x100
     476:	f001 fdff 	bl	2078 <xgets>

		ptr = Line;
		switch (*ptr++) {
     47a:	4642      	mov	r2, r8
     47c:	f812 3b01 	ldrb.w	r3, [r2], #1
     480:	4647      	mov	r7, r8
     482:	2b66      	cmp	r3, #102	; 0x66
     484:	9216      	str	r2, [sp, #88]	; 0x58
     486:	f000 82f2 	beq.w	a6e <main+0x650>
     48a:	d808      	bhi.n	49e <main+0x80>
     48c:	2b62      	cmp	r3, #98	; 0x62
     48e:	f000 8211 	beq.w	8b4 <main+0x496>
     492:	2b64      	cmp	r3, #100	; 0x64
     494:	f000 80e1 	beq.w	65a <main+0x23c>
     498:	2b3f      	cmp	r3, #63	; 0x3f
     49a:	d1e4      	bne.n	466 <main+0x48>
     49c:	e008      	b.n	4b0 <main+0x92>
     49e:	2b70      	cmp	r3, #112	; 0x70
     4a0:	f000 8751 	beq.w	1346 <main+0xf28>
     4a4:	2b74      	cmp	r3, #116	; 0x74
     4a6:	f000 8767 	beq.w	1378 <main+0xf5a>
     4aa:	2b6d      	cmp	r3, #109	; 0x6d
     4ac:	d1db      	bne.n	466 <main+0x48>
     4ae:	e003      	b.n	4b8 <main+0x9a>
		case '?' :	/* Show Command List */
			xputs(HelpMsg);
     4b0:	487e      	ldr	r0, [pc, #504]	; (6ac <main+0x28e>)
     4b2:	f001 fc6f 	bl	1d94 <xputs>
			break;
     4b6:	e7d6      	b.n	466 <main+0x48>

		case 'm' :	/* Memory dump/fill/edit */
			switch (*ptr++) {
     4b8:	f898 3001 	ldrb.w	r3, [r8, #1]
     4bc:	f108 0202 	add.w	r2, r8, #2
     4c0:	2b65      	cmp	r3, #101	; 0x65
     4c2:	9216      	str	r2, [sp, #88]	; 0x58
     4c4:	d064      	beq.n	590 <main+0x172>
     4c6:	2b66      	cmp	r3, #102	; 0x66
     4c8:	d041      	beq.n	54e <main+0x130>
     4ca:	2b64      	cmp	r3, #100	; 0x64
     4cc:	d1cb      	bne.n	466 <main+0x48>
			case 'd' :	/* md[b|h|w] <address> [<count>] - Dump memory */
				switch (*ptr++) {
     4ce:	f898 3002 	ldrb.w	r3, [r8, #2]
     4d2:	f108 0203 	add.w	r2, r8, #3
     4d6:	2b68      	cmp	r3, #104	; 0x68
     4d8:	9216      	str	r2, [sp, #88]	; 0x58
     4da:	d003      	beq.n	4e4 <main+0xc6>
     4dc:	2b77      	cmp	r3, #119	; 0x77
     4de:	d103      	bne.n	4e8 <main+0xca>
				case 'w': p3 = DW_LONG; break;
     4e0:	3b73      	subs	r3, #115	; 0x73
     4e2:	e002      	b.n	4ea <main+0xcc>
				case 'h': p3 = DW_SHORT; break;
     4e4:	2302      	movs	r3, #2
     4e6:	e000      	b.n	4ea <main+0xcc>
				default: p3 = DW_CHAR;
     4e8:	2301      	movs	r3, #1
				}
				if (!xatoi(&ptr, &p1)) break;
     4ea:	a816      	add	r0, sp, #88	; 0x58
     4ec:	a915      	add	r1, sp, #84	; 0x54
			switch (*ptr++) {
			case 'd' :	/* md[b|h|w] <address> [<count>] - Dump memory */
				switch (*ptr++) {
				case 'w': p3 = DW_LONG; break;
				case 'h': p3 = DW_SHORT; break;
				default: p3 = DW_CHAR;
     4ee:	9313      	str	r3, [sp, #76]	; 0x4c
				}
				if (!xatoi(&ptr, &p1)) break;
     4f0:	f001 fdf6 	bl	20e0 <xatoi>
     4f4:	2800      	cmp	r0, #0
     4f6:	d0b6      	beq.n	466 <main+0x48>
				if (!xatoi(&ptr, &p2)) p2 = 128 / p3;
     4f8:	a816      	add	r0, sp, #88	; 0x58
     4fa:	a914      	add	r1, sp, #80	; 0x50
     4fc:	f001 fdf0 	bl	20e0 <xatoi>
     500:	b920      	cbnz	r0, 50c <main+0xee>
     502:	9b13      	ldr	r3, [sp, #76]	; 0x4c
     504:	2280      	movs	r2, #128	; 0x80
     506:	fb92 f3f3 	sdiv	r3, r2, r3
     50a:	9314      	str	r3, [sp, #80]	; 0x50
				for (ptr = (char*)p1; p2 >= 16 / p3; ptr += 16, p2 -= 16 / p3)
     50c:	9b15      	ldr	r3, [sp, #84]	; 0x54
     50e:	9316      	str	r3, [sp, #88]	; 0x58
     510:	e00e      	b.n	530 <main+0x112>
					put_dump(ptr, (DWORD)ptr, 16 / p3, p3);
     512:	9816      	ldr	r0, [sp, #88]	; 0x58
     514:	4601      	mov	r1, r0
     516:	f001 fd67 	bl	1fe8 <put_dump>
				case 'h': p3 = DW_SHORT; break;
				default: p3 = DW_CHAR;
				}
				if (!xatoi(&ptr, &p1)) break;
				if (!xatoi(&ptr, &p2)) p2 = 128 / p3;
				for (ptr = (char*)p1; p2 >= 16 / p3; ptr += 16, p2 -= 16 / p3)
     51a:	9b16      	ldr	r3, [sp, #88]	; 0x58
     51c:	f06f 020f 	mvn.w	r2, #15
     520:	3310      	adds	r3, #16
     522:	9316      	str	r3, [sp, #88]	; 0x58
     524:	9b13      	ldr	r3, [sp, #76]	; 0x4c
     526:	fb92 f3f3 	sdiv	r3, r2, r3
     52a:	9a14      	ldr	r2, [sp, #80]	; 0x50
     52c:	18d3      	adds	r3, r2, r3
     52e:	9314      	str	r3, [sp, #80]	; 0x50
     530:	9b13      	ldr	r3, [sp, #76]	; 0x4c
     532:	2210      	movs	r2, #16
     534:	9f14      	ldr	r7, [sp, #80]	; 0x50
     536:	fb92 f2f3 	sdiv	r2, r2, r3
     53a:	4297      	cmp	r7, r2
     53c:	dae9      	bge.n	512 <main+0xf4>
					put_dump(ptr, (DWORD)ptr, 16 / p3, p3);
				if (p2) put_dump((BYTE*)ptr, (UINT)ptr, p2, p3);
     53e:	2f00      	cmp	r7, #0
     540:	d091      	beq.n	466 <main+0x48>
     542:	9816      	ldr	r0, [sp, #88]	; 0x58
     544:	463a      	mov	r2, r7
     546:	4601      	mov	r1, r0
     548:	f001 fd4e 	bl	1fe8 <put_dump>
     54c:	e78b      	b.n	466 <main+0x48>
				break;
			case 'f' :	/* mf <address> <value> <count> - Fill memory */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2) || !xatoi(&ptr, &p3)) break;
     54e:	a816      	add	r0, sp, #88	; 0x58
     550:	a915      	add	r1, sp, #84	; 0x54
     552:	f001 fdc5 	bl	20e0 <xatoi>
     556:	2800      	cmp	r0, #0
     558:	d085      	beq.n	466 <main+0x48>
     55a:	a816      	add	r0, sp, #88	; 0x58
     55c:	a914      	add	r1, sp, #80	; 0x50
     55e:	f001 fdbf 	bl	20e0 <xatoi>
     562:	2800      	cmp	r0, #0
     564:	f43f af7f 	beq.w	466 <main+0x48>
     568:	a816      	add	r0, sp, #88	; 0x58
     56a:	a913      	add	r1, sp, #76	; 0x4c
     56c:	f001 fdb8 	bl	20e0 <xatoi>
     570:	2800      	cmp	r0, #0
     572:	f43f af78 	beq.w	466 <main+0x48>
     576:	e005      	b.n	584 <main+0x166>
				while (p3--) {
					*(BYTE*)p1 = (BYTE)p2;
     578:	9b15      	ldr	r3, [sp, #84]	; 0x54
     57a:	9a14      	ldr	r2, [sp, #80]	; 0x50
     57c:	701a      	strb	r2, [r3, #0]
					p1++;
     57e:	9b15      	ldr	r3, [sp, #84]	; 0x54
     580:	3301      	adds	r3, #1
     582:	9315      	str	r3, [sp, #84]	; 0x54
					put_dump(ptr, (DWORD)ptr, 16 / p3, p3);
				if (p2) put_dump((BYTE*)ptr, (UINT)ptr, p2, p3);
				break;
			case 'f' :	/* mf <address> <value> <count> - Fill memory */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2) || !xatoi(&ptr, &p3)) break;
				while (p3--) {
     584:	9b13      	ldr	r3, [sp, #76]	; 0x4c
     586:	1e5a      	subs	r2, r3, #1
     588:	9213      	str	r2, [sp, #76]	; 0x4c
     58a:	2b00      	cmp	r3, #0
     58c:	d1f4      	bne.n	578 <main+0x15a>
     58e:	e76a      	b.n	466 <main+0x48>
					*(BYTE*)p1 = (BYTE)p2;
					p1++;
				}
				break;
			case 'e' :	/* me[b|h|w] <address> [<value> ...] - Edit memory */
				switch (*ptr++) {	/* Get data width */
     590:	f898 3002 	ldrb.w	r3, [r8, #2]
     594:	1cfa      	adds	r2, r7, #3
     596:	2b68      	cmp	r3, #104	; 0x68
     598:	9216      	str	r2, [sp, #88]	; 0x58
     59a:	d003      	beq.n	5a4 <main+0x186>
     59c:	2b77      	cmp	r3, #119	; 0x77
     59e:	d103      	bne.n	5a8 <main+0x18a>
				case 'w': p3 = DW_LONG; break;
     5a0:	3b73      	subs	r3, #115	; 0x73
     5a2:	e002      	b.n	5aa <main+0x18c>
				case 'h': p3 = DW_SHORT; break;
     5a4:	2302      	movs	r3, #2
     5a6:	e000      	b.n	5aa <main+0x18c>
				default: p3 = DW_CHAR;
     5a8:	2301      	movs	r3, #1
				}
				if (!xatoi(&ptr, &p1)) break;	/* Get start address */
     5aa:	a816      	add	r0, sp, #88	; 0x58
     5ac:	a915      	add	r1, sp, #84	; 0x54
				break;
			case 'e' :	/* me[b|h|w] <address> [<value> ...] - Edit memory */
				switch (*ptr++) {	/* Get data width */
				case 'w': p3 = DW_LONG; break;
				case 'h': p3 = DW_SHORT; break;
				default: p3 = DW_CHAR;
     5ae:	9313      	str	r3, [sp, #76]	; 0x4c
				}
				if (!xatoi(&ptr, &p1)) break;	/* Get start address */
     5b0:	f001 fd96 	bl	20e0 <xatoi>
     5b4:	2800      	cmp	r0, #0
     5b6:	f43f af56 	beq.w	466 <main+0x48>
				if (xatoi(&ptr, &p2)) {	/* 2nd parameter is given (direct mode) */
     5ba:	a816      	add	r0, sp, #88	; 0x58
     5bc:	a914      	add	r1, sp, #80	; 0x50
     5be:	f001 fd8f 	bl	20e0 <xatoi>
     5c2:	b1b0      	cbz	r0, 5f2 <main+0x1d4>
					do {
						switch (p3) {
     5c4:	9913      	ldr	r1, [sp, #76]	; 0x4c
     5c6:	9b15      	ldr	r3, [sp, #84]	; 0x54
     5c8:	2902      	cmp	r1, #2
     5ca:	9a14      	ldr	r2, [sp, #80]	; 0x50
     5cc:	d003      	beq.n	5d6 <main+0x1b8>
     5ce:	2904      	cmp	r1, #4
     5d0:	d103      	bne.n	5da <main+0x1bc>
						case DW_LONG: *(DWORD*)p1 = (DWORD)p2; break;
     5d2:	601a      	str	r2, [r3, #0]
     5d4:	e002      	b.n	5dc <main+0x1be>
						case DW_SHORT: *(WORD*)p1 = (WORD)p2; break;
     5d6:	801a      	strh	r2, [r3, #0]
     5d8:	e000      	b.n	5dc <main+0x1be>
						default: *(BYTE*)p1 = (BYTE)p2;
     5da:	701a      	strb	r2, [r3, #0]
						}
						p1 += p3;
     5dc:	9a15      	ldr	r2, [sp, #84]	; 0x54
     5de:	9b13      	ldr	r3, [sp, #76]	; 0x4c
					} while (xatoi(&ptr, &p2));	/* Get next value */
     5e0:	a816      	add	r0, sp, #88	; 0x58
						switch (p3) {
						case DW_LONG: *(DWORD*)p1 = (DWORD)p2; break;
						case DW_SHORT: *(WORD*)p1 = (WORD)p2; break;
						default: *(BYTE*)p1 = (BYTE)p2;
						}
						p1 += p3;
     5e2:	18d3      	adds	r3, r2, r3
					} while (xatoi(&ptr, &p2));	/* Get next value */
     5e4:	a914      	add	r1, sp, #80	; 0x50
						switch (p3) {
						case DW_LONG: *(DWORD*)p1 = (DWORD)p2; break;
						case DW_SHORT: *(WORD*)p1 = (WORD)p2; break;
						default: *(BYTE*)p1 = (BYTE)p2;
						}
						p1 += p3;
     5e6:	9315      	str	r3, [sp, #84]	; 0x54
					} while (xatoi(&ptr, &p2));	/* Get next value */
     5e8:	f001 fd7a 	bl	20e0 <xatoi>
     5ec:	2800      	cmp	r0, #0
     5ee:	d1e9      	bne.n	5c4 <main+0x1a6>
     5f0:	e739      	b.n	466 <main+0x48>
					break;
				}
				for (;;) {				/* 2nd parameter is not given (interactive mode) */
					switch (p3) {
     5f2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
     5f4:	9915      	ldr	r1, [sp, #84]	; 0x54
     5f6:	2b02      	cmp	r3, #2
     5f8:	d004      	beq.n	604 <main+0x1e6>
     5fa:	2b04      	cmp	r3, #4
     5fc:	d105      	bne.n	60a <main+0x1ec>
					case DW_LONG: xprintf("%08X 0x%08X-", p1, *(DWORD*)p1); break;
     5fe:	482c      	ldr	r0, [pc, #176]	; (6b0 <main+0x292>)
     600:	680a      	ldr	r2, [r1, #0]
     602:	e004      	b.n	60e <main+0x1f0>
					case DW_SHORT: xprintf("%08X 0x%04X-", p1, *(WORD*)p1); break;
     604:	482b      	ldr	r0, [pc, #172]	; (6b4 <main+0x296>)
     606:	880a      	ldrh	r2, [r1, #0]
     608:	e001      	b.n	60e <main+0x1f0>
					default: xprintf("%08X 0x%02X-", p1, *(BYTE*)p1);
     60a:	482b      	ldr	r0, [pc, #172]	; (6b8 <main+0x29a>)
     60c:	780a      	ldrb	r2, [r1, #0]
     60e:	f001 fcb5 	bl	1f7c <xprintf>
					}
					ptr = Line; xgets(ptr, sizeof Line);
     612:	4638      	mov	r0, r7
     614:	f44f 7180 	mov.w	r1, #256	; 0x100
     618:	9716      	str	r7, [sp, #88]	; 0x58
     61a:	f001 fd2d 	bl	2078 <xgets>
					if (*ptr == '.') break;
     61e:	9b16      	ldr	r3, [sp, #88]	; 0x58
     620:	781b      	ldrb	r3, [r3, #0]
     622:	2b2e      	cmp	r3, #46	; 0x2e
     624:	f43f af1f 	beq.w	466 <main+0x48>
					if ((BYTE)*ptr >= ' ') {
     628:	2b1f      	cmp	r3, #31
     62a:	d911      	bls.n	650 <main+0x232>
						if (!xatoi(&ptr, &p2)) continue;
     62c:	a816      	add	r0, sp, #88	; 0x58
     62e:	a914      	add	r1, sp, #80	; 0x50
     630:	f001 fd56 	bl	20e0 <xatoi>
     634:	2800      	cmp	r0, #0
     636:	d0dc      	beq.n	5f2 <main+0x1d4>
						switch (p3) {
     638:	9913      	ldr	r1, [sp, #76]	; 0x4c
     63a:	9b15      	ldr	r3, [sp, #84]	; 0x54
     63c:	2902      	cmp	r1, #2
     63e:	9a14      	ldr	r2, [sp, #80]	; 0x50
     640:	d003      	beq.n	64a <main+0x22c>
     642:	2904      	cmp	r1, #4
     644:	d103      	bne.n	64e <main+0x230>
						case DW_LONG: *(DWORD*)p1 = (DWORD)p2; break;
     646:	601a      	str	r2, [r3, #0]
     648:	e002      	b.n	650 <main+0x232>
						case DW_SHORT: *(WORD*)p1 = (WORD)p2; break;
     64a:	801a      	strh	r2, [r3, #0]
     64c:	e000      	b.n	650 <main+0x232>
						default: *(BYTE*)p1 = (BYTE)p2;
     64e:	701a      	strb	r2, [r3, #0]
						}
					}
					p1 += p3;
     650:	9a15      	ldr	r2, [sp, #84]	; 0x54
     652:	9b13      	ldr	r3, [sp, #76]	; 0x4c
     654:	18d3      	adds	r3, r2, r3
     656:	9315      	str	r3, [sp, #84]	; 0x54
     658:	e7cb      	b.n	5f2 <main+0x1d4>
				break;
			}
			break;

		case 'd' :	/* Disk I/O layer controls */
			switch (*ptr++) {
     65a:	f898 3001 	ldrb.w	r3, [r8, #1]
     65e:	f108 0202 	add.w	r2, r8, #2
     662:	2b64      	cmp	r3, #100	; 0x64
     664:	9216      	str	r2, [sp, #88]	; 0x58
     666:	d029      	beq.n	6bc <main+0x29e>
     668:	d803      	bhi.n	672 <main+0x254>
     66a:	2b63      	cmp	r3, #99	; 0x63
     66c:	f47f aefb 	bne.w	466 <main+0x48>
     670:	e0e4      	b.n	83c <main+0x41e>
     672:	2b69      	cmp	r3, #105	; 0x69
     674:	d059      	beq.n	72a <main+0x30c>
     676:	2b73      	cmp	r3, #115	; 0x73
     678:	f47f aef5 	bne.w	466 <main+0x48>
     67c:	e065      	b.n	74a <main+0x32c>
     67e:	bf00      	nop
     680:	2009c000 	.word	0x2009c000
     684:	e000e014 	.word	0xe000e014
     688:	0001869f 	.word	0x0001869f
     68c:	00001605 	.word	0x00001605
     690:	10004914 	.word	0x10004914
     694:	00005875 	.word	0x00005875
     698:	000015d9 	.word	0x000015d9
     69c:	10004910 	.word	0x10004910
     6a0:	0000588b 	.word	0x0000588b
     6a4:	0000589a 	.word	0x0000589a
     6a8:	1000480c 	.word	0x1000480c
     6ac:	0000525f 	.word	0x0000525f
     6b0:	000058a3 	.word	0x000058a3
     6b4:	000058b0 	.word	0x000058b0
     6b8:	000058bd 	.word	0x000058bd
			case 'd' :	/* dd [<pd#> <sect>] - Dump secrtor */
				if (!xatoi(&ptr, &p1)) {
     6bc:	a816      	add	r0, sp, #88	; 0x58
     6be:	a915      	add	r1, sp, #84	; 0x54
     6c0:	f001 fd0e 	bl	20e0 <xatoi>
     6c4:	b910      	cbnz	r0, 6cc <main+0x2ae>
					p1 = drv; p2 = sect;
     6c6:	9515      	str	r5, [sp, #84]	; 0x54
     6c8:	9614      	str	r6, [sp, #80]	; 0x50
     6ca:	e006      	b.n	6da <main+0x2bc>
				} else {
					if (!xatoi(&ptr, &p2)) break;
     6cc:	a816      	add	r0, sp, #88	; 0x58
     6ce:	a914      	add	r1, sp, #80	; 0x50
     6d0:	f001 fd06 	bl	20e0 <xatoi>
     6d4:	2800      	cmp	r0, #0
     6d6:	f43f aec6 	beq.w	466 <main+0x48>
				}
				drv = (BYTE)p1; sect = p2;
     6da:	f89d 5054 	ldrb.w	r5, [sp, #84]	; 0x54
     6de:	9f14      	ldr	r7, [sp, #80]	; 0x50
				res = disk_read(drv, Buff, sect, 1);
     6e0:	4628      	mov	r0, r5
     6e2:	49a6      	ldr	r1, [pc, #664]	; (97c <main+0x55e>)
     6e4:	463a      	mov	r2, r7
     6e6:	2301      	movs	r3, #1
     6e8:	f001 ff72 	bl	25d0 <disk_read>
				if (res) { xprintf("rc=%d\n", (WORD)res); break; }
     6ec:	4680      	mov	r8, r0
     6ee:	b128      	cbz	r0, 6fc <main+0x2de>
     6f0:	48a3      	ldr	r0, [pc, #652]	; (980 <main+0x562>)
     6f2:	4641      	mov	r1, r8
     6f4:	f001 fc42 	bl	1f7c <xprintf>
				if (!xatoi(&ptr, &p1)) {
					p1 = drv; p2 = sect;
				} else {
					if (!xatoi(&ptr, &p2)) break;
				}
				drv = (BYTE)p1; sect = p2;
     6f8:	463e      	mov	r6, r7
				res = disk_read(drv, Buff, sect, 1);
				if (res) { xprintf("rc=%d\n", (WORD)res); break; }
     6fa:	e6b4      	b.n	466 <main+0x48>
				xprintf("PD#:%u LBA:%lu\n", drv, sect++);
     6fc:	463a      	mov	r2, r7
     6fe:	48a1      	ldr	r0, [pc, #644]	; (984 <main+0x566>)
     700:	4629      	mov	r1, r5
     702:	f001 fc3b 	bl	1f7c <xprintf>
				for (ptr=(char*)Buff, ofs = 0; ofs < 0x200; ptr += 16, ofs += 16)
     706:	4b9d      	ldr	r3, [pc, #628]	; (97c <main+0x55e>)
					if (!xatoi(&ptr, &p2)) break;
				}
				drv = (BYTE)p1; sect = p2;
				res = disk_read(drv, Buff, sect, 1);
				if (res) { xprintf("rc=%d\n", (WORD)res); break; }
				xprintf("PD#:%u LBA:%lu\n", drv, sect++);
     708:	1c7e      	adds	r6, r7, #1
				for (ptr=(char*)Buff, ofs = 0; ofs < 0x200; ptr += 16, ofs += 16)
     70a:	9316      	str	r3, [sp, #88]	; 0x58
     70c:	4647      	mov	r7, r8
					put_dump((BYTE*)ptr, ofs, 16, DW_CHAR);
     70e:	2301      	movs	r3, #1
     710:	4639      	mov	r1, r7
     712:	2210      	movs	r2, #16
     714:	9816      	ldr	r0, [sp, #88]	; 0x58
     716:	f001 fc67 	bl	1fe8 <put_dump>
				}
				drv = (BYTE)p1; sect = p2;
				res = disk_read(drv, Buff, sect, 1);
				if (res) { xprintf("rc=%d\n", (WORD)res); break; }
				xprintf("PD#:%u LBA:%lu\n", drv, sect++);
				for (ptr=(char*)Buff, ofs = 0; ofs < 0x200; ptr += 16, ofs += 16)
     71a:	9b16      	ldr	r3, [sp, #88]	; 0x58
     71c:	3710      	adds	r7, #16
     71e:	3310      	adds	r3, #16
     720:	f5b7 7f00 	cmp.w	r7, #512	; 0x200
     724:	9316      	str	r3, [sp, #88]	; 0x58
     726:	d1f2      	bne.n	70e <main+0x2f0>
     728:	e69d      	b.n	466 <main+0x48>
					put_dump((BYTE*)ptr, ofs, 16, DW_CHAR);
				break;

			case 'i' :	/* di <pd#> - Initialize disk */
				if (!xatoi(&ptr, &p1)) break;
     72a:	a816      	add	r0, sp, #88	; 0x58
     72c:	a915      	add	r1, sp, #84	; 0x54
     72e:	f001 fcd7 	bl	20e0 <xatoi>
     732:	2800      	cmp	r0, #0
     734:	f43f ae97 	beq.w	466 <main+0x48>
				xprintf("rc=%d\n", (WORD)disk_initialize((BYTE)p1));
     738:	f89d 0054 	ldrb.w	r0, [sp, #84]	; 0x54
     73c:	f001 fe66 	bl	240c <disk_initialize>
     740:	4601      	mov	r1, r0
     742:	488f      	ldr	r0, [pc, #572]	; (980 <main+0x562>)
     744:	f001 fc1a 	bl	1f7c <xprintf>
				break;
     748:	e68d      	b.n	466 <main+0x48>

			case 's' :	/* ds <pd#> - Show disk status */
				if (!xatoi(&ptr, &p1)) break;
     74a:	a816      	add	r0, sp, #88	; 0x58
     74c:	a915      	add	r1, sp, #84	; 0x54
     74e:	f001 fcc7 	bl	20e0 <xatoi>
     752:	2800      	cmp	r0, #0
     754:	f43f ae87 	beq.w	466 <main+0x48>
				if (disk_ioctl((BYTE)p1, GET_SECTOR_COUNT, &p2) == RES_OK)
     758:	f89d 0054 	ldrb.w	r0, [sp, #84]	; 0x54
     75c:	2101      	movs	r1, #1
     75e:	aa14      	add	r2, sp, #80	; 0x50
     760:	f001 ffc4 	bl	26ec <disk_ioctl>
     764:	b918      	cbnz	r0, 76e <main+0x350>
					{ xprintf("Drive size: %lu sectors\n", p2); }
     766:	4888      	ldr	r0, [pc, #544]	; (988 <main+0x56a>)
     768:	9914      	ldr	r1, [sp, #80]	; 0x50
     76a:	f001 fc07 	bl	1f7c <xprintf>
				if (disk_ioctl((BYTE)p1, GET_BLOCK_SIZE, &p2) == RES_OK)
     76e:	f89d 0054 	ldrb.w	r0, [sp, #84]	; 0x54
     772:	2103      	movs	r1, #3
     774:	aa14      	add	r2, sp, #80	; 0x50
     776:	f001 ffb9 	bl	26ec <disk_ioctl>
     77a:	b918      	cbnz	r0, 784 <main+0x366>
					{ xprintf("Block size: %lu sectors\n", p2); }
     77c:	4883      	ldr	r0, [pc, #524]	; (98c <main+0x56e>)
     77e:	9914      	ldr	r1, [sp, #80]	; 0x50
     780:	f001 fbfc 	bl	1f7c <xprintf>
				if (disk_ioctl((BYTE)p1, MMC_GET_TYPE, &b) == RES_OK)
     784:	f89d 0054 	ldrb.w	r0, [sp, #84]	; 0x54
     788:	2132      	movs	r1, #50	; 0x32
     78a:	f10d 025f 	add.w	r2, sp, #95	; 0x5f
     78e:	f001 ffad 	bl	26ec <disk_ioctl>
     792:	b920      	cbnz	r0, 79e <main+0x380>
					{ xprintf("Media type: %u\n", b); }
     794:	487e      	ldr	r0, [pc, #504]	; (990 <main+0x572>)
     796:	f89d 105f 	ldrb.w	r1, [sp, #95]	; 0x5f
     79a:	f001 fbef 	bl	1f7c <xprintf>
				if (disk_ioctl((BYTE)p1, MMC_GET_CSD, Buff) == RES_OK)
     79e:	f89d 0054 	ldrb.w	r0, [sp, #84]	; 0x54
     7a2:	2133      	movs	r1, #51	; 0x33
     7a4:	4a75      	ldr	r2, [pc, #468]	; (97c <main+0x55e>)
     7a6:	f001 ffa1 	bl	26ec <disk_ioctl>
     7aa:	4607      	mov	r7, r0
     7ac:	b940      	cbnz	r0, 7c0 <main+0x3a2>
					{ xputs("CSD:\n"); put_dump(Buff, 0, 16, DW_CHAR); }
     7ae:	4879      	ldr	r0, [pc, #484]	; (994 <main+0x576>)
     7b0:	f001 faf0 	bl	1d94 <xputs>
     7b4:	4871      	ldr	r0, [pc, #452]	; (97c <main+0x55e>)
     7b6:	4639      	mov	r1, r7
     7b8:	2210      	movs	r2, #16
     7ba:	2301      	movs	r3, #1
     7bc:	f001 fc14 	bl	1fe8 <put_dump>
				if (disk_ioctl((BYTE)p1, MMC_GET_CID, Buff) == RES_OK)
     7c0:	f89d 0054 	ldrb.w	r0, [sp, #84]	; 0x54
     7c4:	2134      	movs	r1, #52	; 0x34
     7c6:	4a6d      	ldr	r2, [pc, #436]	; (97c <main+0x55e>)
     7c8:	f001 ff90 	bl	26ec <disk_ioctl>
     7cc:	4607      	mov	r7, r0
     7ce:	b940      	cbnz	r0, 7e2 <main+0x3c4>
					{ xputs("CID:\n"); put_dump(Buff, 0, 16, DW_CHAR); }
     7d0:	4871      	ldr	r0, [pc, #452]	; (998 <main+0x57a>)
     7d2:	f001 fadf 	bl	1d94 <xputs>
     7d6:	4869      	ldr	r0, [pc, #420]	; (97c <main+0x55e>)
     7d8:	4639      	mov	r1, r7
     7da:	2210      	movs	r2, #16
     7dc:	2301      	movs	r3, #1
     7de:	f001 fc03 	bl	1fe8 <put_dump>
				if (disk_ioctl((BYTE)p1, MMC_GET_OCR, Buff) == RES_OK)
     7e2:	f89d 0054 	ldrb.w	r0, [sp, #84]	; 0x54
     7e6:	2135      	movs	r1, #53	; 0x35
     7e8:	4a64      	ldr	r2, [pc, #400]	; (97c <main+0x55e>)
     7ea:	f001 ff7f 	bl	26ec <disk_ioctl>
     7ee:	4607      	mov	r7, r0
     7f0:	b940      	cbnz	r0, 804 <main+0x3e6>
					{ xputs("OCR:\n"); put_dump(Buff, 0, 4, DW_CHAR); }
     7f2:	486a      	ldr	r0, [pc, #424]	; (99c <main+0x57e>)
     7f4:	f001 face 	bl	1d94 <xputs>
     7f8:	4860      	ldr	r0, [pc, #384]	; (97c <main+0x55e>)
     7fa:	4639      	mov	r1, r7
     7fc:	2204      	movs	r2, #4
     7fe:	2301      	movs	r3, #1
     800:	f001 fbf2 	bl	1fe8 <put_dump>
				if (disk_ioctl((BYTE)p1, MMC_GET_SDSTAT, Buff) == RES_OK) {
     804:	f89d 0054 	ldrb.w	r0, [sp, #84]	; 0x54
     808:	2136      	movs	r1, #54	; 0x36
     80a:	4a5c      	ldr	r2, [pc, #368]	; (97c <main+0x55e>)
     80c:	f001 ff6e 	bl	26ec <disk_ioctl>
     810:	4607      	mov	r7, r0
     812:	2800      	cmp	r0, #0
     814:	f47f ae27 	bne.w	466 <main+0x48>
					xputs("SD Status:\n");
     818:	4861      	ldr	r0, [pc, #388]	; (9a0 <main+0x582>)
     81a:	f001 fabb 	bl	1d94 <xputs>
					for (s1 = 0; s1 < 64; s1 += 16) put_dump(Buff+s1, s1, 16, DW_CHAR);
     81e:	9712      	str	r7, [sp, #72]	; 0x48
     820:	e008      	b.n	834 <main+0x416>
     822:	4856      	ldr	r0, [pc, #344]	; (97c <main+0x55e>)
     824:	2301      	movs	r3, #1
     826:	1840      	adds	r0, r0, r1
     828:	2210      	movs	r2, #16
     82a:	f001 fbdd 	bl	1fe8 <put_dump>
     82e:	9b12      	ldr	r3, [sp, #72]	; 0x48
     830:	3310      	adds	r3, #16
     832:	9312      	str	r3, [sp, #72]	; 0x48
     834:	9912      	ldr	r1, [sp, #72]	; 0x48
     836:	293f      	cmp	r1, #63	; 0x3f
     838:	d9f3      	bls.n	822 <main+0x404>
     83a:	e614      	b.n	466 <main+0x48>
				}
				break;

			case 'c' :	/* Disk ioctl */
				switch (*ptr++) {
     83c:	f898 3002 	ldrb.w	r3, [r8, #2]
     840:	f108 0203 	add.w	r2, r8, #3
     844:	2b65      	cmp	r3, #101	; 0x65
     846:	9216      	str	r2, [sp, #88]	; 0x58
     848:	d014      	beq.n	874 <main+0x456>
     84a:	2b73      	cmp	r3, #115	; 0x73
     84c:	f47f ae0b 	bne.w	466 <main+0x48>
				case 's' :	/* dcs <pd#> - CTRL_SYNC */
					if (!xatoi(&ptr, &p1)) break;
     850:	a816      	add	r0, sp, #88	; 0x58
     852:	a915      	add	r1, sp, #84	; 0x54
     854:	f001 fc44 	bl	20e0 <xatoi>
     858:	2800      	cmp	r0, #0
     85a:	f43f ae04 	beq.w	466 <main+0x48>
					xprintf("rc=%d\n", disk_ioctl((BYTE)p1, CTRL_SYNC, 0));
     85e:	2100      	movs	r1, #0
     860:	460a      	mov	r2, r1
     862:	f89d 0054 	ldrb.w	r0, [sp, #84]	; 0x54
     866:	f001 ff41 	bl	26ec <disk_ioctl>
     86a:	4601      	mov	r1, r0
     86c:	4844      	ldr	r0, [pc, #272]	; (980 <main+0x562>)
     86e:	f001 fb85 	bl	1f7c <xprintf>
					break;
     872:	e5f8      	b.n	466 <main+0x48>
				case 'e' :	/* dce <pd#> <s.lba> <e.lba> - CTRL_TRIM */
					if (!xatoi(&ptr, &p1) || !xatoi(&ptr, (long*)&blk[0]) || !xatoi(&ptr, (long*)&blk[1])) break;
     874:	a816      	add	r0, sp, #88	; 0x58
     876:	a915      	add	r1, sp, #84	; 0x54
     878:	f001 fc32 	bl	20e0 <xatoi>
     87c:	2800      	cmp	r0, #0
     87e:	f43f adf2 	beq.w	466 <main+0x48>
     882:	a816      	add	r0, sp, #88	; 0x58
     884:	a90d      	add	r1, sp, #52	; 0x34
     886:	f001 fc2b 	bl	20e0 <xatoi>
     88a:	2800      	cmp	r0, #0
     88c:	f43f adeb 	beq.w	466 <main+0x48>
     890:	a816      	add	r0, sp, #88	; 0x58
     892:	a90e      	add	r1, sp, #56	; 0x38
     894:	f001 fc24 	bl	20e0 <xatoi>
     898:	2800      	cmp	r0, #0
     89a:	f43f ade4 	beq.w	466 <main+0x48>
					xprintf("rc=%d\n", disk_ioctl((BYTE)p1, CTRL_TRIM, blk));
     89e:	2104      	movs	r1, #4
     8a0:	f89d 0054 	ldrb.w	r0, [sp, #84]	; 0x54
     8a4:	aa0d      	add	r2, sp, #52	; 0x34
     8a6:	f001 ff21 	bl	26ec <disk_ioctl>
     8aa:	4601      	mov	r1, r0
     8ac:	4834      	ldr	r0, [pc, #208]	; (980 <main+0x562>)
     8ae:	f001 fb65 	bl	1f7c <xprintf>
					break;
     8b2:	e5d8      	b.n	466 <main+0x48>
				break;
			}
			break;

		case 'b' :	/* Buffer controls */
			switch (*ptr++) {
     8b4:	f898 3001 	ldrb.w	r3, [r8, #1]
     8b8:	1cba      	adds	r2, r7, #2
     8ba:	2b66      	cmp	r3, #102	; 0x66
     8bc:	9216      	str	r2, [sp, #88]	; 0x58
     8be:	f000 80c7 	beq.w	a50 <main+0x632>
     8c2:	d805      	bhi.n	8d0 <main+0x4b2>
     8c4:	2b64      	cmp	r3, #100	; 0x64
     8c6:	d009      	beq.n	8dc <main+0x4be>
     8c8:	2b65      	cmp	r3, #101	; 0x65
     8ca:	f47f adcc 	bne.w	466 <main+0x48>
     8ce:	e024      	b.n	91a <main+0x4fc>
     8d0:	2b72      	cmp	r3, #114	; 0x72
     8d2:	d07b      	beq.n	9cc <main+0x5ae>
     8d4:	2b77      	cmp	r3, #119	; 0x77
     8d6:	f47f adc6 	bne.w	466 <main+0x48>
     8da:	e098      	b.n	a0e <main+0x5f0>
			case 'd' :	/* bd <ofs> - Dump R/W buffer */
				if (!xatoi(&ptr, &p1)) break;
     8dc:	a816      	add	r0, sp, #88	; 0x58
     8de:	a915      	add	r1, sp, #84	; 0x54
     8e0:	f001 fbfe 	bl	20e0 <xatoi>
     8e4:	2800      	cmp	r0, #0
     8e6:	f43f adbe 	beq.w	466 <main+0x48>
				for (ptr=(char*)&Buff[p1], ofs = p1, cnt = 32; cnt; cnt--, ptr+=16, ofs+=16)
     8ea:	9f15      	ldr	r7, [sp, #84]	; 0x54
     8ec:	4b23      	ldr	r3, [pc, #140]	; (97c <main+0x55e>)
     8ee:	18fb      	adds	r3, r7, r3
     8f0:	9316      	str	r3, [sp, #88]	; 0x58
     8f2:	2320      	movs	r3, #32
     8f4:	9310      	str	r3, [sp, #64]	; 0x40
     8f6:	e00c      	b.n	912 <main+0x4f4>
					put_dump((BYTE*)ptr, ofs, 16, DW_CHAR);
     8f8:	4639      	mov	r1, r7
     8fa:	2301      	movs	r3, #1
     8fc:	9816      	ldr	r0, [sp, #88]	; 0x58
     8fe:	2210      	movs	r2, #16
     900:	f001 fb72 	bl	1fe8 <put_dump>

		case 'b' :	/* Buffer controls */
			switch (*ptr++) {
			case 'd' :	/* bd <ofs> - Dump R/W buffer */
				if (!xatoi(&ptr, &p1)) break;
				for (ptr=(char*)&Buff[p1], ofs = p1, cnt = 32; cnt; cnt--, ptr+=16, ofs+=16)
     904:	9b10      	ldr	r3, [sp, #64]	; 0x40
     906:	3710      	adds	r7, #16
     908:	3b01      	subs	r3, #1
     90a:	9310      	str	r3, [sp, #64]	; 0x40
     90c:	9b16      	ldr	r3, [sp, #88]	; 0x58
     90e:	3310      	adds	r3, #16
     910:	9316      	str	r3, [sp, #88]	; 0x58
     912:	9b10      	ldr	r3, [sp, #64]	; 0x40
     914:	2b00      	cmp	r3, #0
     916:	d1ef      	bne.n	8f8 <main+0x4da>
     918:	e5a5      	b.n	466 <main+0x48>
					put_dump((BYTE*)ptr, ofs, 16, DW_CHAR);
				break;

			case 'e' :	/* be <ofs> [<data>] ... - Edit R/W buffer */
				if (!xatoi(&ptr, &p1)) break;
     91a:	a816      	add	r0, sp, #88	; 0x58
     91c:	a915      	add	r1, sp, #84	; 0x54
     91e:	f001 fbdf 	bl	20e0 <xatoi>
     922:	2800      	cmp	r0, #0
     924:	f43f ad9f 	beq.w	466 <main+0x48>
				if (xatoi(&ptr, &p2)) {
     928:	a816      	add	r0, sp, #88	; 0x58
     92a:	a914      	add	r1, sp, #80	; 0x50
     92c:	f001 fbd8 	bl	20e0 <xatoi>
     930:	f8df 8048 	ldr.w	r8, [pc, #72]	; 97c <main+0x55e>
     934:	b160      	cbz	r0, 950 <main+0x532>
					do {
						Buff[p1++] = (BYTE)p2;
     936:	9b15      	ldr	r3, [sp, #84]	; 0x54
     938:	9a14      	ldr	r2, [sp, #80]	; 0x50
					} while (xatoi(&ptr, &p2));
     93a:	a816      	add	r0, sp, #88	; 0x58

			case 'e' :	/* be <ofs> [<data>] ... - Edit R/W buffer */
				if (!xatoi(&ptr, &p1)) break;
				if (xatoi(&ptr, &p2)) {
					do {
						Buff[p1++] = (BYTE)p2;
     93c:	f808 2003 	strb.w	r2, [r8, r3]
					} while (xatoi(&ptr, &p2));
     940:	a914      	add	r1, sp, #80	; 0x50

			case 'e' :	/* be <ofs> [<data>] ... - Edit R/W buffer */
				if (!xatoi(&ptr, &p1)) break;
				if (xatoi(&ptr, &p2)) {
					do {
						Buff[p1++] = (BYTE)p2;
     942:	3301      	adds	r3, #1
     944:	9315      	str	r3, [sp, #84]	; 0x54
					} while (xatoi(&ptr, &p2));
     946:	f001 fbcb 	bl	20e0 <xatoi>
     94a:	2800      	cmp	r0, #0
     94c:	d1f3      	bne.n	936 <main+0x518>
     94e:	e58a      	b.n	466 <main+0x48>
					break;
				}
				for (;;) {
					xprintf("%04X %02X-", (WORD)(p1), (WORD)Buff[p1]);
     950:	9b15      	ldr	r3, [sp, #84]	; 0x54
     952:	4814      	ldr	r0, [pc, #80]	; (9a4 <main+0x586>)
     954:	b299      	uxth	r1, r3
     956:	f818 2003 	ldrb.w	r2, [r8, r3]
     95a:	f001 fb0f 	bl	1f7c <xprintf>
					xgets(Line, sizeof Line);
     95e:	4812      	ldr	r0, [pc, #72]	; (9a8 <main+0x58a>)
     960:	f44f 7180 	mov.w	r1, #256	; 0x100
     964:	f001 fb88 	bl	2078 <xgets>
					ptr = Line;
					if (*ptr == '.') break;
     968:	783b      	ldrb	r3, [r7, #0]
					break;
				}
				for (;;) {
					xprintf("%04X %02X-", (WORD)(p1), (WORD)Buff[p1]);
					xgets(Line, sizeof Line);
					ptr = Line;
     96a:	9716      	str	r7, [sp, #88]	; 0x58
					if (*ptr == '.') break;
     96c:	2b2e      	cmp	r3, #46	; 0x2e
     96e:	f43f ad7a 	beq.w	466 <main+0x48>
					if (*ptr < ' ') { p1++; continue; }
     972:	2b1f      	cmp	r3, #31
     974:	d81a      	bhi.n	9ac <main+0x58e>
     976:	9b15      	ldr	r3, [sp, #84]	; 0x54
     978:	e021      	b.n	9be <main+0x5a0>
     97a:	bf00      	nop
     97c:	100007dc 	.word	0x100007dc
     980:	000058ca 	.word	0x000058ca
     984:	000058d1 	.word	0x000058d1
     988:	000058e1 	.word	0x000058e1
     98c:	000058fa 	.word	0x000058fa
     990:	00005913 	.word	0x00005913
     994:	00005923 	.word	0x00005923
     998:	00005929 	.word	0x00005929
     99c:	0000592f 	.word	0x0000592f
     9a0:	00005935 	.word	0x00005935
     9a4:	00005941 	.word	0x00005941
     9a8:	1000480c 	.word	0x1000480c
					if (xatoi(&ptr, &p2))
     9ac:	a816      	add	r0, sp, #88	; 0x58
     9ae:	a914      	add	r1, sp, #80	; 0x50
     9b0:	f001 fb96 	bl	20e0 <xatoi>
     9b4:	b130      	cbz	r0, 9c4 <main+0x5a6>
						Buff[p1++] = (BYTE)p2;
     9b6:	9b15      	ldr	r3, [sp, #84]	; 0x54
     9b8:	9914      	ldr	r1, [sp, #80]	; 0x50
     9ba:	4ab0      	ldr	r2, [pc, #704]	; (c7c <main+0x85e>)
     9bc:	54d1      	strb	r1, [r2, r3]
     9be:	3301      	adds	r3, #1
     9c0:	9315      	str	r3, [sp, #84]	; 0x54
     9c2:	e7c5      	b.n	950 <main+0x532>
					else
						xputs("???\n");
     9c4:	48ae      	ldr	r0, [pc, #696]	; (c80 <main+0x862>)
     9c6:	f001 f9e5 	bl	1d94 <xputs>
     9ca:	e7c1      	b.n	950 <main+0x532>
				}
				break;

			case 'r' :	/* br <pd#> <lba> [<num>] - Read disk into R/W buffer */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2)) break;
     9cc:	a816      	add	r0, sp, #88	; 0x58
     9ce:	a915      	add	r1, sp, #84	; 0x54
     9d0:	f001 fb86 	bl	20e0 <xatoi>
     9d4:	2800      	cmp	r0, #0
     9d6:	f43f ad46 	beq.w	466 <main+0x48>
     9da:	a816      	add	r0, sp, #88	; 0x58
     9dc:	a914      	add	r1, sp, #80	; 0x50
     9de:	f001 fb7f 	bl	20e0 <xatoi>
     9e2:	2800      	cmp	r0, #0
     9e4:	f43f ad3f 	beq.w	466 <main+0x48>
				if (!xatoi(&ptr, &p3)) p3 = 1;
     9e8:	a816      	add	r0, sp, #88	; 0x58
     9ea:	a913      	add	r1, sp, #76	; 0x4c
     9ec:	f001 fb78 	bl	20e0 <xatoi>
     9f0:	b908      	cbnz	r0, 9f6 <main+0x5d8>
     9f2:	2301      	movs	r3, #1
     9f4:	9313      	str	r3, [sp, #76]	; 0x4c
				xprintf("rc=%u\n", (WORD)disk_read((BYTE)p1, Buff, p2, p3));
     9f6:	f89d 0054 	ldrb.w	r0, [sp, #84]	; 0x54
     9fa:	49a0      	ldr	r1, [pc, #640]	; (c7c <main+0x85e>)
     9fc:	9a14      	ldr	r2, [sp, #80]	; 0x50
     9fe:	9b13      	ldr	r3, [sp, #76]	; 0x4c
     a00:	f001 fde6 	bl	25d0 <disk_read>
     a04:	4601      	mov	r1, r0
     a06:	489f      	ldr	r0, [pc, #636]	; (c84 <main+0x866>)
     a08:	f001 fab8 	bl	1f7c <xprintf>
				break;
     a0c:	e52b      	b.n	466 <main+0x48>

			case 'w' :	/* bw <pd#> <lba> [<num>] - Write R/W buffer into disk */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2)) break;
     a0e:	a816      	add	r0, sp, #88	; 0x58
     a10:	a915      	add	r1, sp, #84	; 0x54
     a12:	f001 fb65 	bl	20e0 <xatoi>
     a16:	2800      	cmp	r0, #0
     a18:	f43f ad25 	beq.w	466 <main+0x48>
     a1c:	a816      	add	r0, sp, #88	; 0x58
     a1e:	a914      	add	r1, sp, #80	; 0x50
     a20:	f001 fb5e 	bl	20e0 <xatoi>
     a24:	2800      	cmp	r0, #0
     a26:	f43f ad1e 	beq.w	466 <main+0x48>
				if (!xatoi(&ptr, &p3)) p3 = 1;
     a2a:	a816      	add	r0, sp, #88	; 0x58
     a2c:	a913      	add	r1, sp, #76	; 0x4c
     a2e:	f001 fb57 	bl	20e0 <xatoi>
     a32:	b908      	cbnz	r0, a38 <main+0x61a>
     a34:	2301      	movs	r3, #1
     a36:	9313      	str	r3, [sp, #76]	; 0x4c
				xprintf("rc=%u\n", (WORD)disk_write((BYTE)p1, Buff, p2, p3));
     a38:	f89d 0054 	ldrb.w	r0, [sp, #84]	; 0x54
     a3c:	498f      	ldr	r1, [pc, #572]	; (c7c <main+0x85e>)
     a3e:	9a14      	ldr	r2, [sp, #80]	; 0x50
     a40:	9b13      	ldr	r3, [sp, #76]	; 0x4c
     a42:	f001 fdff 	bl	2644 <disk_write>
     a46:	4601      	mov	r1, r0
     a48:	488e      	ldr	r0, [pc, #568]	; (c84 <main+0x866>)
     a4a:	f001 fa97 	bl	1f7c <xprintf>
				break;
     a4e:	e50a      	b.n	466 <main+0x48>

			case 'f' :	/* bf <val> - Fill working buffer */
				if (!xatoi(&ptr, &p1)) break;
     a50:	a816      	add	r0, sp, #88	; 0x58
     a52:	a915      	add	r1, sp, #84	; 0x54
     a54:	f001 fb44 	bl	20e0 <xatoi>
     a58:	2800      	cmp	r0, #0
     a5a:	f43f ad04 	beq.w	466 <main+0x48>
				memset(Buff, (BYTE)p1, sizeof Buff);
     a5e:	f89d 1054 	ldrb.w	r1, [sp, #84]	; 0x54
     a62:	f44f 4280 	mov.w	r2, #16384	; 0x4000
     a66:	4885      	ldr	r0, [pc, #532]	; (c7c <main+0x85e>)
     a68:	f004 fa1a 	bl	4ea0 <memset>
				break;
     a6c:	e4fb      	b.n	466 <main+0x48>

			}
			break;

		case 'f' :	/* FatFS API controls */
			switch (*ptr++) {
     a6e:	f898 3001 	ldrb.w	r3, [r8, #1]
     a72:	3702      	adds	r7, #2
     a74:	3b4c      	subs	r3, #76	; 0x4c
     a76:	9716      	str	r7, [sp, #88]	; 0x58
     a78:	2b2e      	cmp	r3, #46	; 0x2e
     a7a:	f63f acf4 	bhi.w	466 <main+0x48>
     a7e:	a201      	add	r2, pc, #4	; (adr r2, a84 <main+0x666>)
     a80:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     a84:	00000df7 	.word	0x00000df7
     a88:	00000467 	.word	0x00000467
     a8c:	00000467 	.word	0x00000467
     a90:	00000467 	.word	0x00000467
     a94:	00000467 	.word	0x00000467
     a98:	00000467 	.word	0x00000467
     a9c:	00000467 	.word	0x00000467
     aa0:	00000467 	.word	0x00000467
     aa4:	00000467 	.word	0x00000467
     aa8:	00000467 	.word	0x00000467
     aac:	00000467 	.word	0x00000467
     ab0:	00000467 	.word	0x00000467
     ab4:	00000467 	.word	0x00000467
     ab8:	00000467 	.word	0x00000467
     abc:	00000467 	.word	0x00000467
     ac0:	00000467 	.word	0x00000467
     ac4:	00000467 	.word	0x00000467
     ac8:	00000467 	.word	0x00000467
     acc:	00000467 	.word	0x00000467
     ad0:	00000467 	.word	0x00000467
     ad4:	00000467 	.word	0x00000467
     ad8:	0000109f 	.word	0x0000109f
     adc:	000012b7 	.word	0x000012b7
     ae0:	00000e79 	.word	0x00000e79
     ae4:	00000eb9 	.word	0x00000eb9
     ae8:	00000e87 	.word	0x00000e87
     aec:	00000467 	.word	0x00000467
     af0:	0000127f 	.word	0x0000127f
     af4:	00000467 	.word	0x00000467
     af8:	00000b41 	.word	0x00000b41
     afc:	00000467 	.word	0x00000467
     b00:	0000108b 	.word	0x0000108b
     b04:	00000ce1 	.word	0x00000ce1
     b08:	000012cb 	.word	0x000012cb
     b0c:	0000102f 	.word	0x0000102f
     b10:	00000e4b 	.word	0x00000e4b
     b14:	00000467 	.word	0x00000467
     b18:	00001293 	.word	0x00001293
     b1c:	00000f13 	.word	0x00000f13
     b20:	00000b63 	.word	0x00000b63
     b24:	000010dd 	.word	0x000010dd
     b28:	00001065 	.word	0x00001065
     b2c:	00001079 	.word	0x00001079
     b30:	00000fa9 	.word	0x00000fa9
     b34:	0000117f 	.word	0x0000117f
     b38:	00000467 	.word	0x00000467
     b3c:	0000131f 	.word	0x0000131f

			case 'i' :	/* fi [<opt>]- Initialize logical drive */
				if (!xatoi(&ptr, &p2)) p2 = 0;
     b40:	a816      	add	r0, sp, #88	; 0x58
     b42:	a914      	add	r1, sp, #80	; 0x50
     b44:	f001 facc 	bl	20e0 <xatoi>
     b48:	b900      	cbnz	r0, b4c <main+0x72e>
     b4a:	9014      	str	r0, [sp, #80]	; 0x50
				put_rc(f_mount(&FatFs, "", (BYTE)p2));
     b4c:	494e      	ldr	r1, [pc, #312]	; (c88 <main+0x86a>)
     b4e:	f89d 2050 	ldrb.w	r2, [sp, #80]	; 0x50
     b52:	484e      	ldr	r0, [pc, #312]	; (c8c <main+0x86e>)
     b54:	f002 fe77 	bl	3846 <f_mount>
     b58:	f7ff fbd2 	bl	300 <put_rc>
				break;
     b5c:	e483      	b.n	466 <main+0x48>

			case 's' :	/* fs [<path>] - Show volume status */
				while (*ptr == ' ') ptr++;
     b5e:	3001      	adds	r0, #1
     b60:	9016      	str	r0, [sp, #88]	; 0x58
     b62:	9816      	ldr	r0, [sp, #88]	; 0x58
     b64:	7803      	ldrb	r3, [r0, #0]
     b66:	2b20      	cmp	r3, #32
     b68:	d0f9      	beq.n	b5e <main+0x740>
				res = f_getfree(ptr, (DWORD*)&p1, &fs);
     b6a:	a915      	add	r1, sp, #84	; 0x54
     b6c:	aa0f      	add	r2, sp, #60	; 0x3c
     b6e:	f003 fb60 	bl	4232 <f_getfree>
				if (res) { put_rc(res); break; }
     b72:	b110      	cbz	r0, b7a <main+0x75c>
     b74:	f7ff fbc4 	bl	300 <put_rc>
     b78:	e475      	b.n	466 <main+0x48>
				xprintf("FAT type = %s\n", ft[fs->fs_type]);
     b7a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
     b7c:	4844      	ldr	r0, [pc, #272]	; (c90 <main+0x872>)
     b7e:	781a      	ldrb	r2, [r3, #0]
     b80:	4b44      	ldr	r3, [pc, #272]	; (c94 <main+0x876>)
     b82:	eb03 0382 	add.w	r3, r3, r2, lsl #2
     b86:	f8d3 16b4 	ldr.w	r1, [r3, #1716]	; 0x6b4
     b8a:	f001 f9f7 	bl	1f7c <xprintf>
				xprintf("Bytes/Cluster = %lu\n", (DWORD)fs->csize * 512);
     b8e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
     b90:	4841      	ldr	r0, [pc, #260]	; (c98 <main+0x87a>)
     b92:	8959      	ldrh	r1, [r3, #10]
     b94:	0249      	lsls	r1, r1, #9
     b96:	f001 f9f1 	bl	1f7c <xprintf>
				xprintf("Number of FATs = %u\n", fs->n_fats);
     b9a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
     b9c:	483f      	ldr	r0, [pc, #252]	; (c9c <main+0x87e>)
     b9e:	7899      	ldrb	r1, [r3, #2]
     ba0:	f001 f9ec 	bl	1f7c <xprintf>
				if (fs->fs_type < FS_FAT32) xprintf("Root DIR entries = %u\n", fs->n_rootdir);
     ba4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
     ba6:	781a      	ldrb	r2, [r3, #0]
     ba8:	2a02      	cmp	r2, #2
     baa:	d803      	bhi.n	bb4 <main+0x796>
     bac:	483c      	ldr	r0, [pc, #240]	; (ca0 <main+0x882>)
     bae:	8919      	ldrh	r1, [r3, #8]
     bb0:	f001 f9e4 	bl	1f7c <xprintf>
				xprintf("Sectors/FAT = %lu\n", fs->fsize);
     bb4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
     bb6:	483b      	ldr	r0, [pc, #236]	; (ca4 <main+0x886>)
     bb8:	69d9      	ldr	r1, [r3, #28]
     bba:	f001 f9df 	bl	1f7c <xprintf>
				xprintf("Number of clusters = %lu\n", (DWORD)fs->n_fatent - 2);
     bbe:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
     bc0:	4839      	ldr	r0, [pc, #228]	; (ca8 <main+0x88a>)
     bc2:	6999      	ldr	r1, [r3, #24]
     bc4:	3902      	subs	r1, #2
     bc6:	f001 f9d9 	bl	1f7c <xprintf>
				xprintf("Volume start (lba) = %lu\n", fs->volbase);
     bca:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
     bcc:	4837      	ldr	r0, [pc, #220]	; (cac <main+0x88e>)
     bce:	6a19      	ldr	r1, [r3, #32]
     bd0:	f001 f9d4 	bl	1f7c <xprintf>
				xprintf("FAT start (lba) = %lu\n", fs->fatbase);
     bd4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
     bd6:	4836      	ldr	r0, [pc, #216]	; (cb0 <main+0x892>)
     bd8:	6a59      	ldr	r1, [r3, #36]	; 0x24
     bda:	f001 f9cf 	bl	1f7c <xprintf>
				xprintf("FDIR start (lba,clustor) = %lu\n", fs->dirbase);
     bde:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
     be0:	4834      	ldr	r0, [pc, #208]	; (cb4 <main+0x896>)
     be2:	6a99      	ldr	r1, [r3, #40]	; 0x28
     be4:	f001 f9ca 	bl	1f7c <xprintf>
				xprintf("Data start (lba) = %lu\n\n", fs->database);
     be8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
     bea:	4833      	ldr	r0, [pc, #204]	; (cb8 <main+0x89a>)
     bec:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
     bee:	f001 f9c5 	bl	1f7c <xprintf>
#if FF_USE_LABEL
				res = f_getlabel(ptr, (char*)Buff, (DWORD*)&p2);
     bf2:	9816      	ldr	r0, [sp, #88]	; 0x58
     bf4:	4921      	ldr	r1, [pc, #132]	; (c7c <main+0x85e>)
     bf6:	aa14      	add	r2, sp, #80	; 0x50
     bf8:	f003 fda6 	bl	4748 <f_getlabel>
				if (res) { put_rc(res); break; }
     bfc:	4607      	mov	r7, r0
     bfe:	b110      	cbz	r0, c06 <main+0x7e8>
     c00:	f7ff fb7e 	bl	300 <put_rc>
     c04:	e42f      	b.n	466 <main+0x48>
				xprintf(Buff[0] ? "Volume name is %s\n" : "No volume label\n", (char*)Buff);
     c06:	491d      	ldr	r1, [pc, #116]	; (c7c <main+0x85e>)
     c08:	4b2c      	ldr	r3, [pc, #176]	; (cbc <main+0x89e>)
     c0a:	7808      	ldrb	r0, [r1, #0]
     c0c:	4a2c      	ldr	r2, [pc, #176]	; (cc0 <main+0x8a2>)
				xprintf("Volume S/N is %04X-%04X\n", (DWORD)p2 >> 16, (DWORD)p2 & 0xFFFF);
#endif
				AccSize = AccFiles = AccDirs = 0;
     c0e:	f8df 80c0 	ldr.w	r8, [pc, #192]	; cd0 <main+0x8b2>
				xprintf("FDIR start (lba,clustor) = %lu\n", fs->dirbase);
				xprintf("Data start (lba) = %lu\n\n", fs->database);
#if FF_USE_LABEL
				res = f_getlabel(ptr, (char*)Buff, (DWORD*)&p2);
				if (res) { put_rc(res); break; }
				xprintf(Buff[0] ? "Volume name is %s\n" : "No volume label\n", (char*)Buff);
     c12:	2800      	cmp	r0, #0
     c14:	bf0c      	ite	eq
     c16:	4610      	moveq	r0, r2
     c18:	4618      	movne	r0, r3
     c1a:	f001 f9af 	bl	1f7c <xprintf>
				xprintf("Volume S/N is %04X-%04X\n", (DWORD)p2 >> 16, (DWORD)p2 & 0xFFFF);
     c1e:	9a14      	ldr	r2, [sp, #80]	; 0x50
     c20:	4828      	ldr	r0, [pc, #160]	; (cc4 <main+0x8a6>)
     c22:	0c11      	lsrs	r1, r2, #16
#endif
				AccSize = AccFiles = AccDirs = 0;
     c24:	f8df 90ac 	ldr.w	r9, [pc, #172]	; cd4 <main+0x8b6>
				xprintf("Data start (lba) = %lu\n\n", fs->database);
#if FF_USE_LABEL
				res = f_getlabel(ptr, (char*)Buff, (DWORD*)&p2);
				if (res) { put_rc(res); break; }
				xprintf(Buff[0] ? "Volume name is %s\n" : "No volume label\n", (char*)Buff);
				xprintf("Volume S/N is %04X-%04X\n", (DWORD)p2 >> 16, (DWORD)p2 & 0xFFFF);
     c28:	b292      	uxth	r2, r2
#endif
				AccSize = AccFiles = AccDirs = 0;
     c2a:	f8df a0ac 	ldr.w	sl, [pc, #172]	; cd8 <main+0x8ba>
				xprintf("Data start (lba) = %lu\n\n", fs->database);
#if FF_USE_LABEL
				res = f_getlabel(ptr, (char*)Buff, (DWORD*)&p2);
				if (res) { put_rc(res); break; }
				xprintf(Buff[0] ? "Volume name is %s\n" : "No volume label\n", (char*)Buff);
				xprintf("Volume S/N is %04X-%04X\n", (DWORD)p2 >> 16, (DWORD)p2 & 0xFFFF);
     c2e:	f001 f9a5 	bl	1f7c <xprintf>
#endif
				AccSize = AccFiles = AccDirs = 0;
				xprintf("...");
     c32:	4825      	ldr	r0, [pc, #148]	; (cc8 <main+0x8aa>)
				res = f_getlabel(ptr, (char*)Buff, (DWORD*)&p2);
				if (res) { put_rc(res); break; }
				xprintf(Buff[0] ? "Volume name is %s\n" : "No volume label\n", (char*)Buff);
				xprintf("Volume S/N is %04X-%04X\n", (DWORD)p2 >> 16, (DWORD)p2 & 0xFFFF);
#endif
				AccSize = AccFiles = AccDirs = 0;
     c34:	f8c8 7000 	str.w	r7, [r8]
     c38:	f8a9 7000 	strh.w	r7, [r9]
     c3c:	f8aa 7000 	strh.w	r7, [sl]
				xprintf("...");
     c40:	f001 f99c 	bl	1f7c <xprintf>
				res = scan_files(ptr);
     c44:	9816      	ldr	r0, [sp, #88]	; 0x58
     c46:	f7ff fb71 	bl	32c <scan_files>
				if (res) { put_rc(res); break; }
     c4a:	b110      	cbz	r0, c52 <main+0x834>
     c4c:	f7ff fb58 	bl	300 <put_rc>
     c50:	e409      	b.n	466 <main+0x48>
				xprintf("\r%u files, %lu bytes.\n%u folders.\n"
						"%lu KiB total disk space.\n%lu KiB available.\n",
						AccFiles, AccSize, AccDirs,
						(fs->n_fatent - 2) * (fs->csize / 2), (DWORD)p1 * (fs->csize / 2)
     c52:	980f      	ldr	r0, [sp, #60]	; 0x3c
#endif
				AccSize = AccFiles = AccDirs = 0;
				xprintf("...");
				res = scan_files(ptr);
				if (res) { put_rc(res); break; }
				xprintf("\r%u files, %lu bytes.\n%u folders.\n"
     c54:	f8ba 1000 	ldrh.w	r1, [sl]
     c58:	8942      	ldrh	r2, [r0, #10]
						"%lu KiB total disk space.\n%lu KiB available.\n",
						AccFiles, AccSize, AccDirs,
						(fs->n_fatent - 2) * (fs->csize / 2), (DWORD)p1 * (fs->csize / 2)
     c5a:	6980      	ldr	r0, [r0, #24]
#endif
				AccSize = AccFiles = AccDirs = 0;
				xprintf("...");
				res = scan_files(ptr);
				if (res) { put_rc(res); break; }
				xprintf("\r%u files, %lu bytes.\n%u folders.\n"
     c5c:	0852      	lsrs	r2, r2, #1
						"%lu KiB total disk space.\n%lu KiB available.\n",
						AccFiles, AccSize, AccDirs,
						(fs->n_fatent - 2) * (fs->csize / 2), (DWORD)p1 * (fs->csize / 2)
     c5e:	3802      	subs	r0, #2
#endif
				AccSize = AccFiles = AccDirs = 0;
				xprintf("...");
				res = scan_files(ptr);
				if (res) { put_rc(res); break; }
				xprintf("\r%u files, %lu bytes.\n%u folders.\n"
     c60:	4350      	muls	r0, r2
     c62:	9000      	str	r0, [sp, #0]
     c64:	9815      	ldr	r0, [sp, #84]	; 0x54
     c66:	f8b9 3000 	ldrh.w	r3, [r9]
     c6a:	4342      	muls	r2, r0
     c6c:	9201      	str	r2, [sp, #4]
     c6e:	4817      	ldr	r0, [pc, #92]	; (ccc <main+0x8ae>)
     c70:	f8d8 2000 	ldr.w	r2, [r8]
     c74:	f001 f982 	bl	1f7c <xprintf>
						"%lu KiB total disk space.\n%lu KiB available.\n",
						AccFiles, AccSize, AccDirs,
						(fs->n_fatent - 2) * (fs->csize / 2), (DWORD)p1 * (fs->csize / 2)
				);
				break;
     c78:	f7ff bbf5 	b.w	466 <main+0x48>
     c7c:	100007dc 	.word	0x100007dc
     c80:	0000594c 	.word	0x0000594c
     c84:	00005951 	.word	0x00005951
     c88:	00005a3e 	.word	0x00005a3e
     c8c:	10000138 	.word	0x10000138
     c90:	00005958 	.word	0x00005958
     c94:	0000517c 	.word	0x0000517c
     c98:	00005967 	.word	0x00005967
     c9c:	0000597c 	.word	0x0000597c
     ca0:	00005991 	.word	0x00005991
     ca4:	000059a8 	.word	0x000059a8
     ca8:	000059bb 	.word	0x000059bb
     cac:	000059d5 	.word	0x000059d5
     cb0:	000059ef 	.word	0x000059ef
     cb4:	00005a06 	.word	0x00005a06
     cb8:	00005a26 	.word	0x00005a26
     cbc:	00005851 	.word	0x00005851
     cc0:	00005864 	.word	0x00005864
     cc4:	00005a3f 	.word	0x00005a3f
     cc8:	00005b8a 	.word	0x00005b8a
     ccc:	00005a58 	.word	0x00005a58
     cd0:	100007d8 	.word	0x100007d8
     cd4:	1000490c 	.word	0x1000490c
     cd8:	1000490e 	.word	0x1000490e

			case 'l' :	/* fl [<path>] - Directory listing */
				while (*ptr == ' ') ptr++;
     cdc:	3101      	adds	r1, #1
     cde:	9116      	str	r1, [sp, #88]	; 0x58
     ce0:	9916      	ldr	r1, [sp, #88]	; 0x58
     ce2:	780b      	ldrb	r3, [r1, #0]
     ce4:	2b20      	cmp	r3, #32
     ce6:	d0f9      	beq.n	cdc <main+0x8be>
				res = f_opendir(&Dir, ptr);
     ce8:	4899      	ldr	r0, [pc, #612]	; (f50 <main+0xb32>)
     cea:	f003 f9ff 	bl	40ec <f_opendir>
				if (res) { put_rc(res); break; }
     cee:	b118      	cbz	r0, cf8 <main+0x8da>
     cf0:	f7ff fb06 	bl	300 <put_rc>
     cf4:	f7ff bbb7 	b.w	466 <main+0x48>
				p1 = s1 = s2 = 0;
     cf8:	9011      	str	r0, [sp, #68]	; 0x44
     cfa:	9012      	str	r0, [sp, #72]	; 0x48
     cfc:	9015      	str	r0, [sp, #84]	; 0x54
				for(;;) {
					res = f_readdir(&Dir, &Finfo);
     cfe:	4894      	ldr	r0, [pc, #592]	; (f50 <main+0xb32>)
     d00:	4994      	ldr	r1, [pc, #592]	; (f54 <main+0xb36>)
     d02:	f003 fa2d 	bl	4160 <f_readdir>
					if ((res != FR_OK) || !Finfo.fname[0]) break;
     d06:	2800      	cmp	r0, #0
     d08:	d159      	bne.n	dbe <main+0x9a0>
     d0a:	4892      	ldr	r0, [pc, #584]	; (f54 <main+0xb36>)
     d0c:	7a43      	ldrb	r3, [r0, #9]
     d0e:	2b00      	cmp	r3, #0
     d10:	d055      	beq.n	dbe <main+0x9a0>
					if (Finfo.fattrib & AM_DIR) {
     d12:	7a03      	ldrb	r3, [r0, #8]
     d14:	f013 0f10 	tst.w	r3, #16
     d18:	d003      	beq.n	d22 <main+0x904>
						s2++;
     d1a:	9b11      	ldr	r3, [sp, #68]	; 0x44
     d1c:	3301      	adds	r3, #1
     d1e:	9311      	str	r3, [sp, #68]	; 0x44
     d20:	e006      	b.n	d30 <main+0x912>
					} else {
						s1++; p1 += Finfo.fsize;
     d22:	9b12      	ldr	r3, [sp, #72]	; 0x48
     d24:	9a15      	ldr	r2, [sp, #84]	; 0x54
     d26:	3301      	adds	r3, #1
     d28:	9312      	str	r3, [sp, #72]	; 0x48
     d2a:	6803      	ldr	r3, [r0, #0]
     d2c:	18d3      	adds	r3, r2, r3
     d2e:	9315      	str	r3, [sp, #84]	; 0x54
					}
					xprintf("%c%c%c%c%c %u/%02u/%02u %02u:%02u %9lu  %s\n",
							(Finfo.fattrib & AM_DIR) ? 'D' : '-',
     d30:	7a07      	ldrb	r7, [r0, #8]
							(Finfo.fattrib & AM_RDO) ? 'R' : '-',
							(Finfo.fattrib & AM_HID) ? 'H' : '-',
							(Finfo.fattrib & AM_SYS) ? 'S' : '-',
							(Finfo.fattrib & AM_ARC) ? 'A' : '-',
							(Finfo.fdate >> 9) + 1980, (Finfo.fdate >> 5) & 15, Finfo.fdate & 31,
     d32:	f8b0 e004 	ldrh.w	lr, [r0, #4]
						s2++;
					} else {
						s1++; p1 += Finfo.fsize;
					}
					xprintf("%c%c%c%c%c %u/%02u/%02u %02u:%02u %9lu  %s\n",
							(Finfo.fattrib & AM_DIR) ? 'D' : '-',
     d36:	f007 0110 	and.w	r1, r7, #16
							(Finfo.fattrib & AM_RDO) ? 'R' : '-',
     d3a:	f007 0201 	and.w	r2, r7, #1
							(Finfo.fattrib & AM_HID) ? 'H' : '-',
     d3e:	f007 0302 	and.w	r3, r7, #2
							(Finfo.fattrib & AM_SYS) ? 'S' : '-',
     d42:	f007 0804 	and.w	r8, r7, #4
							(Finfo.fattrib & AM_ARC) ? 'A' : '-',
     d46:	f007 0720 	and.w	r7, r7, #32
					if (Finfo.fattrib & AM_DIR) {
						s2++;
					} else {
						s1++; p1 += Finfo.fsize;
					}
					xprintf("%c%c%c%c%c %u/%02u/%02u %02u:%02u %9lu  %s\n",
     d4a:	2f00      	cmp	r7, #0
     d4c:	bf0c      	ite	eq
     d4e:	272d      	moveq	r7, #45	; 0x2d
     d50:	2741      	movne	r7, #65	; 0x41
							(Finfo.fattrib & AM_RDO) ? 'R' : '-',
							(Finfo.fattrib & AM_HID) ? 'H' : '-',
							(Finfo.fattrib & AM_SYS) ? 'S' : '-',
							(Finfo.fattrib & AM_ARC) ? 'A' : '-',
							(Finfo.fdate >> 9) + 1980, (Finfo.fdate >> 5) & 15, Finfo.fdate & 31,
							(Finfo.ftime >> 11), (Finfo.ftime >> 5) & 63,
     d52:	f8b0 c006 	ldrh.w	ip, [r0, #6]
					if (Finfo.fattrib & AM_DIR) {
						s2++;
					} else {
						s1++; p1 += Finfo.fsize;
					}
					xprintf("%c%c%c%c%c %u/%02u/%02u %02u:%02u %9lu  %s\n",
     d56:	9701      	str	r7, [sp, #4]
							(Finfo.fattrib & AM_DIR) ? 'D' : '-',
							(Finfo.fattrib & AM_RDO) ? 'R' : '-',
							(Finfo.fattrib & AM_HID) ? 'H' : '-',
							(Finfo.fattrib & AM_SYS) ? 'S' : '-',
							(Finfo.fattrib & AM_ARC) ? 'A' : '-',
							(Finfo.fdate >> 9) + 1980, (Finfo.fdate >> 5) & 15, Finfo.fdate & 31,
     d58:	ea4f 275e 	mov.w	r7, lr, lsr #9
					if (Finfo.fattrib & AM_DIR) {
						s2++;
					} else {
						s1++; p1 += Finfo.fsize;
					}
					xprintf("%c%c%c%c%c %u/%02u/%02u %02u:%02u %9lu  %s\n",
     d5c:	f507 67f6 	add.w	r7, r7, #1968	; 0x7b0
     d60:	370c      	adds	r7, #12
     d62:	9702      	str	r7, [sp, #8]
     d64:	ea4f 175e 	mov.w	r7, lr, lsr #5
     d68:	f007 070f 	and.w	r7, r7, #15
     d6c:	9703      	str	r7, [sp, #12]
     d6e:	f00e 071f 	and.w	r7, lr, #31
     d72:	9704      	str	r7, [sp, #16]
     d74:	ea4f 27dc 	mov.w	r7, ip, lsr #11
     d78:	ea4f 1c5c 	mov.w	ip, ip, lsr #5
     d7c:	9705      	str	r7, [sp, #20]
     d7e:	f1b8 0f00 	cmp.w	r8, #0
     d82:	bf0c      	ite	eq
     d84:	f04f 082d 	moveq.w	r8, #45	; 0x2d
     d88:	f04f 0853 	movne.w	r8, #83	; 0x53
     d8c:	f00c 073f 	and.w	r7, ip, #63	; 0x3f
     d90:	f8cd 8000 	str.w	r8, [sp]
     d94:	9706      	str	r7, [sp, #24]
     d96:	6800      	ldr	r0, [r0, #0]
     d98:	2900      	cmp	r1, #0
     d9a:	bf0c      	ite	eq
     d9c:	212d      	moveq	r1, #45	; 0x2d
     d9e:	2144      	movne	r1, #68	; 0x44
     da0:	9007      	str	r0, [sp, #28]
     da2:	486d      	ldr	r0, [pc, #436]	; (f58 <main+0xb3a>)
     da4:	2a00      	cmp	r2, #0
     da6:	bf0c      	ite	eq
     da8:	222d      	moveq	r2, #45	; 0x2d
     daa:	2252      	movne	r2, #82	; 0x52
     dac:	9008      	str	r0, [sp, #32]
     dae:	2b00      	cmp	r3, #0
     db0:	bf0c      	ite	eq
     db2:	232d      	moveq	r3, #45	; 0x2d
     db4:	2348      	movne	r3, #72	; 0x48
     db6:	4869      	ldr	r0, [pc, #420]	; (f5c <main+0xb3e>)
     db8:	f001 f8e0 	bl	1f7c <xprintf>
							(Finfo.fattrib & AM_SYS) ? 'S' : '-',
							(Finfo.fattrib & AM_ARC) ? 'A' : '-',
							(Finfo.fdate >> 9) + 1980, (Finfo.fdate >> 5) & 15, Finfo.fdate & 31,
							(Finfo.ftime >> 11), (Finfo.ftime >> 5) & 63,
							(DWORD)Finfo.fsize, Finfo.fname);
				}
     dbc:	e79f      	b.n	cfe <main+0x8e0>
				xprintf("%4u File(s),%10lu bytes total\n%4u Dir(s)", s1, p1, s2);
     dbe:	4868      	ldr	r0, [pc, #416]	; (f60 <main+0xb42>)
     dc0:	9912      	ldr	r1, [sp, #72]	; 0x48
     dc2:	9a15      	ldr	r2, [sp, #84]	; 0x54
     dc4:	9b11      	ldr	r3, [sp, #68]	; 0x44
     dc6:	f001 f8d9 	bl	1f7c <xprintf>
				res = f_getfree(ptr, (DWORD*)&p1, &fs);
     dca:	9816      	ldr	r0, [sp, #88]	; 0x58
     dcc:	a915      	add	r1, sp, #84	; 0x54
     dce:	aa0f      	add	r2, sp, #60	; 0x3c
     dd0:	f003 fa2f 	bl	4232 <f_getfree>
				if (res == FR_OK)
     dd4:	b948      	cbnz	r0, dea <main+0x9cc>
					xprintf(", %10lu bytes free\n", p1 * fs->csize * 512);
     dd6:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
     dd8:	9b15      	ldr	r3, [sp, #84]	; 0x54
     dda:	8951      	ldrh	r1, [r2, #10]
     ddc:	025b      	lsls	r3, r3, #9
     dde:	4861      	ldr	r0, [pc, #388]	; (f64 <main+0xb46>)
     de0:	4359      	muls	r1, r3
     de2:	f001 f8cb 	bl	1f7c <xprintf>
     de6:	f7ff bb3e 	b.w	466 <main+0x48>
				else
					put_rc(res);
     dea:	f7ff fa89 	bl	300 <put_rc>
     dee:	f7ff bb3a 	b.w	466 <main+0x48>
				break;
#if FF_USE_FIND
			case 'L' :	/* fL <path> <pattern> - Directory search */
				while (*ptr == ' ') ptr++;
     df2:	3201      	adds	r2, #1
     df4:	9216      	str	r2, [sp, #88]	; 0x58
     df6:	9a16      	ldr	r2, [sp, #88]	; 0x58
     df8:	7813      	ldrb	r3, [r2, #0]
     dfa:	2b20      	cmp	r3, #32
     dfc:	d0f9      	beq.n	df2 <main+0x9d4>
     dfe:	e000      	b.n	e02 <main+0x9e4>
				ptr2 = ptr;
				while (*ptr != ' ') ptr++;
     e00:	9316      	str	r3, [sp, #88]	; 0x58
     e02:	9916      	ldr	r1, [sp, #88]	; 0x58
     e04:	460b      	mov	r3, r1
     e06:	f813 0b01 	ldrb.w	r0, [r3], #1
     e0a:	2820      	cmp	r0, #32
     e0c:	d1f8      	bne.n	e00 <main+0x9e2>
				*ptr++ = 0;
     e0e:	3820      	subs	r0, #32
     e10:	7008      	strb	r0, [r1, #0]
				res = f_findfirst(&Dir, &Finfo, ptr2, ptr);
     e12:	4950      	ldr	r1, [pc, #320]	; (f54 <main+0xb36>)
     e14:	484e      	ldr	r0, [pc, #312]	; (f50 <main+0xb32>)
#if FF_USE_FIND
			case 'L' :	/* fL <path> <pattern> - Directory search */
				while (*ptr == ' ') ptr++;
				ptr2 = ptr;
				while (*ptr != ' ') ptr++;
				*ptr++ = 0;
     e16:	9316      	str	r3, [sp, #88]	; 0x58
				res = f_findfirst(&Dir, &Finfo, ptr2, ptr);
     e18:	f003 f9dc 	bl	41d4 <f_findfirst>
				while (res == FR_OK && Finfo.fname[0]) {
     e1c:	e008      	b.n	e30 <main+0xa12>
					xprintf("%s\n", Finfo.fname);
     e1e:	4852      	ldr	r0, [pc, #328]	; (f68 <main+0xb4a>)
     e20:	f107 0109 	add.w	r1, r7, #9
     e24:	f001 f8aa 	bl	1f7c <xprintf>
					res = f_findnext(&Dir, &Finfo);
     e28:	4849      	ldr	r0, [pc, #292]	; (f50 <main+0xb32>)
     e2a:	4639      	mov	r1, r7
     e2c:	f003 f9bb 	bl	41a6 <f_findnext>
				while (*ptr == ' ') ptr++;
				ptr2 = ptr;
				while (*ptr != ' ') ptr++;
				*ptr++ = 0;
				res = f_findfirst(&Dir, &Finfo, ptr2, ptr);
				while (res == FR_OK && Finfo.fname[0]) {
     e30:	b920      	cbnz	r0, e3c <main+0xa1e>
     e32:	4f48      	ldr	r7, [pc, #288]	; (f54 <main+0xb36>)
     e34:	7a7b      	ldrb	r3, [r7, #9]
     e36:	2b00      	cmp	r3, #0
     e38:	d1f1      	bne.n	e1e <main+0xa00>
     e3a:	e001      	b.n	e40 <main+0xa22>
					xprintf("%s\n", Finfo.fname);
					res = f_findnext(&Dir, &Finfo);
				}
				if (res) put_rc(res);
     e3c:	f7ff fa60 	bl	300 <put_rc>
				f_closedir(&Dir);
     e40:	4843      	ldr	r0, [pc, #268]	; (f50 <main+0xb32>)
     e42:	f003 f985 	bl	4150 <f_closedir>
				break;
     e46:	f7ff bb0e 	b.w	466 <main+0x48>
#endif
			case 'o' :	/* fo <mode> <file> - Open a file */
				if (!xatoi(&ptr, &p1)) break;
     e4a:	a816      	add	r0, sp, #88	; 0x58
     e4c:	a915      	add	r1, sp, #84	; 0x54
     e4e:	f001 f947 	bl	20e0 <xatoi>
     e52:	2800      	cmp	r0, #0
     e54:	f43f ab07 	beq.w	466 <main+0x48>
     e58:	e001      	b.n	e5e <main+0xa40>
				while (*ptr == ' ') ptr++;
     e5a:	3101      	adds	r1, #1
     e5c:	9116      	str	r1, [sp, #88]	; 0x58
     e5e:	9916      	ldr	r1, [sp, #88]	; 0x58
     e60:	780b      	ldrb	r3, [r1, #0]
     e62:	2b20      	cmp	r3, #32
     e64:	d0f9      	beq.n	e5a <main+0xa3c>
				put_rc(f_open(&File[0], ptr, (BYTE)p1));
     e66:	f89d 2054 	ldrb.w	r2, [sp, #84]	; 0x54
     e6a:	4840      	ldr	r0, [pc, #256]	; (f6c <main+0xb4e>)
     e6c:	f002 fd12 	bl	3894 <f_open>
     e70:	f7ff fa46 	bl	300 <put_rc>
				break;
     e74:	f7ff baf7 	b.w	466 <main+0x48>

			case 'c' :	/* fc - Close a file */
				put_rc(f_close(&File[0]));
     e78:	483c      	ldr	r0, [pc, #240]	; (f6c <main+0xb4e>)
     e7a:	f002 ffba 	bl	3df2 <f_close>
     e7e:	f7ff fa3f 	bl	300 <put_rc>
				break;
     e82:	f7ff baf0 	b.w	466 <main+0x48>

			case 'e' :	/* fe - Seek file pointer */
				if (!xatoi(&ptr, &p1)) break;
     e86:	a816      	add	r0, sp, #88	; 0x58
     e88:	a915      	add	r1, sp, #84	; 0x54
     e8a:	f001 f929 	bl	20e0 <xatoi>
     e8e:	2800      	cmp	r0, #0
     e90:	f43f aae9 	beq.w	466 <main+0x48>
				res = f_lseek(&File[0], p1);
     e94:	4835      	ldr	r0, [pc, #212]	; (f6c <main+0xb4e>)
     e96:	9915      	ldr	r1, [sp, #84]	; 0x54
     e98:	f003 f881 	bl	3f9e <f_lseek>
     e9c:	4607      	mov	r7, r0
				put_rc(res);
     e9e:	f7ff fa2f 	bl	300 <put_rc>
				if (res == FR_OK)
     ea2:	2f00      	cmp	r7, #0
     ea4:	f47f aadf 	bne.w	466 <main+0x48>
					xprintf("fptr=%lu(0x%lX)\n", File[0].fptr, File[0].fptr);
     ea8:	4b30      	ldr	r3, [pc, #192]	; (f6c <main+0xb4e>)
     eaa:	4831      	ldr	r0, [pc, #196]	; (f70 <main+0xb52>)
     eac:	6959      	ldr	r1, [r3, #20]
     eae:	460a      	mov	r2, r1
     eb0:	f001 f864 	bl	1f7c <xprintf>
     eb4:	f7ff bad7 	b.w	466 <main+0x48>
				break;

			case 'd' :	/* fd <len> - read and dump file from current fp */
				if (!xatoi(&ptr, &p1)) break;
     eb8:	a816      	add	r0, sp, #88	; 0x58
     eba:	a915      	add	r1, sp, #84	; 0x54
     ebc:	f001 f910 	bl	20e0 <xatoi>
     ec0:	2800      	cmp	r0, #0
     ec2:	f43f aad0 	beq.w	466 <main+0x48>
				ofs = File[0].fptr;
     ec6:	4b29      	ldr	r3, [pc, #164]	; (f6c <main+0xb4e>)
     ec8:	695f      	ldr	r7, [r3, #20]
				while (p1) {
     eca:	e01d      	b.n	f08 <main+0xaea>
					if ((UINT)p1 >= 16) { cnt = 16; p1 -= 16; }
     ecc:	2b0f      	cmp	r3, #15
     ece:	d903      	bls.n	ed8 <main+0xaba>
     ed0:	2210      	movs	r2, #16
     ed2:	9210      	str	r2, [sp, #64]	; 0x40
     ed4:	3b10      	subs	r3, #16
     ed6:	e001      	b.n	edc <main+0xabe>
					else 				{ cnt = p1; p1 = 0; }
     ed8:	9310      	str	r3, [sp, #64]	; 0x40
     eda:	2300      	movs	r3, #0
     edc:	9315      	str	r3, [sp, #84]	; 0x54
					res = f_read(&File[0], Buff, cnt, &cnt);
     ede:	4823      	ldr	r0, [pc, #140]	; (f6c <main+0xb4e>)
     ee0:	4924      	ldr	r1, [pc, #144]	; (f74 <main+0xb56>)
     ee2:	9a10      	ldr	r2, [sp, #64]	; 0x40
     ee4:	ab10      	add	r3, sp, #64	; 0x40
     ee6:	f002 fdbb 	bl	3a60 <f_read>
					if (res != FR_OK) { put_rc(res); break; }
     eea:	b118      	cbz	r0, ef4 <main+0xad6>
     eec:	f7ff fa08 	bl	300 <put_rc>
     ef0:	f7ff bab9 	b.w	466 <main+0x48>
					if (!cnt) break;
     ef4:	9a10      	ldr	r2, [sp, #64]	; 0x40
     ef6:	2a00      	cmp	r2, #0
     ef8:	f43f aab5 	beq.w	466 <main+0x48>
					put_dump(Buff, ofs, cnt, DW_CHAR);
     efc:	4639      	mov	r1, r7
     efe:	481d      	ldr	r0, [pc, #116]	; (f74 <main+0xb56>)
     f00:	2301      	movs	r3, #1
     f02:	f001 f871 	bl	1fe8 <put_dump>
					ofs += 16;
     f06:	3710      	adds	r7, #16
				break;

			case 'd' :	/* fd <len> - read and dump file from current fp */
				if (!xatoi(&ptr, &p1)) break;
				ofs = File[0].fptr;
				while (p1) {
     f08:	9b15      	ldr	r3, [sp, #84]	; 0x54
     f0a:	2b00      	cmp	r3, #0
     f0c:	d1de      	bne.n	ecc <main+0xaae>
     f0e:	f7ff baaa 	b.w	466 <main+0x48>
					ofs += 16;
				}
				break;

			case 'r' :	/* fr <len> - read file */
				if (!xatoi(&ptr, &p1)) break;
     f12:	a816      	add	r0, sp, #88	; 0x58
     f14:	a915      	add	r1, sp, #84	; 0x54
     f16:	f001 f8e3 	bl	20e0 <xatoi>
     f1a:	2800      	cmp	r0, #0
     f1c:	f43f aaa3 	beq.w	466 <main+0x48>
				p2 = 0;
				Timer = 0;
     f20:	4f15      	ldr	r7, [pc, #84]	; (f78 <main+0xb5a>)
				}
				break;

			case 'r' :	/* fr <len> - read file */
				if (!xatoi(&ptr, &p1)) break;
				p2 = 0;
     f22:	2300      	movs	r3, #0
     f24:	9314      	str	r3, [sp, #80]	; 0x50
				Timer = 0;
     f26:	603b      	str	r3, [r7, #0]
				while (p1) {
     f28:	e02f      	b.n	f8a <main+0xb6c>
					if ((UINT)p1 >= blen) {
     f2a:	42a3      	cmp	r3, r4
						cnt = blen; p1 -= blen;
     f2c:	bf2b      	itete	cs
     f2e:	ebc4 0303 	rsbcs	r3, r4, r3
					} else {
						cnt = p1; p1 = 0;
     f32:	9310      	strcc	r3, [sp, #64]	; 0x40
				if (!xatoi(&ptr, &p1)) break;
				p2 = 0;
				Timer = 0;
				while (p1) {
					if ((UINT)p1 >= blen) {
						cnt = blen; p1 -= blen;
     f34:	9410      	strcs	r4, [sp, #64]	; 0x40
					} else {
						cnt = p1; p1 = 0;
     f36:	2300      	movcc	r3, #0
     f38:	9315      	str	r3, [sp, #84]	; 0x54
					}
					res = f_read(&File[0], Buff, cnt, &s2);
     f3a:	480c      	ldr	r0, [pc, #48]	; (f6c <main+0xb4e>)
     f3c:	490d      	ldr	r1, [pc, #52]	; (f74 <main+0xb56>)
     f3e:	9a10      	ldr	r2, [sp, #64]	; 0x40
     f40:	ab11      	add	r3, sp, #68	; 0x44
     f42:	f002 fd8d 	bl	3a60 <f_read>
					if (res != FR_OK) { put_rc(res); break; }
     f46:	b1c8      	cbz	r0, f7c <main+0xb5e>
     f48:	f7ff f9da 	bl	300 <put_rc>
     f4c:	e020      	b.n	f90 <main+0xb72>
     f4e:	bf00      	nop
     f50:	100047dc 	.word	0x100047dc
     f54:	1000036c 	.word	0x1000036c
     f58:	10000375 	.word	0x10000375
     f5c:	00005aa8 	.word	0x00005aa8
     f60:	00005ad4 	.word	0x00005ad4
     f64:	00005afd 	.word	0x00005afd
     f68:	00005ad0 	.word	0x00005ad0
     f6c:	10000384 	.word	0x10000384
     f70:	00005b11 	.word	0x00005b11
     f74:	100007dc 	.word	0x100007dc
     f78:	100007d4 	.word	0x100007d4
					p2 += s2;
     f7c:	9b11      	ldr	r3, [sp, #68]	; 0x44
     f7e:	9a14      	ldr	r2, [sp, #80]	; 0x50
     f80:	18d2      	adds	r2, r2, r3
     f82:	9214      	str	r2, [sp, #80]	; 0x50
					if (cnt != s2) break;
     f84:	9a10      	ldr	r2, [sp, #64]	; 0x40
     f86:	429a      	cmp	r2, r3
     f88:	d102      	bne.n	f90 <main+0xb72>

			case 'r' :	/* fr <len> - read file */
				if (!xatoi(&ptr, &p1)) break;
				p2 = 0;
				Timer = 0;
				while (p1) {
     f8a:	9b15      	ldr	r3, [sp, #84]	; 0x54
     f8c:	2b00      	cmp	r3, #0
     f8e:	d1cc      	bne.n	f2a <main+0xb0c>
					res = f_read(&File[0], Buff, cnt, &s2);
					if (res != FR_OK) { put_rc(res); break; }
					p2 += s2;
					if (cnt != s2) break;
				}
				xprintf("%lu bytes read at %lu kB/sec.\n", p2, Timer ? (p2 / Timer) : 0);
     f90:	683a      	ldr	r2, [r7, #0]
     f92:	9914      	ldr	r1, [sp, #80]	; 0x50
     f94:	b11a      	cbz	r2, f9e <main+0xb80>
     f96:	4b99      	ldr	r3, [pc, #612]	; (11fc <main+0xdde>)
     f98:	681a      	ldr	r2, [r3, #0]
     f9a:	fbb1 f2f2 	udiv	r2, r1, r2
     f9e:	4898      	ldr	r0, [pc, #608]	; (1200 <main+0xde2>)
     fa0:	f000 ffec 	bl	1f7c <xprintf>
				break;
     fa4:	f7ff ba5f 	b.w	466 <main+0x48>

			case 'w' :	/* fw <len> <val> - write file */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2)) break;
     fa8:	a816      	add	r0, sp, #88	; 0x58
     faa:	a915      	add	r1, sp, #84	; 0x54
     fac:	f001 f898 	bl	20e0 <xatoi>
     fb0:	2800      	cmp	r0, #0
     fb2:	f43f aa58 	beq.w	466 <main+0x48>
     fb6:	a816      	add	r0, sp, #88	; 0x58
     fb8:	a914      	add	r1, sp, #80	; 0x50
     fba:	f001 f891 	bl	20e0 <xatoi>
     fbe:	2800      	cmp	r0, #0
     fc0:	f43f aa51 	beq.w	466 <main+0x48>
				memset(Buff, (BYTE)p2, blen);
     fc4:	488f      	ldr	r0, [pc, #572]	; (1204 <main+0xde6>)
     fc6:	f89d 1050 	ldrb.w	r1, [sp, #80]	; 0x50
     fca:	4622      	mov	r2, r4
				p2 = 0;
				Timer = 0;
     fcc:	4f8b      	ldr	r7, [pc, #556]	; (11fc <main+0xdde>)
				xprintf("%lu bytes read at %lu kB/sec.\n", p2, Timer ? (p2 / Timer) : 0);
				break;

			case 'w' :	/* fw <len> <val> - write file */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2)) break;
				memset(Buff, (BYTE)p2, blen);
     fce:	f003 ff67 	bl	4ea0 <memset>
				p2 = 0;
     fd2:	2300      	movs	r3, #0
     fd4:	9314      	str	r3, [sp, #80]	; 0x50
				Timer = 0;
     fd6:	603b      	str	r3, [r7, #0]
				while (p1) {
     fd8:	e018      	b.n	100c <main+0xbee>
					if ((UINT)p1 >= blen) {
     fda:	42a3      	cmp	r3, r4
						cnt = blen; p1 -= blen;
     fdc:	bf2b      	itete	cs
     fde:	ebc4 0303 	rsbcs	r3, r4, r3
					} else {
						cnt = p1; p1 = 0;
     fe2:	9310      	strcc	r3, [sp, #64]	; 0x40
				memset(Buff, (BYTE)p2, blen);
				p2 = 0;
				Timer = 0;
				while (p1) {
					if ((UINT)p1 >= blen) {
						cnt = blen; p1 -= blen;
     fe4:	9410      	strcs	r4, [sp, #64]	; 0x40
					} else {
						cnt = p1; p1 = 0;
     fe6:	2300      	movcc	r3, #0
     fe8:	9315      	str	r3, [sp, #84]	; 0x54
					}
					res = f_write(&File[0], Buff, cnt, &s2);
     fea:	4887      	ldr	r0, [pc, #540]	; (1208 <main+0xdea>)
     fec:	4985      	ldr	r1, [pc, #532]	; (1204 <main+0xde6>)
     fee:	9a10      	ldr	r2, [sp, #64]	; 0x40
     ff0:	ab11      	add	r3, sp, #68	; 0x44
     ff2:	f002 fde7 	bl	3bc4 <f_write>
					if (res != FR_OK) { put_rc(res); break; }
     ff6:	b110      	cbz	r0, ffe <main+0xbe0>
     ff8:	f7ff f982 	bl	300 <put_rc>
     ffc:	e009      	b.n	1012 <main+0xbf4>
					p2 += s2;
     ffe:	9b11      	ldr	r3, [sp, #68]	; 0x44
    1000:	9a14      	ldr	r2, [sp, #80]	; 0x50
    1002:	18d2      	adds	r2, r2, r3
    1004:	9214      	str	r2, [sp, #80]	; 0x50
					if (cnt != s2) break;
    1006:	9a10      	ldr	r2, [sp, #64]	; 0x40
    1008:	429a      	cmp	r2, r3
    100a:	d102      	bne.n	1012 <main+0xbf4>
			case 'w' :	/* fw <len> <val> - write file */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2)) break;
				memset(Buff, (BYTE)p2, blen);
				p2 = 0;
				Timer = 0;
				while (p1) {
    100c:	9b15      	ldr	r3, [sp, #84]	; 0x54
    100e:	2b00      	cmp	r3, #0
    1010:	d1e3      	bne.n	fda <main+0xbbc>
					res = f_write(&File[0], Buff, cnt, &s2);
					if (res != FR_OK) { put_rc(res); break; }
					p2 += s2;
					if (cnt != s2) break;
				}
				xprintf("%lu bytes written at %lu kB/sec.\n", p2, Timer ? (p2 / Timer) : 0);
    1012:	683a      	ldr	r2, [r7, #0]
    1014:	9914      	ldr	r1, [sp, #80]	; 0x50
    1016:	b11a      	cbz	r2, 1020 <main+0xc02>
    1018:	4b78      	ldr	r3, [pc, #480]	; (11fc <main+0xdde>)
    101a:	681a      	ldr	r2, [r3, #0]
    101c:	fbb1 f2f2 	udiv	r2, r1, r2
    1020:	487a      	ldr	r0, [pc, #488]	; (120c <main+0xdee>)
    1022:	f000 ffab 	bl	1f7c <xprintf>
				break;
    1026:	f7ff ba1e 	b.w	466 <main+0x48>

			case 'n' :	/* fn <org.name> <new.name> - Change name of an object */
				while (*ptr == ' ') ptr++;
    102a:	3001      	adds	r0, #1
    102c:	9016      	str	r0, [sp, #88]	; 0x58
    102e:	9816      	ldr	r0, [sp, #88]	; 0x58
    1030:	7803      	ldrb	r3, [r0, #0]
    1032:	2b20      	cmp	r3, #32
    1034:	d0f9      	beq.n	102a <main+0xc0c>
				ptr2 = strchr(ptr, ' ');
    1036:	2120      	movs	r1, #32
    1038:	f003 ff8c 	bl	4f54 <strchr>
				if (!ptr2) break;
    103c:	2800      	cmp	r0, #0
    103e:	f43f aa12 	beq.w	466 <main+0x48>
				*ptr2++ = 0;
    1042:	2300      	movs	r3, #0
    1044:	7003      	strb	r3, [r0, #0]
				while (*ptr2 == ' ') ptr2++;
    1046:	e000      	b.n	104a <main+0xc2c>
    1048:	4608      	mov	r0, r1
    104a:	7843      	ldrb	r3, [r0, #1]
	"\n";




int main (void)
    104c:	1c41      	adds	r1, r0, #1
			case 'n' :	/* fn <org.name> <new.name> - Change name of an object */
				while (*ptr == ' ') ptr++;
				ptr2 = strchr(ptr, ' ');
				if (!ptr2) break;
				*ptr2++ = 0;
				while (*ptr2 == ' ') ptr2++;
    104e:	2b20      	cmp	r3, #32
    1050:	d0fa      	beq.n	1048 <main+0xc2a>
				put_rc(f_rename(ptr, ptr2));
    1052:	9816      	ldr	r0, [sp, #88]	; 0x58
    1054:	f003 fa98 	bl	4588 <f_rename>
    1058:	f7ff f952 	bl	300 <put_rc>
				break;
    105c:	f7ff ba03 	b.w	466 <main+0x48>

			case 'u' :	/* fu <name> - Unlink an object */
				while (*ptr == ' ') ptr++;
    1060:	3001      	adds	r0, #1
    1062:	9016      	str	r0, [sp, #88]	; 0x58
    1064:	9816      	ldr	r0, [sp, #88]	; 0x58
    1066:	7803      	ldrb	r3, [r0, #0]
    1068:	2b20      	cmp	r3, #32
    106a:	d0f9      	beq.n	1060 <main+0xc42>
				put_rc(f_unlink(ptr));
    106c:	f003 f9a0 	bl	43b0 <f_unlink>
    1070:	f7ff f946 	bl	300 <put_rc>
				break;
    1074:	f7ff b9f7 	b.w	466 <main+0x48>

			case 'v' :	/* fv - Truncate file */
				put_rc(f_truncate(&File[0]));
    1078:	4863      	ldr	r0, [pc, #396]	; (1208 <main+0xdea>)
    107a:	f003 f946 	bl	430a <f_truncate>
    107e:	f7ff f93f 	bl	300 <put_rc>
				break;
    1082:	f7ff b9f0 	b.w	466 <main+0x48>

			case 'k' :	/* fk <name> - Create a directory */
				while (*ptr == ' ') ptr++;
    1086:	3001      	adds	r0, #1
    1088:	9016      	str	r0, [sp, #88]	; 0x58
    108a:	9816      	ldr	r0, [sp, #88]	; 0x58
    108c:	7803      	ldrb	r3, [r0, #0]
    108e:	2b20      	cmp	r3, #32
    1090:	d0f9      	beq.n	1086 <main+0xc68>
				put_rc(f_mkdir(ptr));
    1092:	f003 f9ec 	bl	446e <f_mkdir>
    1096:	f7ff f933 	bl	300 <put_rc>
				break;
    109a:	f7ff b9e4 	b.w	466 <main+0x48>
#if FF_USE_CHMOD
			case 'a' :	/* fa <atrr> <mask> <name> - Change attribute of an object */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2)) break;
    109e:	a816      	add	r0, sp, #88	; 0x58
    10a0:	a915      	add	r1, sp, #84	; 0x54
    10a2:	f001 f81d 	bl	20e0 <xatoi>
    10a6:	2800      	cmp	r0, #0
    10a8:	f43f a9dd 	beq.w	466 <main+0x48>
    10ac:	a816      	add	r0, sp, #88	; 0x58
    10ae:	a914      	add	r1, sp, #80	; 0x50
    10b0:	f001 f816 	bl	20e0 <xatoi>
    10b4:	2800      	cmp	r0, #0
    10b6:	f43f a9d6 	beq.w	466 <main+0x48>
    10ba:	e001      	b.n	10c0 <main+0xca2>
				while (*ptr == ' ') ptr++;
    10bc:	3001      	adds	r0, #1
    10be:	9016      	str	r0, [sp, #88]	; 0x58
    10c0:	9816      	ldr	r0, [sp, #88]	; 0x58
    10c2:	7803      	ldrb	r3, [r0, #0]
    10c4:	2b20      	cmp	r3, #32
    10c6:	d0f9      	beq.n	10bc <main+0xc9e>
				put_rc(f_chmod(ptr, p1, p2));
    10c8:	f89d 1054 	ldrb.w	r1, [sp, #84]	; 0x54
    10cc:	f89d 2050 	ldrb.w	r2, [sp, #80]	; 0x50
    10d0:	f003 fae3 	bl	469a <f_chmod>
    10d4:	f7ff f914 	bl	300 <put_rc>
				break;
    10d8:	f7ff b9c5 	b.w	466 <main+0x48>

			case 't' :	/* ft <year> <month> <day> <hour> <min> <sec> <name> - Change timestamp of an object */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2) || !xatoi(&ptr, &p3)) break;
    10dc:	a816      	add	r0, sp, #88	; 0x58
    10de:	a915      	add	r1, sp, #84	; 0x54
    10e0:	f000 fffe 	bl	20e0 <xatoi>
    10e4:	2800      	cmp	r0, #0
    10e6:	f43f a9be 	beq.w	466 <main+0x48>
    10ea:	a816      	add	r0, sp, #88	; 0x58
    10ec:	a914      	add	r1, sp, #80	; 0x50
    10ee:	f000 fff7 	bl	20e0 <xatoi>
    10f2:	2800      	cmp	r0, #0
    10f4:	f43f a9b7 	beq.w	466 <main+0x48>
    10f8:	a816      	add	r0, sp, #88	; 0x58
    10fa:	a913      	add	r1, sp, #76	; 0x4c
    10fc:	f000 fff0 	bl	20e0 <xatoi>
    1100:	2800      	cmp	r0, #0
    1102:	f43f a9b0 	beq.w	466 <main+0x48>
				Finfo.fdate = ((p1 - 1980) << 9) | ((p2 & 15) << 5) | (p3 & 31);
    1106:	9b15      	ldr	r3, [sp, #84]	; 0x54
    1108:	9a14      	ldr	r2, [sp, #80]	; 0x50
    110a:	f5a3 63f6 	sub.w	r3, r3, #1968	; 0x7b0
    110e:	f002 020f 	and.w	r2, r2, #15
    1112:	0152      	lsls	r2, r2, #5
    1114:	3b0c      	subs	r3, #12
    1116:	ea42 2343 	orr.w	r3, r2, r3, lsl #9
    111a:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    111c:	4f3c      	ldr	r7, [pc, #240]	; (1210 <main+0xdf2>)
    111e:	f002 021f 	and.w	r2, r2, #31
    1122:	4313      	orrs	r3, r2
    1124:	80bb      	strh	r3, [r7, #4]
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2) || !xatoi(&ptr, &p3)) break;
    1126:	a816      	add	r0, sp, #88	; 0x58
    1128:	a915      	add	r1, sp, #84	; 0x54
    112a:	f000 ffd9 	bl	20e0 <xatoi>
    112e:	2800      	cmp	r0, #0
    1130:	f43f a999 	beq.w	466 <main+0x48>
    1134:	a816      	add	r0, sp, #88	; 0x58
    1136:	a914      	add	r1, sp, #80	; 0x50
    1138:	f000 ffd2 	bl	20e0 <xatoi>
    113c:	2800      	cmp	r0, #0
    113e:	f43f a992 	beq.w	466 <main+0x48>
    1142:	a816      	add	r0, sp, #88	; 0x58
    1144:	a913      	add	r1, sp, #76	; 0x4c
    1146:	f000 ffcb 	bl	20e0 <xatoi>
    114a:	2800      	cmp	r0, #0
    114c:	f43f a98b 	beq.w	466 <main+0x48>
				Finfo.ftime = ((p1 & 31) << 11) | ((p2 & 63) << 5) | ((p3 >> 1) & 31);
    1150:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    1152:	9a14      	ldr	r2, [sp, #80]	; 0x50
    1154:	105b      	asrs	r3, r3, #1
    1156:	f002 023f 	and.w	r2, r2, #63	; 0x3f
    115a:	f003 031f 	and.w	r3, r3, #31
    115e:	ea43 1342 	orr.w	r3, r3, r2, lsl #5
    1162:	9a15      	ldr	r2, [sp, #84]	; 0x54
				put_rc(f_utime(ptr, &Finfo));
    1164:	4639      	mov	r1, r7

			case 't' :	/* ft <year> <month> <day> <hour> <min> <sec> <name> - Change timestamp of an object */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2) || !xatoi(&ptr, &p3)) break;
				Finfo.fdate = ((p1 - 1980) << 9) | ((p2 & 15) << 5) | (p3 & 31);
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2) || !xatoi(&ptr, &p3)) break;
				Finfo.ftime = ((p1 & 31) << 11) | ((p2 & 63) << 5) | ((p3 >> 1) & 31);
    1166:	ea43 23c2 	orr.w	r3, r3, r2, lsl #11
    116a:	80fb      	strh	r3, [r7, #6]
				put_rc(f_utime(ptr, &Finfo));
    116c:	9816      	ldr	r0, [sp, #88]	; 0x58
    116e:	f003 fac1 	bl	46f4 <f_utime>
    1172:	f7ff f8c5 	bl	300 <put_rc>
				break;
    1176:	f7ff b976 	b.w	466 <main+0x48>
#endif
			case 'x' : /* fx <src.name> <dst.name> - Copy a file */
				while (*ptr == ' ') ptr++;
    117a:	3001      	adds	r0, #1
    117c:	9016      	str	r0, [sp, #88]	; 0x58
    117e:	9816      	ldr	r0, [sp, #88]	; 0x58
    1180:	7803      	ldrb	r3, [r0, #0]
    1182:	2b20      	cmp	r3, #32
    1184:	d0f9      	beq.n	117a <main+0xd5c>
				ptr2 = strchr(ptr, ' ');
    1186:	2120      	movs	r1, #32
    1188:	f003 fee4 	bl	4f54 <strchr>
				if (!ptr2) break;
    118c:	2800      	cmp	r0, #0
    118e:	f43f a96a 	beq.w	466 <main+0x48>
				*ptr2++ = 0;
    1192:	2300      	movs	r3, #0
    1194:	7003      	strb	r3, [r0, #0]
				while (*ptr2 == ' ') ptr2++;
    1196:	e000      	b.n	119a <main+0xd7c>
    1198:	4638      	mov	r0, r7
    119a:	7843      	ldrb	r3, [r0, #1]
	"\n";




int main (void)
    119c:	1c47      	adds	r7, r0, #1
			case 'x' : /* fx <src.name> <dst.name> - Copy a file */
				while (*ptr == ' ') ptr++;
				ptr2 = strchr(ptr, ' ');
				if (!ptr2) break;
				*ptr2++ = 0;
				while (*ptr2 == ' ') ptr2++;
    119e:	2b20      	cmp	r3, #32
    11a0:	d0fa      	beq.n	1198 <main+0xd7a>
				xprintf("Opening \"%s\"", ptr);
    11a2:	481c      	ldr	r0, [pc, #112]	; (1214 <main+0xdf6>)
    11a4:	9916      	ldr	r1, [sp, #88]	; 0x58
    11a6:	f000 fee9 	bl	1f7c <xprintf>
				res = f_open(&File[0], ptr, FA_OPEN_EXISTING | FA_READ);
    11aa:	4817      	ldr	r0, [pc, #92]	; (1208 <main+0xdea>)
    11ac:	9916      	ldr	r1, [sp, #88]	; 0x58
    11ae:	2201      	movs	r2, #1
    11b0:	f002 fb70 	bl	3894 <f_open>
    11b4:	4680      	mov	r8, r0
				xputc('\n');
    11b6:	200a      	movs	r0, #10
    11b8:	f000 fdd4 	bl	1d64 <xputc>
				if (res) {
    11bc:	f1b8 0f00 	cmp.w	r8, #0
    11c0:	d004      	beq.n	11cc <main+0xdae>
					put_rc(res);
    11c2:	4640      	mov	r0, r8
    11c4:	f7ff f89c 	bl	300 <put_rc>
					break;
    11c8:	f7ff b94d 	b.w	466 <main+0x48>
				}
				xprintf("Creating \"%s\"", ptr2);
    11cc:	4812      	ldr	r0, [pc, #72]	; (1218 <main+0xdfa>)
    11ce:	4639      	mov	r1, r7
    11d0:	f000 fed4 	bl	1f7c <xprintf>
				res = f_open(&File[1], ptr2, FA_CREATE_ALWAYS | FA_WRITE);
    11d4:	4811      	ldr	r0, [pc, #68]	; (121c <main+0xdfe>)
    11d6:	4639      	mov	r1, r7
    11d8:	220a      	movs	r2, #10
    11da:	f002 fb5b 	bl	3894 <f_open>
    11de:	4680      	mov	r8, r0
				xputc('\n');
    11e0:	200a      	movs	r0, #10
    11e2:	f000 fdbf 	bl	1d64 <xputc>
				if (res) {
    11e6:	f1b8 0f00 	cmp.w	r8, #0
    11ea:	d019      	beq.n	1220 <main+0xe02>
					put_rc(res);
    11ec:	4640      	mov	r0, r8
    11ee:	f7ff f887 	bl	300 <put_rc>
					f_close(&File[0]);
    11f2:	4805      	ldr	r0, [pc, #20]	; (1208 <main+0xdea>)
    11f4:	f002 fdfd 	bl	3df2 <f_close>
					break;
    11f8:	f7ff b935 	b.w	466 <main+0x48>
    11fc:	100007d4 	.word	0x100007d4
    1200:	00005b22 	.word	0x00005b22
    1204:	100007dc 	.word	0x100007dc
    1208:	10000384 	.word	0x10000384
    120c:	00005b41 	.word	0x00005b41
    1210:	1000036c 	.word	0x1000036c
    1214:	00005b63 	.word	0x00005b63
    1218:	00005b70 	.word	0x00005b70
    121c:	100005ac 	.word	0x100005ac
				}
				xprintf("Copying file...");
				Timer = 0;
    1220:	4f7a      	ldr	r7, [pc, #488]	; (140c <main+0xfee>)
				if (res) {
					put_rc(res);
					f_close(&File[0]);
					break;
				}
				xprintf("Copying file...");
    1222:	487b      	ldr	r0, [pc, #492]	; (1410 <main+0xff2>)
    1224:	f000 feaa 	bl	1f7c <xprintf>
				Timer = 0;
    1228:	f8c7 8000 	str.w	r8, [r7]
				p1 = 0;
    122c:	f8cd 8054 	str.w	r8, [sp, #84]	; 0x54
				for (;;) {
					res = f_read(&File[0], Buff, blen, &s1);
    1230:	4878      	ldr	r0, [pc, #480]	; (1414 <main+0xff6>)
    1232:	4979      	ldr	r1, [pc, #484]	; (1418 <main+0xffa>)
    1234:	4622      	mov	r2, r4
    1236:	ab12      	add	r3, sp, #72	; 0x48
    1238:	f002 fc12 	bl	3a60 <f_read>
					if (res || s1 == 0) break;   /* error or eof */
    123c:	b970      	cbnz	r0, 125c <main+0xe3e>
    123e:	9a12      	ldr	r2, [sp, #72]	; 0x48
    1240:	b162      	cbz	r2, 125c <main+0xe3e>
					res = f_write(&File[1], Buff, s1, &s2);
    1242:	ab11      	add	r3, sp, #68	; 0x44
    1244:	4875      	ldr	r0, [pc, #468]	; (141c <main+0xffe>)
    1246:	4974      	ldr	r1, [pc, #464]	; (1418 <main+0xffa>)
    1248:	f002 fcbc 	bl	3bc4 <f_write>
					p1 += s2;
    124c:	9a15      	ldr	r2, [sp, #84]	; 0x54
    124e:	9b11      	ldr	r3, [sp, #68]	; 0x44
    1250:	18d2      	adds	r2, r2, r3
    1252:	9215      	str	r2, [sp, #84]	; 0x54
					if (res || s2 < s1) break;   /* error or disk full */
    1254:	b910      	cbnz	r0, 125c <main+0xe3e>
    1256:	9a12      	ldr	r2, [sp, #72]	; 0x48
    1258:	4293      	cmp	r3, r2
    125a:	d2e9      	bcs.n	1230 <main+0xe12>
				}
				xprintf("\n%lu bytes copied at %lu kB/sec.\n", p1, p1 / Timer);
    125c:	9915      	ldr	r1, [sp, #84]	; 0x54
    125e:	683a      	ldr	r2, [r7, #0]
    1260:	486f      	ldr	r0, [pc, #444]	; (1420 <main+0x1002>)
    1262:	fbb1 f2f2 	udiv	r2, r1, r2
    1266:	f000 fe89 	bl	1f7c <xprintf>
				f_close(&File[0]);
    126a:	486a      	ldr	r0, [pc, #424]	; (1414 <main+0xff6>)
    126c:	f002 fdc1 	bl	3df2 <f_close>
				f_close(&File[1]);
    1270:	486a      	ldr	r0, [pc, #424]	; (141c <main+0xffe>)
    1272:	f002 fdbe 	bl	3df2 <f_close>
				break;
    1276:	f7ff b8f6 	b.w	466 <main+0x48>
#if FF_FS_RPATH
			case 'g' :	/* fg <path> - Change current directory */
				while (*ptr == ' ') ptr++;
    127a:	3001      	adds	r0, #1
    127c:	9016      	str	r0, [sp, #88]	; 0x58
    127e:	9816      	ldr	r0, [sp, #88]	; 0x58
    1280:	7803      	ldrb	r3, [r0, #0]
    1282:	2b20      	cmp	r3, #32
    1284:	d0f9      	beq.n	127a <main+0xe5c>
				put_rc(f_chdir(ptr));
    1286:	f002 fdd1 	bl	3e2c <f_chdir>
    128a:	f7ff f839 	bl	300 <put_rc>
				break;
    128e:	f7ff b8ea 	b.w	466 <main+0x48>
#if FF_FS_RPATH >= 2
			case 'q' :	/* fq - Show current dir path */
				res = f_getcwd(Line, sizeof Line);
    1292:	4864      	ldr	r0, [pc, #400]	; (1424 <main+0x1006>)
    1294:	f44f 7180 	mov.w	r1, #256	; 0x100
    1298:	f002 fdf9 	bl	3e8e <f_getcwd>
				if (res)
    129c:	b118      	cbz	r0, 12a6 <main+0xe88>
					put_rc(res);
    129e:	f7ff f82f 	bl	300 <put_rc>
    12a2:	f7ff b8e0 	b.w	466 <main+0x48>
				else
					xprintf("%s\n", Line);
    12a6:	4860      	ldr	r0, [pc, #384]	; (1428 <main+0x100a>)
    12a8:	495e      	ldr	r1, [pc, #376]	; (1424 <main+0x1006>)
    12aa:	f000 fe67 	bl	1f7c <xprintf>
    12ae:	f7ff b8da 	b.w	466 <main+0x48>
				break;
#endif
#endif
#if FF_USE_LABEL
			case 'b' :	/* fb <name> - Set volume label */
				while (*ptr == ' ') ptr++;
    12b2:	3001      	adds	r0, #1
    12b4:	9016      	str	r0, [sp, #88]	; 0x58
    12b6:	9816      	ldr	r0, [sp, #88]	; 0x58
    12b8:	7803      	ldrb	r3, [r0, #0]
    12ba:	2b20      	cmp	r3, #32
    12bc:	d0f9      	beq.n	12b2 <main+0xe94>
				put_rc(f_setlabel(ptr));
    12be:	f003 fa91 	bl	47e4 <f_setlabel>
    12c2:	f7ff f81d 	bl	300 <put_rc>
				break;
    12c6:	f7ff b8ce 	b.w	466 <main+0x48>
#endif	/* _USE_LABEL */
#if FF_USE_MKFS
			case 'm' :	/* fm <type> <csize> - Create file system */
				if (!xatoi(&ptr, &p2) || !xatoi(&ptr, &p3)) break;
    12ca:	a816      	add	r0, sp, #88	; 0x58
    12cc:	a914      	add	r1, sp, #80	; 0x50
    12ce:	f000 ff07 	bl	20e0 <xatoi>
    12d2:	2800      	cmp	r0, #0
    12d4:	f43f a8c7 	beq.w	466 <main+0x48>
    12d8:	a816      	add	r0, sp, #88	; 0x58
    12da:	a913      	add	r1, sp, #76	; 0x4c
    12dc:	f000 ff00 	bl	20e0 <xatoi>
    12e0:	2800      	cmp	r0, #0
    12e2:	f43f a8c0 	beq.w	466 <main+0x48>
				xprintf("The volume will be formatted. Are you sure? (Y/n)=");
    12e6:	4851      	ldr	r0, [pc, #324]	; (142c <main+0x100e>)
    12e8:	f000 fe48 	bl	1f7c <xprintf>
				xgets(Line, sizeof Line);
    12ec:	484d      	ldr	r0, [pc, #308]	; (1424 <main+0x1006>)
    12ee:	f44f 7180 	mov.w	r1, #256	; 0x100
    12f2:	f000 fec1 	bl	2078 <xgets>
				if (Line[0] == 'Y')
    12f6:	f898 3000 	ldrb.w	r3, [r8]
    12fa:	2b59      	cmp	r3, #89	; 0x59
    12fc:	f47f a8b3 	bne.w	466 <main+0x48>
					put_rc(f_mkfs("", (BYTE)p2, (WORD)p3, Buff, sizeof Buff));
    1300:	f44f 4380 	mov.w	r3, #16384	; 0x4000
    1304:	f89d 1050 	ldrb.w	r1, [sp, #80]	; 0x50
    1308:	f8bd 204c 	ldrh.w	r2, [sp, #76]	; 0x4c
    130c:	9300      	str	r3, [sp, #0]
    130e:	4848      	ldr	r0, [pc, #288]	; (1430 <main+0x1012>)
    1310:	4b41      	ldr	r3, [pc, #260]	; (1418 <main+0xffa>)
    1312:	f003 fafd 	bl	4910 <f_mkfs>
    1316:	f7fe fff3 	bl	300 <put_rc>
    131a:	f7ff b8a4 	b.w	466 <main+0x48>
				break;
#endif	/* _USE_MKFS */
			case 'z' :	/* fz [<size>] - Change/Show R/W length for fr/fw/fx command */
				if (xatoi(&ptr, &p1) && p1 >= 1 && p1 <= (long)sizeof Buff)
    131e:	a816      	add	r0, sp, #88	; 0x58
    1320:	a915      	add	r1, sp, #84	; 0x54
    1322:	f000 fedd 	bl	20e0 <xatoi>
    1326:	b130      	cbz	r0, 1336 <main+0xf18>
    1328:	9b15      	ldr	r3, [sp, #84]	; 0x54
    132a:	2b00      	cmp	r3, #0
    132c:	dd03      	ble.n	1336 <main+0xf18>
					blen = p1;
    132e:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
    1332:	bfd8      	it	le
    1334:	461c      	movle	r4, r3
				xprintf("blen=%u\n", blen);
    1336:	483f      	ldr	r0, [pc, #252]	; (1434 <main+0x1016>)
    1338:	4621      	mov	r1, r4
    133a:	f000 fe1f 	bl	1f7c <xprintf>
				break;
    133e:	f7ff b892 	b.w	466 <main+0x48>
			}
			break;
#ifdef SOUND_DEFINED
		case 'p' :	/* p <wavfile> - Play RIFF-WAV file */
			while (*ptr == ' ') ptr++;
    1342:	3101      	adds	r1, #1
    1344:	9116      	str	r1, [sp, #88]	; 0x58
    1346:	9916      	ldr	r1, [sp, #88]	; 0x58
    1348:	780b      	ldrb	r3, [r1, #0]
    134a:	2b20      	cmp	r3, #32
    134c:	d0f9      	beq.n	1342 <main+0xf24>
			res = f_open(&File[0], ptr, FA_READ);
    134e:	4831      	ldr	r0, [pc, #196]	; (1414 <main+0xff6>)
    1350:	2201      	movs	r2, #1
    1352:	f002 fa9f 	bl	3894 <f_open>
			if (res) {
    1356:	b118      	cbz	r0, 1360 <main+0xf42>
				put_rc(res);
    1358:	f7fe ffd2 	bl	300 <put_rc>
    135c:	f7ff b883 	b.w	466 <main+0x48>
			} else {
				load_wav(&File[0], "WAV Player", Buff, sizeof Buff);
    1360:	4935      	ldr	r1, [pc, #212]	; (1438 <main+0x101a>)
    1362:	4a2d      	ldr	r2, [pc, #180]	; (1418 <main+0xffa>)
    1364:	f44f 4380 	mov.w	r3, #16384	; 0x4000
    1368:	482a      	ldr	r0, [pc, #168]	; (1414 <main+0xff6>)
    136a:	f000 fb4f 	bl	1a0c <load_wav>
				f_close(&File[0]);
    136e:	4829      	ldr	r0, [pc, #164]	; (1414 <main+0xff6>)
    1370:	f002 fd3f 	bl	3df2 <f_close>
    1374:	f7ff b877 	b.w	466 <main+0x48>
			}
			break;
#endif
		case 't' :	/* t [<year> <mon> <mday> <hour> <min> <sec>] - Set/Show RTC */
			if (xatoi(&ptr, &p1)) {
    1378:	a816      	add	r0, sp, #88	; 0x58
    137a:	a915      	add	r1, sp, #84	; 0x54
    137c:	f000 feb0 	bl	20e0 <xatoi>
    1380:	b360      	cbz	r0, 13dc <main+0xfbe>
				rtc.year = (WORD)p1;
    1382:	f8bd 2054 	ldrh.w	r2, [sp, #84]	; 0x54
				xatoi(&ptr, &p1); rtc.month = (BYTE)p1;
    1386:	a915      	add	r1, sp, #84	; 0x54
    1388:	a816      	add	r0, sp, #88	; 0x58
			}
			break;
#endif
		case 't' :	/* t [<year> <mon> <mday> <hour> <min> <sec>] - Set/Show RTC */
			if (xatoi(&ptr, &p1)) {
				rtc.year = (WORD)p1;
    138a:	f8ad 202c 	strh.w	r2, [sp, #44]	; 0x2c
				xatoi(&ptr, &p1); rtc.month = (BYTE)p1;
    138e:	f000 fea7 	bl	20e0 <xatoi>
    1392:	9b15      	ldr	r3, [sp, #84]	; 0x54
				xatoi(&ptr, &p1); rtc.mday = (BYTE)p1;
    1394:	a915      	add	r1, sp, #84	; 0x54
    1396:	a816      	add	r0, sp, #88	; 0x58
			break;
#endif
		case 't' :	/* t [<year> <mon> <mday> <hour> <min> <sec>] - Set/Show RTC */
			if (xatoi(&ptr, &p1)) {
				rtc.year = (WORD)p1;
				xatoi(&ptr, &p1); rtc.month = (BYTE)p1;
    1398:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
				xatoi(&ptr, &p1); rtc.mday = (BYTE)p1;
    139c:	f000 fea0 	bl	20e0 <xatoi>
    13a0:	9b15      	ldr	r3, [sp, #84]	; 0x54
				xatoi(&ptr, &p1); rtc.hour = (BYTE)p1;
    13a2:	a915      	add	r1, sp, #84	; 0x54
    13a4:	a816      	add	r0, sp, #88	; 0x58
#endif
		case 't' :	/* t [<year> <mon> <mday> <hour> <min> <sec>] - Set/Show RTC */
			if (xatoi(&ptr, &p1)) {
				rtc.year = (WORD)p1;
				xatoi(&ptr, &p1); rtc.month = (BYTE)p1;
				xatoi(&ptr, &p1); rtc.mday = (BYTE)p1;
    13a6:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
				xatoi(&ptr, &p1); rtc.hour = (BYTE)p1;
    13aa:	f000 fe99 	bl	20e0 <xatoi>
    13ae:	9b15      	ldr	r3, [sp, #84]	; 0x54
				xatoi(&ptr, &p1); rtc.min = (BYTE)p1;
    13b0:	a915      	add	r1, sp, #84	; 0x54
    13b2:	a816      	add	r0, sp, #88	; 0x58
		case 't' :	/* t [<year> <mon> <mday> <hour> <min> <sec>] - Set/Show RTC */
			if (xatoi(&ptr, &p1)) {
				rtc.year = (WORD)p1;
				xatoi(&ptr, &p1); rtc.month = (BYTE)p1;
				xatoi(&ptr, &p1); rtc.mday = (BYTE)p1;
				xatoi(&ptr, &p1); rtc.hour = (BYTE)p1;
    13b4:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
				xatoi(&ptr, &p1); rtc.min = (BYTE)p1;
    13b8:	f000 fe92 	bl	20e0 <xatoi>
    13bc:	9b15      	ldr	r3, [sp, #84]	; 0x54
				if (!xatoi(&ptr, &p1)) break;
    13be:	a816      	add	r0, sp, #88	; 0x58
    13c0:	a915      	add	r1, sp, #84	; 0x54
			if (xatoi(&ptr, &p1)) {
				rtc.year = (WORD)p1;
				xatoi(&ptr, &p1); rtc.month = (BYTE)p1;
				xatoi(&ptr, &p1); rtc.mday = (BYTE)p1;
				xatoi(&ptr, &p1); rtc.hour = (BYTE)p1;
				xatoi(&ptr, &p1); rtc.min = (BYTE)p1;
    13c2:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
				if (!xatoi(&ptr, &p1)) break;
    13c6:	f000 fe8b 	bl	20e0 <xatoi>
    13ca:	2800      	cmp	r0, #0
    13cc:	f43f a84b 	beq.w	466 <main+0x48>
				rtc.sec = (BYTE)p1;
    13d0:	9b15      	ldr	r3, [sp, #84]	; 0x54
				rtc_settime(&rtc);
    13d2:	a80b      	add	r0, sp, #44	; 0x2c
				xatoi(&ptr, &p1); rtc.month = (BYTE)p1;
				xatoi(&ptr, &p1); rtc.mday = (BYTE)p1;
				xatoi(&ptr, &p1); rtc.hour = (BYTE)p1;
				xatoi(&ptr, &p1); rtc.min = (BYTE)p1;
				if (!xatoi(&ptr, &p1)) break;
				rtc.sec = (BYTE)p1;
    13d4:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
				rtc_settime(&rtc);
    13d8:	f000 f9da 	bl	1790 <rtc_settime>
			}
			rtc_gettime(&rtc);
    13dc:	a80b      	add	r0, sp, #44	; 0x2c
    13de:	f000 f997 	bl	1710 <rtc_gettime>
			xprintf("%u/%u/%u %02u:%02u:%02u\n", rtc.year, rtc.month, rtc.mday, rtc.hour, rtc.min, rtc.sec);
    13e2:	f89d 0031 	ldrb.w	r0, [sp, #49]	; 0x31
    13e6:	f8bd 102c 	ldrh.w	r1, [sp, #44]	; 0x2c
    13ea:	9000      	str	r0, [sp, #0]
    13ec:	f89d 0032 	ldrb.w	r0, [sp, #50]	; 0x32
    13f0:	f89d 202e 	ldrb.w	r2, [sp, #46]	; 0x2e
    13f4:	9001      	str	r0, [sp, #4]
    13f6:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
    13fa:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
    13fe:	9002      	str	r0, [sp, #8]
    1400:	480e      	ldr	r0, [pc, #56]	; (143c <main+0x101e>)
    1402:	f000 fdbb 	bl	1f7c <xprintf>
    1406:	f7ff b82e 	b.w	466 <main+0x48>
    140a:	bf00      	nop
    140c:	100007d4 	.word	0x100007d4
    1410:	00005b7e 	.word	0x00005b7e
    1414:	10000384 	.word	0x10000384
    1418:	100007dc 	.word	0x100007dc
    141c:	100005ac 	.word	0x100005ac
    1420:	00005b8e 	.word	0x00005b8e
    1424:	1000480c 	.word	0x1000480c
    1428:	00005ad0 	.word	0x00005ad0
    142c:	00005bb0 	.word	0x00005bb0
    1430:	00005a3e 	.word	0x00005a3e
    1434:	00005be3 	.word	0x00005be3
    1438:	00005bec 	.word	0x00005bec
    143c:	00005bf7 	.word	0x00005bf7

00001440 <SVC_Handler>:
/*--------------------------------------------------------------------/
/ Default SVC Handler                                                 /
/--------------------------------------------------------------------*/

void SVC_Handler (void)
{
    1440:	e7fe      	b.n	1440 <SVC_Handler>

00001442 <Reset_Handler>:
{
	long *s, *d;

	/* Configure system clock generator */

	FLASHCFG = (FLASHCFG & 0xFFFF0FFF) | (FLASH_WAIT << 12);	/* Configure flash accelerator */
    1442:	4b28      	ldr	r3, [pc, #160]	; (14e4 <Reset_Handler+0xa2>)

	/* Set to PLL bypass mode if PLL is in use */
	PLL0CON = 1;
    1444:	4828      	ldr	r0, [pc, #160]	; (14e8 <Reset_Handler+0xa6>)
{
	long *s, *d;

	/* Configure system clock generator */

	FLASHCFG = (FLASHCFG & 0xFFFF0FFF) | (FLASH_WAIT << 12);	/* Configure flash accelerator */
    1446:	681a      	ldr	r2, [r3, #0]

	/* Set to PLL bypass mode if PLL is in use */
	PLL0CON = 1;
	PLL0FEED = 0xAA; PLL0FEED = 0x55;
    1448:	21aa      	movs	r1, #170	; 0xaa
{
	long *s, *d;

	/* Configure system clock generator */

	FLASHCFG = (FLASHCFG & 0xFFFF0FFF) | (FLASH_WAIT << 12);	/* Configure flash accelerator */
    144a:	f422 4270 	bic.w	r2, r2, #61440	; 0xf000
    144e:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
    1452:	601a      	str	r2, [r3, #0]

	/* Set to PLL bypass mode if PLL is in use */
	PLL0CON = 1;
    1454:	2301      	movs	r3, #1
    1456:	6003      	str	r3, [r0, #0]
	PLL0FEED = 0xAA; PLL0FEED = 0x55;
    1458:	4b24      	ldr	r3, [pc, #144]	; (14ec <Reset_Handler+0xaa>)
    145a:	2255      	movs	r2, #85	; 0x55
	/* Disable PLL */
	PLL0CON = 0;
    145c:	2400      	movs	r4, #0

	FLASHCFG = (FLASHCFG & 0xFFFF0FFF) | (FLASH_WAIT << 12);	/* Configure flash accelerator */

	/* Set to PLL bypass mode if PLL is in use */
	PLL0CON = 1;
	PLL0FEED = 0xAA; PLL0FEED = 0x55;
    145e:	6019      	str	r1, [r3, #0]
    1460:	601a      	str	r2, [r3, #0]
	/* Disable PLL */
	PLL0CON = 0;
    1462:	6004      	str	r4, [r0, #0]
	PLL0FEED = 0xAA; PLL0FEED = 0x55;
    1464:	6019      	str	r1, [r3, #0]
    1466:	601a      	str	r2, [r3, #0]

	if (OSC_SEL == 1) {	/* Enable main oscillator */
		SCS = F_OSC >= 17500000 ? 0x30 : 0x20;
    1468:	4b21      	ldr	r3, [pc, #132]	; (14f0 <Reset_Handler+0xae>)
    146a:	3a35      	subs	r2, #53	; 0x35
    146c:	601a      	str	r2, [r3, #0]
		while (!(SCS & 0x40)) ;	/* Wait for oscillation stable */
    146e:	4b20      	ldr	r3, [pc, #128]	; (14f0 <Reset_Handler+0xae>)
    1470:	681b      	ldr	r3, [r3, #0]
    1472:	f013 0f40 	tst.w	r3, #64	; 0x40
    1476:	d0fa      	beq.n	146e <Reset_Handler+0x2c>
	} else {			/* Disable main oscillator */
		SCS = 0;
	}
	CLKSRCSEL = OSC_SEL;	/* Select specified oscillator as PLL input */
    1478:	4b1e      	ldr	r3, [pc, #120]	; (14f4 <Reset_Handler+0xb2>)
    147a:	2001      	movs	r0, #1
	CCLKCFG = CCLK_SEL - 1;	/* Set cclk divider (divide ratio of pllclk) */
    147c:	2203      	movs	r2, #3
		SCS = F_OSC >= 17500000 ? 0x30 : 0x20;
		while (!(SCS & 0x40)) ;	/* Wait for oscillation stable */
	} else {			/* Disable main oscillator */
		SCS = 0;
	}
	CLKSRCSEL = OSC_SEL;	/* Select specified oscillator as PLL input */
    147e:	6018      	str	r0, [r3, #0]
	CCLKCFG = CCLK_SEL - 1;	/* Set cclk divider (divide ratio of pllclk) */
    1480:	f843 2c08 	str.w	r2, [r3, #-8]

	if (USE_PLL) {
		PLL0CFG = ((PLL_N - 1) << 16) | (PLL_M - 1);	/* Initialize PLL registers */
    1484:	4a1c      	ldr	r2, [pc, #112]	; (14f8 <Reset_Handler+0xb6>)
		PLL0FEED = 0xAA; PLL0FEED = 0x55;
		PLL0CON = 1;			/* Enable PLL */
    1486:	4c18      	ldr	r4, [pc, #96]	; (14e8 <Reset_Handler+0xa6>)
	}
	CLKSRCSEL = OSC_SEL;	/* Select specified oscillator as PLL input */
	CCLKCFG = CCLK_SEL - 1;	/* Set cclk divider (divide ratio of pllclk) */

	if (USE_PLL) {
		PLL0CFG = ((PLL_N - 1) << 16) | (PLL_M - 1);	/* Initialize PLL registers */
    1488:	f843 2c88 	str.w	r2, [r3, #-136]
		PLL0FEED = 0xAA; PLL0FEED = 0x55;
    148c:	21aa      	movs	r1, #170	; 0xaa
    148e:	2255      	movs	r2, #85	; 0x55
    1490:	f843 1c80 	str.w	r1, [r3, #-128]
    1494:	f843 2c80 	str.w	r2, [r3, #-128]
		PLL0CON = 1;			/* Enable PLL */
    1498:	6020      	str	r0, [r4, #0]
		PLL0FEED = 0xAA; PLL0FEED = 0x55;
    149a:	f843 1c80 	str.w	r1, [r3, #-128]
    149e:	f843 2c80 	str.w	r2, [r3, #-128]
		while ((PLL0STAT & (1<<26)) == 0) ;	/* Wait for PLL locked */
    14a2:	4b16      	ldr	r3, [pc, #88]	; (14fc <Reset_Handler+0xba>)
    14a4:	681b      	ldr	r3, [r3, #0]
    14a6:	f013 6f80 	tst.w	r3, #67108864	; 0x4000000
    14aa:	d0fa      	beq.n	14a2 <Reset_Handler+0x60>
		PLL0CON = 3;			/* Connect PLL output to the pllclk divider */
    14ac:	4b0e      	ldr	r3, [pc, #56]	; (14e8 <Reset_Handler+0xa6>)
    14ae:	2203      	movs	r2, #3
    14b0:	601a      	str	r2, [r3, #0]
		PLL0FEED = 0xAA; PLL0FEED = 0x55;
    14b2:	32a7      	adds	r2, #167	; 0xa7
    14b4:	60da      	str	r2, [r3, #12]
    14b6:	3a55      	subs	r2, #85	; 0x55
    14b8:	60da      	str	r2, [r3, #12]
    14ba:	4a11      	ldr	r2, [pc, #68]	; (1500 <Reset_Handler+0xbe>)
		*** LPC176x has no EMC ***
	*/


	/* Initialize .data/.bss section and static objects get ready to use after this process */
	for (s = _sidata, d = _sdata; d < _edata; *d++ = *s++) ;
    14bc:	4b11      	ldr	r3, [pc, #68]	; (1504 <Reset_Handler+0xc2>)
    14be:	e003      	b.n	14c8 <Reset_Handler+0x86>
    14c0:	f852 1b04 	ldr.w	r1, [r2], #4
    14c4:	f843 1b04 	str.w	r1, [r3], #4
    14c8:	490f      	ldr	r1, [pc, #60]	; (1508 <Reset_Handler+0xc6>)
    14ca:	428b      	cmp	r3, r1
    14cc:	d3f8      	bcc.n	14c0 <Reset_Handler+0x7e>
    14ce:	4b0f      	ldr	r3, [pc, #60]	; (150c <Reset_Handler+0xca>)
    14d0:	e002      	b.n	14d8 <Reset_Handler+0x96>
	for (d = _sbss; d < _ebss; *d++ = 0) ;
    14d2:	2200      	movs	r2, #0
    14d4:	f843 2b04 	str.w	r2, [r3], #4
    14d8:	4a0d      	ldr	r2, [pc, #52]	; (1510 <Reset_Handler+0xce>)
    14da:	4293      	cmp	r3, r2
    14dc:	d3f9      	bcc.n	14d2 <Reset_Handler+0x90>

	/* Start main() with MSP and privileged mode */
	main();
    14de:	f7fe ff9e 	bl	41e <main>
    14e2:	e7fe      	b.n	14e2 <Reset_Handler+0xa0>
    14e4:	400fc000 	.word	0x400fc000
    14e8:	400fc080 	.word	0x400fc080
    14ec:	400fc08c 	.word	0x400fc08c
    14f0:	400fc1a0 	.word	0x400fc1a0
    14f4:	400fc10c 	.word	0x400fc10c
    14f8:	000b00c7 	.word	0x000b00c7
    14fc:	400fc088 	.word	0x400fc088
    1500:	00005d20 	.word	0x00005d20
    1504:	10000000 	.word	0x10000000
    1508:	10000004 	.word	0x10000004
    150c:	10000004 	.word	0x10000004
    1510:	10004918 	.word	0x10004918

00001514 <Exception_Trap>:
/*--------------------------------------------------------------------/
/ Unexpected Exception/IRQ Trap                                       /
/--------------------------------------------------------------------*/

void Exception_Trap (void)
{
    1514:	e7fe      	b.n	1514 <Exception_Trap>

00001516 <IRQ_Trap>:
	for (;;) ;
}


void IRQ_Trap (void)
{
    1516:	e7fe      	b.n	1516 <IRQ_Trap>

00001518 <UART0_IRQHandler>:
	uint16_t	ri, wi, ct;
	uint8_t		buff[UART0_RXB];
} RxBuff0;

void UART0_IRQHandler (void)
{
    1518:	b570      	push	{r4, r5, r6, lr}
	uint8_t iir, d;
	int i, cnt;


	for (;;) {
		iir = U0IIR;			/* Get interrupt ID */
    151a:	4b28      	ldr	r3, [pc, #160]	; (15bc <UART0_IRQHandler+0xa4>)
    151c:	681b      	ldr	r3, [r3, #0]
		if (iir & 1) break;		/* Exit if there is no interrupt */
    151e:	b2db      	uxtb	r3, r3
    1520:	f013 0f01 	tst.w	r3, #1
    1524:	d148      	bne.n	15b8 <UART0_IRQHandler+0xa0>
		switch (iir & 7) {
    1526:	f003 0307 	and.w	r3, r3, #7
    152a:	2b02      	cmp	r3, #2
    152c:	d01d      	beq.n	156a <UART0_IRQHandler+0x52>
    152e:	2b04      	cmp	r3, #4
    1530:	d13d      	bne.n	15ae <UART0_IRQHandler+0x96>
		case 4:			/* Rx FIFO is half filled or timeout occured */
			i = RxBuff0.wi;
    1532:	4b23      	ldr	r3, [pc, #140]	; (15c0 <UART0_IRQHandler+0xa8>)
    1534:	8859      	ldrh	r1, [r3, #2]
			cnt = RxBuff0.ct;
    1536:	889a      	ldrh	r2, [r3, #4]
	for (;;) {
		iir = U0IIR;			/* Get interrupt ID */
		if (iir & 1) break;		/* Exit if there is no interrupt */
		switch (iir & 7) {
		case 4:			/* Rx FIFO is half filled or timeout occured */
			i = RxBuff0.wi;
    1538:	b289      	uxth	r1, r1
			cnt = RxBuff0.ct;
    153a:	b292      	uxth	r2, r2
    153c:	4618      	mov	r0, r3
			while (U0LSR & 0x01) {	/* Get all data in the Rx FIFO */
    153e:	e00a      	b.n	1556 <UART0_IRQHandler+0x3e>
				d = U0RBR;
    1540:	4c20      	ldr	r4, [pc, #128]	; (15c4 <UART0_IRQHandler+0xac>)
				if (cnt < UART0_RXB) {	/* Store data if Rx buffer is not full */
    1542:	2a7f      	cmp	r2, #127	; 0x7f
		switch (iir & 7) {
		case 4:			/* Rx FIFO is half filled or timeout occured */
			i = RxBuff0.wi;
			cnt = RxBuff0.ct;
			while (U0LSR & 0x01) {	/* Get all data in the Rx FIFO */
				d = U0RBR;
    1544:	6825      	ldr	r5, [r4, #0]
    1546:	b2ed      	uxtb	r5, r5
				if (cnt < UART0_RXB) {	/* Store data if Rx buffer is not full */
    1548:	dc05      	bgt.n	1556 <UART0_IRQHandler+0x3e>
					RxBuff0.buff[i++] = d;
    154a:	1844      	adds	r4, r0, r1
    154c:	3101      	adds	r1, #1
    154e:	71a5      	strb	r5, [r4, #6]
					i %= UART0_RXB;
    1550:	f001 017f 	and.w	r1, r1, #127	; 0x7f
					cnt++;
    1554:	3201      	adds	r2, #1
		if (iir & 1) break;		/* Exit if there is no interrupt */
		switch (iir & 7) {
		case 4:			/* Rx FIFO is half filled or timeout occured */
			i = RxBuff0.wi;
			cnt = RxBuff0.ct;
			while (U0LSR & 0x01) {	/* Get all data in the Rx FIFO */
    1556:	4c1c      	ldr	r4, [pc, #112]	; (15c8 <UART0_IRQHandler+0xb0>)
    1558:	6824      	ldr	r4, [r4, #0]
    155a:	f014 0f01 	tst.w	r4, #1
    155e:	d1ef      	bne.n	1540 <UART0_IRQHandler+0x28>
					RxBuff0.buff[i++] = d;
					i %= UART0_RXB;
					cnt++;
				}
			}
			RxBuff0.wi = i;
    1560:	b289      	uxth	r1, r1
			RxBuff0.ct = cnt;
    1562:	b292      	uxth	r2, r2
					RxBuff0.buff[i++] = d;
					i %= UART0_RXB;
					cnt++;
				}
			}
			RxBuff0.wi = i;
    1564:	8059      	strh	r1, [r3, #2]
			RxBuff0.ct = cnt;
    1566:	809a      	strh	r2, [r3, #4]
			break;
    1568:	e7d7      	b.n	151a <UART0_IRQHandler+0x2>

		case 2:			/* Tx FIFO empty */
			cnt = TxBuff0.ct;
    156a:	4b15      	ldr	r3, [pc, #84]	; (15c0 <UART0_IRQHandler+0xa8>)
    156c:	f8b3 208a 	ldrh.w	r2, [r3, #138]	; 0x8a
    1570:	461c      	mov	r4, r3
    1572:	b292      	uxth	r2, r2
			if (cnt) {		/* There is one or more byte to send */
    1574:	b1c2      	cbz	r2, 15a8 <UART0_IRQHandler+0x90>
				i = TxBuff0.ri;
    1576:	f8b3 1086 	ldrh.w	r1, [r3, #134]	; 0x86
    157a:	2010      	movs	r0, #16
    157c:	b289      	uxth	r1, r1
				for (d = 16; d && cnt; d--, cnt--) {	/* Fill Tx FIFO */
					U0THR = TxBuff0.buff[i++];
    157e:	1865      	adds	r5, r4, r1
    1580:	f895 608e 	ldrb.w	r6, [r5, #142]	; 0x8e

		case 2:			/* Tx FIFO empty */
			cnt = TxBuff0.ct;
			if (cnt) {		/* There is one or more byte to send */
				i = TxBuff0.ri;
				for (d = 16; d && cnt; d--, cnt--) {	/* Fill Tx FIFO */
    1584:	3801      	subs	r0, #1
					U0THR = TxBuff0.buff[i++];
    1586:	4d0f      	ldr	r5, [pc, #60]	; (15c4 <UART0_IRQHandler+0xac>)
    1588:	3101      	adds	r1, #1

		case 2:			/* Tx FIFO empty */
			cnt = TxBuff0.ct;
			if (cnt) {		/* There is one or more byte to send */
				i = TxBuff0.ri;
				for (d = 16; d && cnt; d--, cnt--) {	/* Fill Tx FIFO */
    158a:	b2c0      	uxtb	r0, r0
					U0THR = TxBuff0.buff[i++];
    158c:	602e      	str	r6, [r5, #0]
					i %= UART0_TXB;
    158e:	f001 017f 	and.w	r1, r1, #127	; 0x7f

		case 2:			/* Tx FIFO empty */
			cnt = TxBuff0.ct;
			if (cnt) {		/* There is one or more byte to send */
				i = TxBuff0.ri;
				for (d = 16; d && cnt; d--, cnt--) {	/* Fill Tx FIFO */
    1592:	3a01      	subs	r2, #1
    1594:	b108      	cbz	r0, 159a <UART0_IRQHandler+0x82>
    1596:	2a00      	cmp	r2, #0
    1598:	d1f1      	bne.n	157e <UART0_IRQHandler+0x66>
					U0THR = TxBuff0.buff[i++];
					i %= UART0_TXB;
				}
				TxBuff0.ri = i;
    159a:	b289      	uxth	r1, r1
				TxBuff0.ct = cnt;
    159c:	b292      	uxth	r2, r2
				i = TxBuff0.ri;
				for (d = 16; d && cnt; d--, cnt--) {	/* Fill Tx FIFO */
					U0THR = TxBuff0.buff[i++];
					i %= UART0_TXB;
				}
				TxBuff0.ri = i;
    159e:	f8a3 1086 	strh.w	r1, [r3, #134]	; 0x86
				TxBuff0.ct = cnt;
    15a2:	f8a3 208a 	strh.w	r2, [r3, #138]	; 0x8a
    15a6:	e7b8      	b.n	151a <UART0_IRQHandler+0x2>
			} else {
				TxBuff0.act = 0; /* When no data to send, next putc must trigger Tx sequense */
    15a8:	f8a3 208c 	strh.w	r2, [r3, #140]	; 0x8c
    15ac:	e7b5      	b.n	151a <UART0_IRQHandler+0x2>
			}
			break;

		default:		/* Data error or break detected */
			U0LSR;
    15ae:	4b06      	ldr	r3, [pc, #24]	; (15c8 <UART0_IRQHandler+0xb0>)
    15b0:	681b      	ldr	r3, [r3, #0]
			U0RBR;
    15b2:	4b04      	ldr	r3, [pc, #16]	; (15c4 <UART0_IRQHandler+0xac>)
    15b4:	681b      	ldr	r3, [r3, #0]
    15b6:	e7b0      	b.n	151a <UART0_IRQHandler+0x2>
    15b8:	bd70      	pop	{r4, r5, r6, pc}
    15ba:	bf00      	nop
    15bc:	4000c008 	.word	0x4000c008
    15c0:	10000008 	.word	0x10000008
    15c4:	4000c000 	.word	0x4000c000
    15c8:	4000c014 	.word	0x4000c014

000015cc <uart0_test>:
}


int uart0_test (void)
{
	return RxBuff0.ct;
    15cc:	4b01      	ldr	r3, [pc, #4]	; (15d4 <uart0_test+0x8>)
    15ce:	8898      	ldrh	r0, [r3, #4]
}
    15d0:	b280      	uxth	r0, r0
    15d2:	4770      	bx	lr
    15d4:	10000008 	.word	0x10000008

000015d8 <uart0_getc>:
{
	uint8_t d;
	int i;

	/* Wait while Rx buffer is empty */
	while (!RxBuff0.ct) ;
    15d8:	4b09      	ldr	r3, [pc, #36]	; (1600 <uart0_getc+0x28>)
    15da:	889a      	ldrh	r2, [r3, #4]
    15dc:	b292      	uxth	r2, r2
    15de:	2a00      	cmp	r2, #0
    15e0:	d0fa      	beq.n	15d8 <uart0_getc>

	i = RxBuff0.ri;			/* Get a byte from Rx buffer */
    15e2:	881a      	ldrh	r2, [r3, #0]
    15e4:	b292      	uxth	r2, r2
	d = RxBuff0.buff[i++];
    15e6:	1899      	adds	r1, r3, r2
    15e8:	3201      	adds	r2, #1
	RxBuff0.ri = i % UART0_RXB;
    15ea:	f002 027f 	and.w	r2, r2, #127	; 0x7f

	/* Wait while Rx buffer is empty */
	while (!RxBuff0.ct) ;

	i = RxBuff0.ri;			/* Get a byte from Rx buffer */
	d = RxBuff0.buff[i++];
    15ee:	7988      	ldrb	r0, [r1, #6]
	RxBuff0.ri = i % UART0_RXB;
    15f0:	801a      	strh	r2, [r3, #0]
	__disable_irq();
    15f2:	b672      	cpsid	i
	RxBuff0.ct--;
    15f4:	889a      	ldrh	r2, [r3, #4]
    15f6:	3a01      	subs	r2, #1
    15f8:	b292      	uxth	r2, r2
    15fa:	809a      	strh	r2, [r3, #4]
	__enable_irq();
    15fc:	b662      	cpsie	i

	return d;
}
    15fe:	4770      	bx	lr
    1600:	10000008 	.word	0x10000008

00001604 <uart0_putc>:
void uart0_putc (uint8_t d)
{
	int i;

	/* Wait for Tx buffer ready */
	while (TxBuff0.ct >= UART0_TXB) ;
    1604:	4b11      	ldr	r3, [pc, #68]	; (164c <uart0_putc+0x48>)
    1606:	f8b3 208a 	ldrh.w	r2, [r3, #138]	; 0x8a
    160a:	b292      	uxth	r2, r2
    160c:	2a7f      	cmp	r2, #127	; 0x7f
    160e:	d8f9      	bhi.n	1604 <uart0_putc>

	__disable_irq();
    1610:	b672      	cpsid	i
	if (TxBuff0.act) {
    1612:	f8b3 208c 	ldrh.w	r2, [r3, #140]	; 0x8c
    1616:	b292      	uxth	r2, r2
    1618:	b18a      	cbz	r2, 163e <uart0_putc+0x3a>
		i = TxBuff0.wi;		/* Put a byte into Tx byffer */
    161a:	f8b3 2088 	ldrh.w	r2, [r3, #136]	; 0x88
    161e:	b292      	uxth	r2, r2
		TxBuff0.buff[i++] = d;
    1620:	1899      	adds	r1, r3, r2
    1622:	3201      	adds	r2, #1
		TxBuff0.wi = i % UART0_TXB;
    1624:	f002 027f 	and.w	r2, r2, #127	; 0x7f
	while (TxBuff0.ct >= UART0_TXB) ;

	__disable_irq();
	if (TxBuff0.act) {
		i = TxBuff0.wi;		/* Put a byte into Tx byffer */
		TxBuff0.buff[i++] = d;
    1628:	f881 008e 	strb.w	r0, [r1, #142]	; 0x8e
		TxBuff0.wi = i % UART0_TXB;
    162c:	f8a3 2088 	strh.w	r2, [r3, #136]	; 0x88
		TxBuff0.ct++;
    1630:	f8b3 208a 	ldrh.w	r2, [r3, #138]	; 0x8a
    1634:	3201      	adds	r2, #1
    1636:	b292      	uxth	r2, r2
    1638:	f8a3 208a 	strh.w	r2, [r3, #138]	; 0x8a
    163c:	e004      	b.n	1648 <uart0_putc+0x44>
	} else {
		U0THR = d;		/* Trigger Tx sequense */
    163e:	4a04      	ldr	r2, [pc, #16]	; (1650 <uart0_putc+0x4c>)
    1640:	6010      	str	r0, [r2, #0]
		TxBuff0.act = 1;
    1642:	2201      	movs	r2, #1
    1644:	f8a3 208c 	strh.w	r2, [r3, #140]	; 0x8c
	}
	__enable_irq();
    1648:	b662      	cpsie	i
}
    164a:	4770      	bx	lr
    164c:	10000008 	.word	0x10000008
    1650:	4000c000 	.word	0x4000c000

00001654 <uart0_init>:


void uart0_init (void)
{
	__disable_irqn(UART0_IRQn);
    1654:	4b1f      	ldr	r3, [pc, #124]	; (16d4 <uart0_init+0x80>)
    1656:	2120      	movs	r1, #32
	__enable_irq();
}


void uart0_init (void)
{
    1658:	b530      	push	{r4, r5, lr}
	__disable_irqn(UART0_IRQn);
    165a:	6019      	str	r1, [r3, #0]

	/* Enable UART0 module */
	__set_PCONP(PCUART0, 1);
    165c:	4b1e      	ldr	r3, [pc, #120]	; (16d8 <uart0_init+0x84>)
	__set_PCLKSEL(PCLK_UART0, PCLKDIV);

	/* Initialize UART */
	U0LCR = 0x83;			/* Select baud rate divisor latch */
	U0DLM = DLVAL0 / 256;	/* Set BRG dividers */
	U0DLL = DLVAL0 % 256;
    165e:	4c1f      	ldr	r4, [pc, #124]	; (16dc <uart0_init+0x88>)
void uart0_init (void)
{
	__disable_irqn(UART0_IRQn);

	/* Enable UART0 module */
	__set_PCONP(PCUART0, 1);
    1660:	681a      	ldr	r2, [r3, #0]
	__set_PCLKSEL(PCLK_UART0, PCLKDIV);

	/* Initialize UART */
	U0LCR = 0x83;			/* Select baud rate divisor latch */
	U0DLM = DLVAL0 / 256;	/* Set BRG dividers */
    1662:	481f      	ldr	r0, [pc, #124]	; (16e0 <uart0_init+0x8c>)
void uart0_init (void)
{
	__disable_irqn(UART0_IRQn);

	/* Enable UART0 module */
	__set_PCONP(PCUART0, 1);
    1664:	f042 0208 	orr.w	r2, r2, #8
    1668:	601a      	str	r2, [r3, #0]
	__set_PCLKSEL(PCLK_UART0, PCLKDIV);
    166a:	f8d3 20e4 	ldr.w	r2, [r3, #228]	; 0xe4

	/* Initialize UART */
	U0LCR = 0x83;			/* Select baud rate divisor latch */
	U0DLM = DLVAL0 / 256;	/* Set BRG dividers */
	U0DLL = DLVAL0 % 256;
    166e:	2506      	movs	r5, #6
{
	__disable_irqn(UART0_IRQn);

	/* Enable UART0 module */
	__set_PCONP(PCUART0, 1);
	__set_PCLKSEL(PCLK_UART0, PCLKDIV);
    1670:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
    1674:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4

	/* Initialize UART */
	U0LCR = 0x83;			/* Select baud rate divisor latch */
    1678:	4a1a      	ldr	r2, [pc, #104]	; (16e4 <uart0_init+0x90>)
    167a:	2383      	movs	r3, #131	; 0x83
    167c:	6013      	str	r3, [r2, #0]
	U0DLM = DLVAL0 / 256;	/* Set BRG dividers */
    167e:	3b83      	subs	r3, #131	; 0x83
    1680:	6003      	str	r3, [r0, #0]
	U0DLL = DLVAL0 % 256;
    1682:	6025      	str	r5, [r4, #0]
	U0FDR = (MULVAL << 4) | DIVADD;
    1684:	357b      	adds	r5, #123	; 0x7b
    1686:	62a5      	str	r5, [r4, #40]	; 0x28
	U0LCR = 0x03;			/* Set serial format N81 and deselect divisor latch */
    1688:	2403      	movs	r4, #3
    168a:	6014      	str	r4, [r2, #0]
	U0FCR = 0x87;			/* Enable FIFO */
    168c:	3484      	adds	r4, #132	; 0x84
    168e:	f842 4c04 	str.w	r4, [r2, #-4]
	U0TER = 0x80;			/* Enable Tansmission */
    1692:	3c07      	subs	r4, #7
    1694:	6254      	str	r4, [r2, #36]	; 0x24

	/* Clear Tx/Rx buffers */
	TxBuff0.ri = 0; TxBuff0.wi = 0; TxBuff0.ct = 0; TxBuff0.act = 0;
    1696:	4a14      	ldr	r2, [pc, #80]	; (16e8 <uart0_init+0x94>)
    1698:	f8a2 3086 	strh.w	r3, [r2, #134]	; 0x86
    169c:	f8a2 3088 	strh.w	r3, [r2, #136]	; 0x88
    16a0:	f8a2 308a 	strh.w	r3, [r2, #138]	; 0x8a
    16a4:	f8a2 308c 	strh.w	r3, [r2, #140]	; 0x8c
	RxBuff0.ri = 0; RxBuff0.wi = 0; RxBuff0.ct = 0;
    16a8:	8013      	strh	r3, [r2, #0]
    16aa:	8053      	strh	r3, [r2, #2]
    16ac:	8093      	strh	r3, [r2, #4]

	/* Attach UART0 to I/O pad */
	__set_PINSEL(0, 3, 1);	/* P0.3 - RXD0 */\
    16ae:	4b0f      	ldr	r3, [pc, #60]	; (16ec <uart0_init+0x98>)
    16b0:	681a      	ldr	r2, [r3, #0]
    16b2:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
    16b6:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    16ba:	601a      	str	r2, [r3, #0]
	__set_PINSEL(0, 2, 1);	/* P0.2 - TXD0 */\
    16bc:	681a      	ldr	r2, [r3, #0]
    16be:	f022 0230 	bic.w	r2, r2, #48	; 0x30
    16c2:	f042 0210 	orr.w	r2, r2, #16
    16c6:	601a      	str	r2, [r3, #0]

	/* Enable Tx/Rx/Error interrupts */
	U0IER = 0x07;
    16c8:	2307      	movs	r3, #7
    16ca:	6003      	str	r3, [r0, #0]
	__enable_irqn(UART0_IRQn);
    16cc:	4b08      	ldr	r3, [pc, #32]	; (16f0 <uart0_init+0x9c>)
    16ce:	6019      	str	r1, [r3, #0]
}
    16d0:	bd30      	pop	{r4, r5, pc}
    16d2:	bf00      	nop
    16d4:	e000e180 	.word	0xe000e180
    16d8:	400fc0c4 	.word	0x400fc0c4
    16dc:	4000c000 	.word	0x4000c000
    16e0:	4000c004 	.word	0x4000c004
    16e4:	4000c00c 	.word	0x4000c00c
    16e8:	10000008 	.word	0x10000008
    16ec:	4002c000 	.word	0x4002c000
    16f0:	e000e100 	.word	0xe000e100

000016f4 <rtc_initialize>:


int rtc_initialize (void)
{
	/* Enable PCLK to the RTC */
	__set_PCONP(PCRTC, 1);
    16f4:	4b04      	ldr	r3, [pc, #16]	; (1708 <rtc_initialize+0x14>)

	/* Start RTC with external XTAL */
	RTC_CCR = 0x11;

	return 1;
}
    16f6:	2001      	movs	r0, #1


int rtc_initialize (void)
{
	/* Enable PCLK to the RTC */
	__set_PCONP(PCRTC, 1);
    16f8:	681a      	ldr	r2, [r3, #0]
    16fa:	f442 7200 	orr.w	r2, r2, #512	; 0x200
    16fe:	601a      	str	r2, [r3, #0]

	/* Start RTC with external XTAL */
	RTC_CCR = 0x11;
    1700:	4b02      	ldr	r3, [pc, #8]	; (170c <rtc_initialize+0x18>)
    1702:	2211      	movs	r2, #17
    1704:	601a      	str	r2, [r3, #0]

	return 1;
}
    1706:	4770      	bx	lr
    1708:	400fc0c4 	.word	0x400fc0c4
    170c:	40024008 	.word	0x40024008

00001710 <rtc_gettime>:



int rtc_gettime (RTC *rtc)	/* 1:RTC valid, 0:RTC volatiled */
{
    1710:	b510      	push	{r4, lr}
	uint32_t d, t;


	do {
		t = RTC_CTIME0;
    1712:	4c1c      	ldr	r4, [pc, #112]	; (1784 <rtc_gettime+0x74>)
		d = RTC_CTIME1;
    1714:	491c      	ldr	r1, [pc, #112]	; (1788 <rtc_gettime+0x78>)
{
	uint32_t d, t;


	do {
		t = RTC_CTIME0;
    1716:	6823      	ldr	r3, [r4, #0]
		d = RTC_CTIME1;
    1718:	680a      	ldr	r2, [r1, #0]
	} while (t != RTC_CTIME0 || d != RTC_CTIME1);
    171a:	6824      	ldr	r4, [r4, #0]
    171c:	42a3      	cmp	r3, r4
    171e:	d1f8      	bne.n	1712 <rtc_gettime+0x2>
    1720:	6809      	ldr	r1, [r1, #0]
    1722:	428a      	cmp	r2, r1
    1724:	d1f5      	bne.n	1712 <rtc_gettime+0x2>

	if (RTC_AUX & _BV(4)) {	/* If power fail has been detected, return default time. */
    1726:	4919      	ldr	r1, [pc, #100]	; (178c <rtc_gettime+0x7c>)
    1728:	6809      	ldr	r1, [r1, #0]
    172a:	f011 0f10 	tst.w	r1, #16
    172e:	d00c      	beq.n	174a <rtc_gettime+0x3a>
		rtc->sec = 0; rtc->min = 0; rtc->hour = 0;
		rtc->wday = 0; rtc->mday = 1; rtc->month = 1; rtc->year = 2014;
    1730:	2201      	movs	r2, #1
		t = RTC_CTIME0;
		d = RTC_CTIME1;
	} while (t != RTC_CTIME0 || d != RTC_CTIME1);

	if (RTC_AUX & _BV(4)) {	/* If power fail has been detected, return default time. */
		rtc->sec = 0; rtc->min = 0; rtc->hour = 0;
    1732:	2300      	movs	r3, #0
		rtc->wday = 0; rtc->mday = 1; rtc->month = 1; rtc->year = 2014;
    1734:	70c2      	strb	r2, [r0, #3]
    1736:	7082      	strb	r2, [r0, #2]
    1738:	f240 72de 	movw	r2, #2014	; 0x7de
		t = RTC_CTIME0;
		d = RTC_CTIME1;
	} while (t != RTC_CTIME0 || d != RTC_CTIME1);

	if (RTC_AUX & _BV(4)) {	/* If power fail has been detected, return default time. */
		rtc->sec = 0; rtc->min = 0; rtc->hour = 0;
    173c:	71c3      	strb	r3, [r0, #7]
    173e:	7183      	strb	r3, [r0, #6]
    1740:	7143      	strb	r3, [r0, #5]
		rtc->wday = 0; rtc->mday = 1; rtc->month = 1; rtc->year = 2014;
    1742:	7103      	strb	r3, [r0, #4]
    1744:	8002      	strh	r2, [r0, #0]
		return 0;
    1746:	4618      	mov	r0, r3
    1748:	bd10      	pop	{r4, pc}
	}

	rtc->sec = t & 63;
    174a:	f003 013f 	and.w	r1, r3, #63	; 0x3f
    174e:	71c1      	strb	r1, [r0, #7]
	rtc->min = (t >> 8) & 63;
    1750:	0a19      	lsrs	r1, r3, #8
    1752:	f001 013f 	and.w	r1, r1, #63	; 0x3f
    1756:	7181      	strb	r1, [r0, #6]
	rtc->hour = (t >> 16) & 31;
    1758:	0c19      	lsrs	r1, r3, #16
	rtc->wday = (t >> 24) & 7;
    175a:	0e1b      	lsrs	r3, r3, #24
    175c:	f003 0307 	and.w	r3, r3, #7
    1760:	7103      	strb	r3, [r0, #4]
	rtc->mday = d & 31;
    1762:	f002 031f 	and.w	r3, r2, #31
    1766:	70c3      	strb	r3, [r0, #3]
	rtc->month = (d >> 8) & 15;
    1768:	0a13      	lsrs	r3, r2, #8
	rtc->year = (d >> 16) & 4095;
    176a:	0c12      	lsrs	r2, r2, #16
    176c:	0512      	lsls	r2, r2, #20
		return 0;
	}

	rtc->sec = t & 63;
	rtc->min = (t >> 8) & 63;
	rtc->hour = (t >> 16) & 31;
    176e:	f001 011f 	and.w	r1, r1, #31
	rtc->wday = (t >> 24) & 7;
	rtc->mday = d & 31;
	rtc->month = (d >> 8) & 15;
    1772:	f003 030f 	and.w	r3, r3, #15
	rtc->year = (d >> 16) & 4095;
    1776:	0d12      	lsrs	r2, r2, #20
		return 0;
	}

	rtc->sec = t & 63;
	rtc->min = (t >> 8) & 63;
	rtc->hour = (t >> 16) & 31;
    1778:	7141      	strb	r1, [r0, #5]
	rtc->wday = (t >> 24) & 7;
	rtc->mday = d & 31;
	rtc->month = (d >> 8) & 15;
    177a:	7083      	strb	r3, [r0, #2]
	rtc->year = (d >> 16) & 4095;
    177c:	8002      	strh	r2, [r0, #0]
	return 1;
    177e:	2001      	movs	r0, #1
}
    1780:	bd10      	pop	{r4, pc}
    1782:	bf00      	nop
    1784:	40024014 	.word	0x40024014
    1788:	40024018 	.word	0x40024018
    178c:	4002405c 	.word	0x4002405c

00001790 <rtc_settime>:



int rtc_settime (const RTC *rtc)
{
	RTC_CCR = 0x12;		/* Stop RTC */
    1790:	4b0b      	ldr	r3, [pc, #44]	; (17c0 <rtc_settime+0x30>)
    1792:	2212      	movs	r2, #18
    1794:	601a      	str	r2, [r3, #0]

	/* Update RTC registers */
	RTC_SEC = rtc->sec;
    1796:	79c1      	ldrb	r1, [r0, #7]
    1798:	4a0a      	ldr	r2, [pc, #40]	; (17c4 <rtc_settime+0x34>)
    179a:	6011      	str	r1, [r2, #0]
	RTC_MIN = rtc->min;
    179c:	7981      	ldrb	r1, [r0, #6]
    179e:	6051      	str	r1, [r2, #4]
	RTC_HOUR = rtc->hour;
    17a0:	7941      	ldrb	r1, [r0, #5]
    17a2:	6091      	str	r1, [r2, #8]
	RTC_DOW = rtc->wday;
    17a4:	7901      	ldrb	r1, [r0, #4]
    17a6:	6111      	str	r1, [r2, #16]
	RTC_DOM = rtc->mday;
    17a8:	78c1      	ldrb	r1, [r0, #3]
    17aa:	60d1      	str	r1, [r2, #12]
	RTC_MONTH = rtc->month;
    17ac:	7881      	ldrb	r1, [r0, #2]
    17ae:	6191      	str	r1, [r2, #24]
	RTC_YEAR = rtc->year;
    17b0:	8801      	ldrh	r1, [r0, #0]

	RTC_AUX = _BV(4);	/* Clear power fail flag */
	RTC_CCR = 0x11;		/* Restart RTC, Disable calibration feature */

	return 1;
}
    17b2:	2001      	movs	r0, #1
	RTC_MIN = rtc->min;
	RTC_HOUR = rtc->hour;
	RTC_DOW = rtc->wday;
	RTC_DOM = rtc->mday;
	RTC_MONTH = rtc->month;
	RTC_YEAR = rtc->year;
    17b4:	61d1      	str	r1, [r2, #28]

	RTC_AUX = _BV(4);	/* Clear power fail flag */
    17b6:	2110      	movs	r1, #16
    17b8:	63d1      	str	r1, [r2, #60]	; 0x3c
	RTC_CCR = 0x11;		/* Restart RTC, Disable calibration feature */
    17ba:	2211      	movs	r2, #17
    17bc:	601a      	str	r2, [r3, #0]

	return 1;
}
    17be:	4770      	bx	lr
    17c0:	40024008 	.word	0x40024008
    17c4:	40024020 	.word	0x40024020

000017c8 <TIMER3_IRQHandler>:
/*-----------------------------------------------------*/
/* Sound sampling ISR                                  */

void TIMER3_IRQHandler (void)
{
	WAVFIFO *fcb = WavFifo;	/* Pointer to FIFO controls */
    17c8:	4b30      	ldr	r3, [pc, #192]	; (188c <TIMER3_IRQHandler+0xc4>)

/*-----------------------------------------------------*/
/* Sound sampling ISR                                  */

void TIMER3_IRQHandler (void)
{
    17ca:	b530      	push	{r4, r5, lr}
	WAVFIFO *fcb = WavFifo;	/* Pointer to FIFO controls */
    17cc:	681a      	ldr	r2, [r3, #0]
	uint32_t ri, ct;
	uint8_t *buff;
	uint32_t a1, a2;


	T3IR = T3IR;	/* Clear MR0 match irq flag */
    17ce:	4b30      	ldr	r3, [pc, #192]	; (1890 <TIMER3_IRQHandler+0xc8>)
    17d0:	6819      	ldr	r1, [r3, #0]
    17d2:	6019      	str	r1, [r3, #0]

	if (!fcb) return;
    17d4:	2a00      	cmp	r2, #0
    17d6:	d058      	beq.n	188a <TIMER3_IRQHandler+0xc2>
	buff = fcb->buff;
	ct = fcb->ct; ri = fcb->ri;

	switch (fcb->mode) {
    17d8:	6810      	ldr	r0, [r2, #0]

	T3IR = T3IR;	/* Clear MR0 match irq flag */

	if (!fcb) return;
	buff = fcb->buff;
	ct = fcb->ct; ri = fcb->ri;
    17da:	68d1      	ldr	r1, [r2, #12]

	switch (fcb->mode) {
    17dc:	2801      	cmp	r0, #1


	T3IR = T3IR;	/* Clear MR0 match irq flag */

	if (!fcb) return;
	buff = fcb->buff;
    17de:	6914      	ldr	r4, [r2, #16]
	ct = fcb->ct; ri = fcb->ri;
    17e0:	6853      	ldr	r3, [r2, #4]

	switch (fcb->mode) {
    17e2:	d00a      	beq.n	17fa <TIMER3_IRQHandler+0x32>
    17e4:	d302      	bcc.n	17ec <TIMER3_IRQHandler+0x24>
    17e6:	2802      	cmp	r0, #2
    17e8:	d11a      	bne.n	1820 <TIMER3_IRQHandler+0x58>
    17ea:	e010      	b.n	180e <TIMER3_IRQHandler+0x46>
	case 0:		/* Mono, 8bit */
		if (ct < 1) return;
    17ec:	2900      	cmp	r1, #0
    17ee:	d04c      	beq.n	188a <TIMER3_IRQHandler+0xc2>
		a1 = a2 = buff[ri] << 8;
    17f0:	5ce0      	ldrb	r0, [r4, r3]
		ct -= 1; ri += 1;
    17f2:	3901      	subs	r1, #1
	ct = fcb->ct; ri = fcb->ri;

	switch (fcb->mode) {
	case 0:		/* Mono, 8bit */
		if (ct < 1) return;
		a1 = a2 = buff[ri] << 8;
    17f4:	0200      	lsls	r0, r0, #8
		ct -= 1; ri += 1;
    17f6:	3301      	adds	r3, #1
    17f8:	e010      	b.n	181c <TIMER3_IRQHandler+0x54>
		break;
	case 1:		/* Stereo, 8bit */
		if (ct < 2) return;
    17fa:	2901      	cmp	r1, #1
    17fc:	d945      	bls.n	188a <TIMER3_IRQHandler+0xc2>
		a1 = buff[ri] << 8;
    17fe:	5ce5      	ldrb	r5, [r4, r3]
		a2 = buff[ri + 1] << 8;
    1800:	18e4      	adds	r4, r4, r3
    1802:	7860      	ldrb	r0, [r4, #1]
		a1 = a2 = buff[ri] << 8;
		ct -= 1; ri += 1;
		break;
	case 1:		/* Stereo, 8bit */
		if (ct < 2) return;
		a1 = buff[ri] << 8;
    1804:	022d      	lsls	r5, r5, #8
		a2 = buff[ri + 1] << 8;
    1806:	0200      	lsls	r0, r0, #8
		ct -= 2; ri += 2;
    1808:	3902      	subs	r1, #2
    180a:	3302      	adds	r3, #2
		break;
    180c:	e015      	b.n	183a <TIMER3_IRQHandler+0x72>
	case 2:		/* Mono, 16bit */
		if (ct < 2) return;
    180e:	2901      	cmp	r1, #1
    1810:	d93b      	bls.n	188a <TIMER3_IRQHandler+0xc2>
		a1 = a2 = LD_WORD(buff+ri) ^ 0x8000;
    1812:	5ae0      	ldrh	r0, [r4, r3]
		ct -= 2; ri += 2;
    1814:	3902      	subs	r1, #2
		a2 = buff[ri + 1] << 8;
		ct -= 2; ri += 2;
		break;
	case 2:		/* Mono, 16bit */
		if (ct < 2) return;
		a1 = a2 = LD_WORD(buff+ri) ^ 0x8000;
    1816:	f480 4000 	eor.w	r0, r0, #32768	; 0x8000
		ct -= 2; ri += 2;
    181a:	3302      	adds	r3, #2
		a2 = buff[ri + 1] << 8;
		ct -= 2; ri += 2;
		break;
	case 2:		/* Mono, 16bit */
		if (ct < 2) return;
		a1 = a2 = LD_WORD(buff+ri) ^ 0x8000;
    181c:	4605      	mov	r5, r0
		ct -= 2; ri += 2;
		break;
    181e:	e00c      	b.n	183a <TIMER3_IRQHandler+0x72>
	default:	/* Stereo, 16bit */
		if (ct < 4) return;
    1820:	2903      	cmp	r1, #3
    1822:	d932      	bls.n	188a <TIMER3_IRQHandler+0xc2>
		a1 = LD_WORD(buff+ri) ^ 0x8000;;
    1824:	5ae5      	ldrh	r5, [r4, r3]
		a2 = LD_WORD(buff+ri+2) ^ 0x8000;;
    1826:	18e4      	adds	r4, r4, r3
		a1 = a2 = LD_WORD(buff+ri) ^ 0x8000;
		ct -= 2; ri += 2;
		break;
	default:	/* Stereo, 16bit */
		if (ct < 4) return;
		a1 = LD_WORD(buff+ri) ^ 0x8000;;
    1828:	481a      	ldr	r0, [pc, #104]	; (1894 <TIMER3_IRQHandler+0xcc>)
		a2 = LD_WORD(buff+ri+2) ^ 0x8000;;
    182a:	8864      	ldrh	r4, [r4, #2]
		a1 = a2 = LD_WORD(buff+ri) ^ 0x8000;
		ct -= 2; ri += 2;
		break;
	default:	/* Stereo, 16bit */
		if (ct < 4) return;
		a1 = LD_WORD(buff+ri) ^ 0x8000;;
    182c:	4045      	eors	r5, r0
		a2 = LD_WORD(buff+ri+2) ^ 0x8000;;
    182e:	ea84 0000 	eor.w	r0, r4, r0
		a1 = a2 = LD_WORD(buff+ri) ^ 0x8000;
		ct -= 2; ri += 2;
		break;
	default:	/* Stereo, 16bit */
		if (ct < 4) return;
		a1 = LD_WORD(buff+ri) ^ 0x8000;;
    1832:	b2ad      	uxth	r5, r5
		a2 = LD_WORD(buff+ri+2) ^ 0x8000;;
    1834:	b280      	uxth	r0, r0
		ct -= 4; ri += 4;
    1836:	3904      	subs	r1, #4
    1838:	3304      	adds	r3, #4
	}
	fcb->ct = ct;
    183a:	60d1      	str	r1, [r2, #12]
	fcb->ri = ri & (fcb->sz_buff - 1);
    183c:	6951      	ldr	r1, [r2, #20]

	/* a1:L-ch, a2:R-ch */
	a1 >>= 7; a2 >>= 7;
    183e:	09c0      	lsrs	r0, r0, #7
		a1 = LD_WORD(buff+ri) ^ 0x8000;;
		a2 = LD_WORD(buff+ri+2) ^ 0x8000;;
		ct -= 4; ri += 4;
	}
	fcb->ct = ct;
	fcb->ri = ri & (fcb->sz_buff - 1);
    1840:	3901      	subs	r1, #1
    1842:	400b      	ands	r3, r1
    1844:	6053      	str	r3, [r2, #4]

	/* a1:L-ch, a2:R-ch */
	a1 >>= 7; a2 >>= 7;
	if (a1 == 511) a1 = 510;
    1846:	f240 12ff 	movw	r2, #511	; 0x1ff
	}
	fcb->ct = ct;
	fcb->ri = ri & (fcb->sz_buff - 1);

	/* a1:L-ch, a2:R-ch */
	a1 >>= 7; a2 >>= 7;
    184a:	09eb      	lsrs	r3, r5, #7
	if (a1 == 511) a1 = 510;
    184c:	4293      	cmp	r3, r2
    184e:	bf08      	it	eq
    1850:	f44f 73ff 	moveq.w	r3, #510	; 0x1fe
	if (a2 == 511) a2 = 510;
	PWM1MR1 = a1 >> 1;
    1854:	4910      	ldr	r1, [pc, #64]	; (1898 <TIMER3_IRQHandler+0xd0>)
	fcb->ri = ri & (fcb->sz_buff - 1);

	/* a1:L-ch, a2:R-ch */
	a1 >>= 7; a2 >>= 7;
	if (a1 == 511) a1 = 510;
	if (a2 == 511) a2 = 510;
    1856:	4290      	cmp	r0, r2
    1858:	bf08      	it	eq
    185a:	f44f 70ff 	moveq.w	r0, #510	; 0x1fe
	PWM1MR1 = a1 >> 1;
    185e:	085a      	lsrs	r2, r3, #1
    1860:	600a      	str	r2, [r1, #0]
	PWM1MR2 = (~(a1 >> 1) - (a1 & 1)) & 0xFF;
    1862:	f003 0301 	and.w	r3, r3, #1
    1866:	43d2      	mvns	r2, r2
    1868:	1ad3      	subs	r3, r2, r3
    186a:	f003 03ff 	and.w	r3, r3, #255	; 0xff
	PWM1MR3 = a2 >> 1;
    186e:	4a0b      	ldr	r2, [pc, #44]	; (189c <TIMER3_IRQHandler+0xd4>)
	/* a1:L-ch, a2:R-ch */
	a1 >>= 7; a2 >>= 7;
	if (a1 == 511) a1 = 510;
	if (a2 == 511) a2 = 510;
	PWM1MR1 = a1 >> 1;
	PWM1MR2 = (~(a1 >> 1) - (a1 & 1)) & 0xFF;
    1870:	604b      	str	r3, [r1, #4]
	PWM1MR3 = a2 >> 1;
    1872:	0843      	lsrs	r3, r0, #1
    1874:	6013      	str	r3, [r2, #0]
	PWM1MR4 = (~(a2 >> 1) - (a2 & 1)) & 0xFF;
    1876:	f000 0001 	and.w	r0, r0, #1
    187a:	43db      	mvns	r3, r3
    187c:	1a18      	subs	r0, r3, r0
    187e:	f000 00ff 	and.w	r0, r0, #255	; 0xff
	PWM1LER = 0x1F;
    1882:	4b07      	ldr	r3, [pc, #28]	; (18a0 <TIMER3_IRQHandler+0xd8>)
	if (a1 == 511) a1 = 510;
	if (a2 == 511) a2 = 510;
	PWM1MR1 = a1 >> 1;
	PWM1MR2 = (~(a1 >> 1) - (a1 & 1)) & 0xFF;
	PWM1MR3 = a2 >> 1;
	PWM1MR4 = (~(a2 >> 1) - (a2 & 1)) & 0xFF;
    1884:	61d0      	str	r0, [r2, #28]
	PWM1LER = 0x1F;
    1886:	221f      	movs	r2, #31
    1888:	601a      	str	r2, [r3, #0]
    188a:	bd30      	pop	{r4, r5, pc}
    188c:	10000118 	.word	0x10000118
    1890:	40094000 	.word	0x40094000
    1894:	ffff8000 	.word	0xffff8000
    1898:	4001801c 	.word	0x4001801c
    189c:	40018024 	.word	0x40018024
    18a0:	40018050 	.word	0x40018050

000018a4 <sound_start>:
int sound_start (
	WAVFIFO* fcb,	/* Pointer to the sound FIFO control structure */
	uint32_t fs		/* Sampling frequency [Hz] (8000-48000) */
)
{
	if (fs < 8000 || fs > 48000) return 0;	/* Check fs range */
    18a4:	f5a1 52fa 	sub.w	r2, r1, #8000	; 0x1f40
    18a8:	f649 4340 	movw	r3, #40000	; 0x9c40
    18ac:	429a      	cmp	r2, r3

int sound_start (
	WAVFIFO* fcb,	/* Pointer to the sound FIFO control structure */
	uint32_t fs		/* Sampling frequency [Hz] (8000-48000) */
)
{
    18ae:	b570      	push	{r4, r5, r6, lr}
    18b0:	f04f 0200 	mov.w	r2, #0
	if (fs < 8000 || fs > 48000) return 0;	/* Check fs range */
    18b4:	d858      	bhi.n	1968 <sound_start+0xc4>

	fcb->ri = 0; fcb->wi = 0; fcb->ct = 0;	/* Flush FIFO */
	WavFifo = fcb;			/* Register FIFO control structure */
    18b6:	4b2d      	ldr	r3, [pc, #180]	; (196c <sound_start+0xc8>)
	uint32_t fs		/* Sampling frequency [Hz] (8000-48000) */
)
{
	if (fs < 8000 || fs > 48000) return 0;	/* Check fs range */

	fcb->ri = 0; fcb->wi = 0; fcb->ct = 0;	/* Flush FIFO */
    18b8:	6042      	str	r2, [r0, #4]
	WavFifo = fcb;			/* Register FIFO control structure */
    18ba:	6018      	str	r0, [r3, #0]
	uint32_t fs		/* Sampling frequency [Hz] (8000-48000) */
)
{
	if (fs < 8000 || fs > 48000) return 0;	/* Check fs range */

	fcb->ri = 0; fcb->wi = 0; fcb->ct = 0;	/* Flush FIFO */
    18bc:	6082      	str	r2, [r0, #8]
    18be:	60c2      	str	r2, [r0, #12]
	WavFifo = fcb;			/* Register FIFO control structure */

	/* Configure PWM1 as audio outputs */
	__set_PCONP(PCPWM1, 1);		/* Enable PWM1 module */
    18c0:	482b      	ldr	r0, [pc, #172]	; (1970 <sound_start+0xcc>)
	__set_PCLKSEL(PCLK_PWM1, PCLKDIV_PWM1);
	PWM1TCR = _BV(1);
    18c2:	4d2c      	ldr	r5, [pc, #176]	; (1974 <sound_start+0xd0>)

	fcb->ri = 0; fcb->wi = 0; fcb->ct = 0;	/* Flush FIFO */
	WavFifo = fcb;			/* Register FIFO control structure */

	/* Configure PWM1 as audio outputs */
	__set_PCONP(PCPWM1, 1);		/* Enable PWM1 module */
    18c4:	6803      	ldr	r3, [r0, #0]
	__set_PCLKSEL(PCLK_PWM1, PCLKDIV_PWM1);
	PWM1TCR = _BV(1);
	PWM1MCR = _BV(1);
	PWM1MR0 = 256 - 1;
    18c6:	26ff      	movs	r6, #255	; 0xff

	fcb->ri = 0; fcb->wi = 0; fcb->ct = 0;	/* Flush FIFO */
	WavFifo = fcb;			/* Register FIFO control structure */

	/* Configure PWM1 as audio outputs */
	__set_PCONP(PCPWM1, 1);		/* Enable PWM1 module */
    18c8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    18cc:	6003      	str	r3, [r0, #0]
	__set_PCLKSEL(PCLK_PWM1, PCLKDIV_PWM1);
    18ce:	4b2a      	ldr	r3, [pc, #168]	; (1978 <sound_start+0xd4>)
    18d0:	681c      	ldr	r4, [r3, #0]
    18d2:	f424 5440 	bic.w	r4, r4, #12288	; 0x3000
    18d6:	f444 5480 	orr.w	r4, r4, #4096	; 0x1000
    18da:	601c      	str	r4, [r3, #0]
	PWM1TCR = _BV(1);
	PWM1MCR = _BV(1);
    18dc:	4b27      	ldr	r3, [pc, #156]	; (197c <sound_start+0xd8>)
	WavFifo = fcb;			/* Register FIFO control structure */

	/* Configure PWM1 as audio outputs */
	__set_PCONP(PCPWM1, 1);		/* Enable PWM1 module */
	__set_PCLKSEL(PCLK_PWM1, PCLKDIV_PWM1);
	PWM1TCR = _BV(1);
    18de:	2402      	movs	r4, #2
    18e0:	602c      	str	r4, [r5, #0]
	PWM1MCR = _BV(1);
    18e2:	601c      	str	r4, [r3, #0]
	PWM1MR0 = 256 - 1;
    18e4:	605e      	str	r6, [r3, #4]
	PWM1MR1 = 128;
    18e6:	4e26      	ldr	r6, [pc, #152]	; (1980 <sound_start+0xdc>)
    18e8:	2380      	movs	r3, #128	; 0x80
    18ea:	6033      	str	r3, [r6, #0]
	PWM1MR2 = 128;
    18ec:	6073      	str	r3, [r6, #4]
	PWM1MR3 = 128;
    18ee:	60b3      	str	r3, [r6, #8]
	PWM1MR4 = 128;
    18f0:	6273      	str	r3, [r6, #36]	; 0x24
	PWM1PCR = _BV(12)|_BV(11)|_BV(10)|_BV(9);
    18f2:	4b24      	ldr	r3, [pc, #144]	; (1984 <sound_start+0xe0>)
    18f4:	f44f 56f0 	mov.w	r6, #7680	; 0x1e00
    18f8:	601e      	str	r6, [r3, #0]
	PWM1TCR = _BV(3)|_BV(0);
    18fa:	2309      	movs	r3, #9
    18fc:	602b      	str	r3, [r5, #0]
	__set_PINSEL(2, 0, 1);
    18fe:	4b22      	ldr	r3, [pc, #136]	; (1988 <sound_start+0xe4>)
    1900:	681d      	ldr	r5, [r3, #0]
    1902:	f025 0503 	bic.w	r5, r5, #3
    1906:	f045 0501 	orr.w	r5, r5, #1
    190a:	601d      	str	r5, [r3, #0]
	__set_PINSEL(2, 1, 1);
    190c:	681d      	ldr	r5, [r3, #0]
    190e:	f025 050c 	bic.w	r5, r5, #12
    1912:	f045 0504 	orr.w	r5, r5, #4
    1916:	601d      	str	r5, [r3, #0]
	__set_PINSEL(2, 2, 1);
    1918:	681d      	ldr	r5, [r3, #0]
    191a:	f025 0530 	bic.w	r5, r5, #48	; 0x30
    191e:	f045 0510 	orr.w	r5, r5, #16
    1922:	601d      	str	r5, [r3, #0]
	__set_PINSEL(2, 3, 1);
    1924:	681d      	ldr	r5, [r3, #0]
    1926:	f025 05c0 	bic.w	r5, r5, #192	; 0xc0
    192a:	f045 0540 	orr.w	r5, r5, #64	; 0x40
    192e:	601d      	str	r5, [r3, #0]

	/* Configure TIMER3 as sampling interval timer */
	__set_PCONP(PCTIM3, 1);		/* Enable TIMER3 module */
    1930:	6803      	ldr	r3, [r0, #0]
    1932:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
    1936:	6003      	str	r3, [r0, #0]
	__set_PCLKSEL(PCLK_TIMER3, PCLKDIV_T3);
    1938:	4b14      	ldr	r3, [pc, #80]	; (198c <sound_start+0xe8>)
    193a:	6818      	ldr	r0, [r3, #0]
    193c:	f420 4040 	bic.w	r0, r0, #49152	; 0xc000
    1940:	6018      	str	r0, [r3, #0]
	T3TCR = _BV(1);
	T3MR0 = F_PCLK_T3 / fs - 1;
    1942:	4813      	ldr	r0, [pc, #76]	; (1990 <sound_start+0xec>)
	__set_PINSEL(2, 3, 1);

	/* Configure TIMER3 as sampling interval timer */
	__set_PCONP(PCTIM3, 1);		/* Enable TIMER3 module */
	__set_PCLKSEL(PCLK_TIMER3, PCLKDIV_T3);
	T3TCR = _BV(1);
    1944:	4b13      	ldr	r3, [pc, #76]	; (1994 <sound_start+0xf0>)
	T3MR0 = F_PCLK_T3 / fs - 1;
    1946:	fbb0 f1f1 	udiv	r1, r0, r1
    194a:	4813      	ldr	r0, [pc, #76]	; (1998 <sound_start+0xf4>)
    194c:	3901      	subs	r1, #1
	__set_PINSEL(2, 3, 1);

	/* Configure TIMER3 as sampling interval timer */
	__set_PCONP(PCTIM3, 1);		/* Enable TIMER3 module */
	__set_PCLKSEL(PCLK_TIMER3, PCLKDIV_T3);
	T3TCR = _BV(1);
    194e:	601c      	str	r4, [r3, #0]
	T3MR0 = F_PCLK_T3 / fs - 1;
    1950:	6001      	str	r1, [r0, #0]
	T3MCR = _BV(1)|_BV(0);
    1952:	4912      	ldr	r1, [pc, #72]	; (199c <sound_start+0xf8>)
    1954:	2003      	movs	r0, #3
    1956:	6008      	str	r0, [r1, #0]
	T3TCR = _BV(0);
    1958:	3802      	subs	r0, #2
    195a:	6018      	str	r0, [r3, #0]
	__enable_irqn(TIMER3_IRQn);	/* Enable interrupt */
    195c:	4b10      	ldr	r3, [pc, #64]	; (19a0 <sound_start+0xfc>)
    195e:	2110      	movs	r1, #16
    1960:	6019      	str	r1, [r3, #0]
	__set_irqn_priority(TIMER3_IRQn, 0);	/* Set interrupt priority, highest */
    1962:	4b10      	ldr	r3, [pc, #64]	; (19a4 <sound_start+0x100>)
    1964:	701a      	strb	r2, [r3, #0]

	return 1;
    1966:	bd70      	pop	{r4, r5, r6, pc}
int sound_start (
	WAVFIFO* fcb,	/* Pointer to the sound FIFO control structure */
	uint32_t fs		/* Sampling frequency [Hz] (8000-48000) */
)
{
	if (fs < 8000 || fs > 48000) return 0;	/* Check fs range */
    1968:	4610      	mov	r0, r2
	T3TCR = _BV(0);
	__enable_irqn(TIMER3_IRQn);	/* Enable interrupt */
	__set_irqn_priority(TIMER3_IRQn, 0);	/* Set interrupt priority, highest */

	return 1;
}
    196a:	bd70      	pop	{r4, r5, r6, pc}
    196c:	10000118 	.word	0x10000118
    1970:	400fc0c4 	.word	0x400fc0c4
    1974:	40018004 	.word	0x40018004
    1978:	400fc1a8 	.word	0x400fc1a8
    197c:	40018014 	.word	0x40018014
    1980:	4001801c 	.word	0x4001801c
    1984:	4001804c 	.word	0x4001804c
    1988:	4002c010 	.word	0x4002c010
    198c:	400fc1ac 	.word	0x400fc1ac
    1990:	017d7840 	.word	0x017d7840
    1994:	40094004 	.word	0x40094004
    1998:	40094018 	.word	0x40094018
    199c:	40094014 	.word	0x40094014
    19a0:	e000e100 	.word	0xe000e100
    19a4:	e000e404 	.word	0xe000e404

000019a8 <sound_stop>:
/*-----------------------------------------------------*/
/* Disable sound output                                */

void sound_stop (void)
{
	PWM1TCR = 0;				/* Stop PWM1 module */
    19a8:	4b12      	ldr	r3, [pc, #72]	; (19f4 <sound_stop+0x4c>)
	__set_PCONP(PCPWM1, 0);		/* Disable PWM1 module */
    19aa:	4a13      	ldr	r2, [pc, #76]	; (19f8 <sound_stop+0x50>)
/*-----------------------------------------------------*/
/* Disable sound output                                */

void sound_stop (void)
{
	PWM1TCR = 0;				/* Stop PWM1 module */
    19ac:	2100      	movs	r1, #0
    19ae:	6019      	str	r1, [r3, #0]
	__set_PCONP(PCPWM1, 0);		/* Disable PWM1 module */
    19b0:	6813      	ldr	r3, [r2, #0]
    19b2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    19b6:	6013      	str	r3, [r2, #0]
	__set_PINSEL(2, 0, 0);
    19b8:	4b10      	ldr	r3, [pc, #64]	; (19fc <sound_stop+0x54>)
    19ba:	6818      	ldr	r0, [r3, #0]
    19bc:	f020 0003 	bic.w	r0, r0, #3
    19c0:	6018      	str	r0, [r3, #0]
	__set_PINSEL(2, 1, 0);
    19c2:	6818      	ldr	r0, [r3, #0]
    19c4:	f020 000c 	bic.w	r0, r0, #12
    19c8:	6018      	str	r0, [r3, #0]
	__set_PINSEL(2, 2, 0);
    19ca:	6818      	ldr	r0, [r3, #0]
    19cc:	f020 0030 	bic.w	r0, r0, #48	; 0x30
    19d0:	6018      	str	r0, [r3, #0]
	__set_PINSEL(2, 3, 0);
    19d2:	6818      	ldr	r0, [r3, #0]
    19d4:	f020 00c0 	bic.w	r0, r0, #192	; 0xc0
    19d8:	6018      	str	r0, [r3, #0]

	T3TCR = 0;					/* Stop sampling interrupt (TIMER3) */
    19da:	4b09      	ldr	r3, [pc, #36]	; (1a00 <sound_stop+0x58>)
	__disable_irqn(TIMER3_IRQn);
    19dc:	2010      	movs	r0, #16
	__set_PINSEL(2, 0, 0);
	__set_PINSEL(2, 1, 0);
	__set_PINSEL(2, 2, 0);
	__set_PINSEL(2, 3, 0);

	T3TCR = 0;					/* Stop sampling interrupt (TIMER3) */
    19de:	6019      	str	r1, [r3, #0]
	__disable_irqn(TIMER3_IRQn);
    19e0:	4b08      	ldr	r3, [pc, #32]	; (1a04 <sound_stop+0x5c>)
    19e2:	6018      	str	r0, [r3, #0]
	__set_PCONP(PCTIM3, 0);		/* Disable TIMER3 module */
    19e4:	6813      	ldr	r3, [r2, #0]
    19e6:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
    19ea:	6013      	str	r3, [r2, #0]

	WavFifo = 0;		/* Unregister FIFO control structure */
    19ec:	4b06      	ldr	r3, [pc, #24]	; (1a08 <sound_stop+0x60>)
    19ee:	6019      	str	r1, [r3, #0]
}
    19f0:	4770      	bx	lr
    19f2:	bf00      	nop
    19f4:	40018004 	.word	0x40018004
    19f8:	400fc0c4 	.word	0x400fc0c4
    19fc:	4002c010 	.word	0x4002c010
    1a00:	40094004 	.word	0x40094004
    1a04:	e000e180 	.word	0xe000e180
    1a08:	10000118 	.word	0x10000118

00001a0c <load_wav>:
	FIL *fp,			/* Pointer to the open file object to play */
	const char *title,	/* Title (file name, etc...) */
	void *work,			/* Pointer to working buffer (must be-4 byte aligned) */
	DWORD sz_work		/* Size of working buffer (must be power of 2) */
)
{
    1a0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1a10:	4615      	mov	r5, r2
    1a12:	b0b1      	sub	sp, #196	; 0xc4
    1a14:	4604      	mov	r4, r0
	WAVFIFO fcb;
	BYTE k, *buff = work;
	char *p, nam[NBSIZE], art[NBSIZE];


	xprintf("**** %s ****\n", title);	/* Put title */
    1a16:	489a      	ldr	r0, [pc, #616]	; (1c80 <load_wav+0x274>)
	FIL *fp,			/* Pointer to the open file object to play */
	const char *title,	/* Title (file name, etc...) */
	void *work,			/* Pointer to working buffer (must be-4 byte aligned) */
	DWORD sz_work		/* Size of working buffer (must be power of 2) */
)
{
    1a18:	9306      	str	r3, [sp, #24]
	WAVFIFO fcb;
	BYTE k, *buff = work;
	char *p, nam[NBSIZE], art[NBSIZE];


	xprintf("**** %s ****\n", title);	/* Put title */
    1a1a:	f000 faaf 	bl	1f7c <xprintf>

	/* Is it a WAV file? */
	if (f_read(fp, buff, 12, &br) || br != 12) return -1;
    1a1e:	4620      	mov	r0, r4
    1a20:	4629      	mov	r1, r5
    1a22:	220c      	movs	r2, #12
    1a24:	ab2f      	add	r3, sp, #188	; 0xbc
    1a26:	f002 f81b 	bl	3a60 <f_read>
    1a2a:	2800      	cmp	r0, #0
    1a2c:	f040 818b 	bne.w	1d46 <load_wav+0x33a>
    1a30:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
    1a32:	2b0c      	cmp	r3, #12
    1a34:	f040 8187 	bne.w	1d46 <load_wav+0x33a>
	if (LD_DWORD(&buff[0]) != FCC('R','I','F','F')) return -1;
    1a38:	682a      	ldr	r2, [r5, #0]
    1a3a:	4b92      	ldr	r3, [pc, #584]	; (1c84 <load_wav+0x278>)
    1a3c:	429a      	cmp	r2, r3
    1a3e:	f040 8182 	bne.w	1d46 <load_wav+0x33a>
	if (LD_DWORD(&buff[8]) != FCC('W','A','V','E')) return -1;
    1a42:	68aa      	ldr	r2, [r5, #8]
    1a44:	4b90      	ldr	r3, [pc, #576]	; (1c88 <load_wav+0x27c>)
    1a46:	429a      	cmp	r2, r3
    1a48:	f040 817d 	bne.w	1d46 <load_wav+0x33a>
	eof = LD_DWORD(&buff[4]) + 8;
    1a4c:	686b      	ldr	r3, [r5, #4]
    1a4e:	f105 0a04 	add.w	sl, r5, #4
    1a52:	3308      	adds	r3, #8
    1a54:	9307      	str	r3, [sp, #28]
    1a56:	4653      	mov	r3, sl

	/* Analyze the RIFF-WAVE header and get properties */
	nam[0] = art[0] = 0;
    1a58:	f88d 0024 	strb.w	r0, [sp, #36]	; 0x24
    1a5c:	f88d 0064 	strb.w	r0, [sp, #100]	; 0x64
	md = fsmp = wsmp = offw = szwav = 0;
    1a60:	4606      	mov	r6, r0
    1a62:	4683      	mov	fp, r0
    1a64:	9005      	str	r0, [sp, #20]
    1a66:	4681      	mov	r9, r0
    1a68:	4680      	mov	r8, r0
    1a6a:	4682      	mov	sl, r0
    1a6c:	461f      	mov	r7, r3
	while (f_tell(fp) < eof) {
    1a6e:	e0ae      	b.n	1bce <load_wav+0x1c2>
		if (f_read(fp, buff, 8, &br) || br != 8) return -1;
    1a70:	4620      	mov	r0, r4
    1a72:	4629      	mov	r1, r5
    1a74:	2208      	movs	r2, #8
    1a76:	ab2f      	add	r3, sp, #188	; 0xbc
    1a78:	f001 fff2 	bl	3a60 <f_read>
    1a7c:	2800      	cmp	r0, #0
    1a7e:	f040 8162 	bne.w	1d46 <load_wav+0x33a>
    1a82:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
    1a84:	2b08      	cmp	r3, #8
    1a86:	f040 815e 	bne.w	1d46 <load_wav+0x33a>
		sz = (LD_DWORD(&buff[4]) + 1) & ~1;
    1a8a:	683e      	ldr	r6, [r7, #0]
		switch (LD_DWORD(&buff[0])) {
    1a8c:	682b      	ldr	r3, [r5, #0]
    1a8e:	4a7f      	ldr	r2, [pc, #508]	; (1c8c <load_wav+0x280>)
	/* Analyze the RIFF-WAVE header and get properties */
	nam[0] = art[0] = 0;
	md = fsmp = wsmp = offw = szwav = 0;
	while (f_tell(fp) < eof) {
		if (f_read(fp, buff, 8, &br) || br != 8) return -1;
		sz = (LD_DWORD(&buff[4]) + 1) & ~1;
    1a90:	3601      	adds	r6, #1
		switch (LD_DWORD(&buff[0])) {
    1a92:	4293      	cmp	r3, r2
	/* Analyze the RIFF-WAVE header and get properties */
	nam[0] = art[0] = 0;
	md = fsmp = wsmp = offw = szwav = 0;
	while (f_tell(fp) < eof) {
		if (f_read(fp, buff, 8, &br) || br != 8) return -1;
		sz = (LD_DWORD(&buff[4]) + 1) & ~1;
    1a94:	f026 0601 	bic.w	r6, r6, #1
		switch (LD_DWORD(&buff[0])) {
    1a98:	d048      	beq.n	1b2c <load_wav+0x120>
    1a9a:	d804      	bhi.n	1aa6 <load_wav+0x9a>
    1a9c:	4a7c      	ldr	r2, [pc, #496]	; (1c90 <load_wav+0x284>)
    1a9e:	4293      	cmp	r3, r2
    1aa0:	f040 8151 	bne.w	1d46 <load_wav+0x33a>
    1aa4:	e007      	b.n	1ab6 <load_wav+0xaa>
    1aa6:	4a7b      	ldr	r2, [pc, #492]	; (1c94 <load_wav+0x288>)
    1aa8:	4293      	cmp	r3, r2
    1aaa:	d037      	beq.n	1b1c <load_wav+0x110>
    1aac:	4a7a      	ldr	r2, [pc, #488]	; (1c98 <load_wav+0x28c>)
    1aae:	4293      	cmp	r3, r2
    1ab0:	f040 8149 	bne.w	1d46 <load_wav+0x33a>
    1ab4:	e02c      	b.n	1b10 <load_wav+0x104>
		case FCC('f','m','t',' ') :	/* fmt chunk */
			if (sz > 1000 || sz < 16 || f_read(fp, buff, sz, &br) || sz != br) return -1;
    1ab6:	f1a6 0310 	sub.w	r3, r6, #16
    1aba:	f5b3 7f76 	cmp.w	r3, #984	; 0x3d8
    1abe:	f200 8142 	bhi.w	1d46 <load_wav+0x33a>
    1ac2:	4620      	mov	r0, r4
    1ac4:	4629      	mov	r1, r5
    1ac6:	4632      	mov	r2, r6
    1ac8:	ab2f      	add	r3, sp, #188	; 0xbc
    1aca:	f001 ffc9 	bl	3a60 <f_read>
    1ace:	2800      	cmp	r0, #0
    1ad0:	f040 8139 	bne.w	1d46 <load_wav+0x33a>
    1ad4:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
    1ad6:	429e      	cmp	r6, r3
    1ad8:	f040 8135 	bne.w	1d46 <load_wav+0x33a>
			if (LD_WORD(&buff[0]) != 0x1) return -1;	/* Check if LPCM */
    1adc:	882b      	ldrh	r3, [r5, #0]
    1ade:	2b01      	cmp	r3, #1
    1ae0:	f040 8131 	bne.w	1d46 <load_wav+0x33a>
			if (LD_WORD(&buff[2]) == 2) {	/* Channels (1 or 2) */
    1ae4:	f8b5 b002 	ldrh.w	fp, [r5, #2]
				md = 1; wsmp = 2;
			} else {
				md = 0; wsmp = 1;
			}
			if (LD_WORD(&buff[14]) == 16) {	/* Resolution (8 or 16) */
    1ae8:	89eb      	ldrh	r3, [r5, #14]
		switch (LD_DWORD(&buff[0])) {
		case FCC('f','m','t',' ') :	/* fmt chunk */
			if (sz > 1000 || sz < 16 || f_read(fp, buff, sz, &br) || sz != br) return -1;
			if (LD_WORD(&buff[0]) != 0x1) return -1;	/* Check if LPCM */
			if (LD_WORD(&buff[2]) == 2) {	/* Channels (1 or 2) */
				md = 1; wsmp = 2;
    1aea:	f1bb 0f02 	cmp.w	fp, #2
    1aee:	bf18      	it	ne
    1af0:	f04f 0b01 	movne.w	fp, #1
    1af4:	bf14      	ite	ne
    1af6:	f04f 0900 	movne.w	r9, #0
    1afa:	f04f 0901 	moveq.w	r9, #1
			} else {
				md = 0; wsmp = 1;
			}
			if (LD_WORD(&buff[14]) == 16) {	/* Resolution (8 or 16) */
    1afe:	2b10      	cmp	r3, #16
				md |= 2; wsmp *= 2;
    1b00:	bf04      	itt	eq
    1b02:	f049 0902 	orreq.w	r9, r9, #2
    1b06:	ea4f 0b4b 	moveq.w	fp, fp, lsl #1
			}
			fsmp = LD_DWORD(&buff[4]);		/* Sampling rate */
    1b0a:	f8d7 8000 	ldr.w	r8, [r7]
			break;
    1b0e:	e05e      	b.n	1bce <load_wav+0x1c2>

		case FCC('f','a','c','t') :	/* fact chunk */
			f_lseek(fp, f_tell(fp) + sz);
    1b10:	6961      	ldr	r1, [r4, #20]
    1b12:	4620      	mov	r0, r4
    1b14:	1871      	adds	r1, r6, r1
    1b16:	f002 fa42 	bl	3f9e <f_lseek>
			break;
    1b1a:	e058      	b.n	1bce <load_wav+0x1c2>

		case FCC('d','a','t','a') :	/* data chunk */
			offw = f_tell(fp);	/* Wave data start offset */
    1b1c:	6961      	ldr	r1, [r4, #20]
			szwav = sz;			/* Wave data length [byte] */
			f_lseek(fp, f_tell(fp) + sz);
    1b1e:	4620      	mov	r0, r4
		case FCC('f','a','c','t') :	/* fact chunk */
			f_lseek(fp, f_tell(fp) + sz);
			break;

		case FCC('d','a','t','a') :	/* data chunk */
			offw = f_tell(fp);	/* Wave data start offset */
    1b20:	9105      	str	r1, [sp, #20]
			szwav = sz;			/* Wave data length [byte] */
			f_lseek(fp, f_tell(fp) + sz);
    1b22:	1871      	adds	r1, r6, r1
    1b24:	f002 fa3b 	bl	3f9e <f_lseek>
	/* Analyze the RIFF-WAVE header and get properties */
	nam[0] = art[0] = 0;
	md = fsmp = wsmp = offw = szwav = 0;
	while (f_tell(fp) < eof) {
		if (f_read(fp, buff, 8, &br) || br != 8) return -1;
		sz = (LD_DWORD(&buff[4]) + 1) & ~1;
    1b28:	46b2      	mov	sl, r6

		case FCC('d','a','t','a') :	/* data chunk */
			offw = f_tell(fp);	/* Wave data start offset */
			szwav = sz;			/* Wave data length [byte] */
			f_lseek(fp, f_tell(fp) + sz);
			break;
    1b2a:	e050      	b.n	1bce <load_wav+0x1c2>

		case FCC('L','I','S','T'):	/* LIST chunk */
			sz += f_tell(fp);
    1b2c:	6962      	ldr	r2, [r4, #20]
			if (f_read(fp, buff, 4, &br) || br != 4) return -1;
    1b2e:	4620      	mov	r0, r4
			szwav = sz;			/* Wave data length [byte] */
			f_lseek(fp, f_tell(fp) + sz);
			break;

		case FCC('L','I','S','T'):	/* LIST chunk */
			sz += f_tell(fp);
    1b30:	9204      	str	r2, [sp, #16]
			if (f_read(fp, buff, 4, &br) || br != 4) return -1;
    1b32:	4629      	mov	r1, r5
    1b34:	2204      	movs	r2, #4
    1b36:	ab2f      	add	r3, sp, #188	; 0xbc
    1b38:	f001 ff92 	bl	3a60 <f_read>
    1b3c:	2800      	cmp	r0, #0
    1b3e:	f040 8102 	bne.w	1d46 <load_wav+0x33a>
    1b42:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
    1b44:	2b04      	cmp	r3, #4
    1b46:	f040 80fe 	bne.w	1d46 <load_wav+0x33a>
			szwav = sz;			/* Wave data length [byte] */
			f_lseek(fp, f_tell(fp) + sz);
			break;

		case FCC('L','I','S','T'):	/* LIST chunk */
			sz += f_tell(fp);
    1b4a:	9b04      	ldr	r3, [sp, #16]
			if (f_read(fp, buff, 4, &br) || br != 4) return -1;
			if (LD_DWORD(buff) == FCC('I','N','F','O')) {	/* LIST/INFO sub-chunk */
    1b4c:	682a      	ldr	r2, [r5, #0]
			szwav = sz;			/* Wave data length [byte] */
			f_lseek(fp, f_tell(fp) + sz);
			break;

		case FCC('L','I','S','T'):	/* LIST chunk */
			sz += f_tell(fp);
    1b4e:	18f6      	adds	r6, r6, r3
			if (f_read(fp, buff, 4, &br) || br != 4) return -1;
			if (LD_DWORD(buff) == FCC('I','N','F','O')) {	/* LIST/INFO sub-chunk */
    1b50:	4b52      	ldr	r3, [pc, #328]	; (1c9c <load_wav+0x290>)
			szwav = sz;			/* Wave data length [byte] */
			f_lseek(fp, f_tell(fp) + sz);
			break;

		case FCC('L','I','S','T'):	/* LIST chunk */
			sz += f_tell(fp);
    1b52:	9604      	str	r6, [sp, #16]
			if (f_read(fp, buff, 4, &br) || br != 4) return -1;
			if (LD_DWORD(buff) == FCC('I','N','F','O')) {	/* LIST/INFO sub-chunk */
    1b54:	429a      	cmp	r2, r3
    1b56:	d02e      	beq.n	1bb6 <load_wav+0x1aa>
    1b58:	e032      	b.n	1bc0 <load_wav+0x1b4>
				while (f_tell(fp) < sz) {
					if (f_read(fp, buff, 8, &br) || br != 8) return -1;
    1b5a:	4620      	mov	r0, r4
    1b5c:	4629      	mov	r1, r5
    1b5e:	2208      	movs	r2, #8
    1b60:	ab2f      	add	r3, sp, #188	; 0xbc
    1b62:	f001 ff7d 	bl	3a60 <f_read>
    1b66:	2800      	cmp	r0, #0
    1b68:	f040 80ed 	bne.w	1d46 <load_wav+0x33a>
    1b6c:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
    1b6e:	2b08      	cmp	r3, #8
    1b70:	f040 80e9 	bne.w	1d46 <load_wav+0x33a>
					ssz = (LD_DWORD(&buff[4]) + 1) & ~1;
    1b74:	683e      	ldr	r6, [r7, #0]
					p = 0;
					switch (LD_DWORD(buff)) {
    1b76:	682b      	ldr	r3, [r5, #0]
    1b78:	4a49      	ldr	r2, [pc, #292]	; (1ca0 <load_wav+0x294>)
			sz += f_tell(fp);
			if (f_read(fp, buff, 4, &br) || br != 4) return -1;
			if (LD_DWORD(buff) == FCC('I','N','F','O')) {	/* LIST/INFO sub-chunk */
				while (f_tell(fp) < sz) {
					if (f_read(fp, buff, 8, &br) || br != 8) return -1;
					ssz = (LD_DWORD(&buff[4]) + 1) & ~1;
    1b7a:	3601      	adds	r6, #1
					p = 0;
					switch (LD_DWORD(buff)) {
    1b7c:	4293      	cmp	r3, r2
			sz += f_tell(fp);
			if (f_read(fp, buff, 4, &br) || br != 4) return -1;
			if (LD_DWORD(buff) == FCC('I','N','F','O')) {	/* LIST/INFO sub-chunk */
				while (f_tell(fp) < sz) {
					if (f_read(fp, buff, 8, &br) || br != 8) return -1;
					ssz = (LD_DWORD(&buff[4]) + 1) & ~1;
    1b7e:	f026 0601 	bic.w	r6, r6, #1
					p = 0;
					switch (LD_DWORD(buff)) {
    1b82:	f000 80e5 	beq.w	1d50 <load_wav+0x344>
    1b86:	4a47      	ldr	r2, [pc, #284]	; (1ca4 <load_wav+0x298>)
    1b88:	4293      	cmp	r3, r2
    1b8a:	d10c      	bne.n	1ba6 <load_wav+0x19a>
    1b8c:	e0e2      	b.n	1d54 <load_wav+0x348>
						p = nam; break;
					case FCC('I','A','R','T'):		/* IART field */
						p = art; break;
					}
					if (p && ssz <= NBSIZE) {
						if (f_read(fp, p, ssz, &br) || br != ssz) return -1;
    1b8e:	4620      	mov	r0, r4
    1b90:	4632      	mov	r2, r6
    1b92:	ab2f      	add	r3, sp, #188	; 0xbc
    1b94:	f001 ff64 	bl	3a60 <f_read>
    1b98:	2800      	cmp	r0, #0
    1b9a:	f040 80d4 	bne.w	1d46 <load_wav+0x33a>
    1b9e:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
    1ba0:	42b3      	cmp	r3, r6
    1ba2:	d008      	beq.n	1bb6 <load_wav+0x1aa>
    1ba4:	e0cf      	b.n	1d46 <load_wav+0x33a>
					} else {
						if (f_lseek(fp, f_tell(fp) + ssz)) return -1;
    1ba6:	6961      	ldr	r1, [r4, #20]
    1ba8:	4620      	mov	r0, r4
    1baa:	1871      	adds	r1, r6, r1
    1bac:	f002 f9f7 	bl	3f9e <f_lseek>
    1bb0:	2800      	cmp	r0, #0
    1bb2:	f040 80c8 	bne.w	1d46 <load_wav+0x33a>

		case FCC('L','I','S','T'):	/* LIST chunk */
			sz += f_tell(fp);
			if (f_read(fp, buff, 4, &br) || br != 4) return -1;
			if (LD_DWORD(buff) == FCC('I','N','F','O')) {	/* LIST/INFO sub-chunk */
				while (f_tell(fp) < sz) {
    1bb6:	6963      	ldr	r3, [r4, #20]
    1bb8:	9904      	ldr	r1, [sp, #16]
    1bba:	428b      	cmp	r3, r1
    1bbc:	d3cd      	bcc.n	1b5a <load_wav+0x14e>
    1bbe:	e006      	b.n	1bce <load_wav+0x1c2>
					} else {
						if (f_lseek(fp, f_tell(fp) + ssz)) return -1;
					}
				}
			} else {
				if (f_lseek(fp, sz)) return -1;	/* Skip unknown sub-chunk type */
    1bc0:	4620      	mov	r0, r4
    1bc2:	9904      	ldr	r1, [sp, #16]
    1bc4:	f002 f9eb 	bl	3f9e <f_lseek>
    1bc8:	2800      	cmp	r0, #0
    1bca:	f040 80bc 	bne.w	1d46 <load_wav+0x33a>
	eof = LD_DWORD(&buff[4]) + 8;

	/* Analyze the RIFF-WAVE header and get properties */
	nam[0] = art[0] = 0;
	md = fsmp = wsmp = offw = szwav = 0;
	while (f_tell(fp) < eof) {
    1bce:	6963      	ldr	r3, [r4, #20]
    1bd0:	9a07      	ldr	r2, [sp, #28]
    1bd2:	4293      	cmp	r3, r2
    1bd4:	f4ff af4c 	bcc.w	1a70 <load_wav+0x64>
    1bd8:	4657      	mov	r7, sl
    1bda:	4646      	mov	r6, r8

		default :	/* Unknown chunk */
			return -1;
		}
	}
	if (!szwav || !fsmp) return -1;		/* Check if valid WAV file */
    1bdc:	2f00      	cmp	r7, #0
    1bde:	f000 80b2 	beq.w	1d46 <load_wav+0x33a>
    1be2:	2e00      	cmp	r6, #0
    1be4:	f000 80af 	beq.w	1d46 <load_wav+0x33a>
	if (f_lseek(fp, offw)) return -1;	/* Seek to top of wav data */
    1be8:	4620      	mov	r0, r4
    1bea:	9905      	ldr	r1, [sp, #20]
    1bec:	f002 f9d7 	bl	3f9e <f_lseek>
    1bf0:	4682      	mov	sl, r0
    1bf2:	2800      	cmp	r0, #0
    1bf4:	f040 80a7 	bne.w	1d46 <load_wav+0x33a>
	tc = (uint32_t)(szwav / fsmp / wsmp);	/* Length (sec) */

	xprintf("IART=%s\nINAM=%s\n", art, nam);
    1bf8:	482b      	ldr	r0, [pc, #172]	; (1ca8 <load_wav+0x29c>)
    1bfa:	a909      	add	r1, sp, #36	; 0x24
    1bfc:	aa19      	add	r2, sp, #100	; 0x64
    1bfe:	f000 f9bd 	bl	1f7c <xprintf>
	xprintf("Sample=%u.%ukHz/%ubit/%s\nLength=%u:%02u\n", fsmp / 1000, (fsmp / 100) % 10, (md & 2) ? 16 : 8, (md & 1) ? "Stereo" : "Mono", tc / 60, tc % 60);
    1c02:	f009 0e02 	and.w	lr, r9, #2
    1c06:	f8cd e010 	str.w	lr, [sp, #16]
    1c0a:	4928      	ldr	r1, [pc, #160]	; (1cac <load_wav+0x2a0>)
    1c0c:	f8df e0a4 	ldr.w	lr, [pc, #164]	; 1cb4 <load_wav+0x2a8>
    1c10:	f009 0001 	and.w	r0, r9, #1
			return -1;
		}
	}
	if (!szwav || !fsmp) return -1;		/* Check if valid WAV file */
	if (f_lseek(fp, offw)) return -1;	/* Seek to top of wav data */
	tc = (uint32_t)(szwav / fsmp / wsmp);	/* Length (sec) */
    1c14:	fbb7 f8f8 	udiv	r8, r7, r8

	xprintf("IART=%s\nINAM=%s\n", art, nam);
	xprintf("Sample=%u.%ukHz/%ubit/%s\nLength=%u:%02u\n", fsmp / 1000, (fsmp / 100) % 10, (md & 2) ? 16 : 8, (md & 1) ? "Stereo" : "Mono", tc / 60, tc % 60);
    1c18:	2800      	cmp	r0, #0
    1c1a:	bf18      	it	ne
    1c1c:	4671      	movne	r1, lr
			return -1;
		}
	}
	if (!szwav || !fsmp) return -1;		/* Check if valid WAV file */
	if (f_lseek(fp, offw)) return -1;	/* Seek to top of wav data */
	tc = (uint32_t)(szwav / fsmp / wsmp);	/* Length (sec) */
    1c1e:	fbb8 f8fb 	udiv	r8, r8, fp

	xprintf("IART=%s\nINAM=%s\n", art, nam);
	xprintf("Sample=%u.%ukHz/%ubit/%s\nLength=%u:%02u\n", fsmp / 1000, (fsmp / 100) % 10, (md & 2) ? 16 : 8, (md & 1) ? "Stereo" : "Mono", tc / 60, tc % 60);
    1c22:	203c      	movs	r0, #60	; 0x3c
    1c24:	9100      	str	r1, [sp, #0]
    1c26:	fbb8 f1f0 	udiv	r1, r8, r0
    1c2a:	9101      	str	r1, [sp, #4]
    1c2c:	fb00 8111 	mls	r1, r0, r1, r8
    1c30:	2264      	movs	r2, #100	; 0x64
    1c32:	230a      	movs	r3, #10
    1c34:	fbb6 f2f2 	udiv	r2, r6, r2
    1c38:	f8dd e010 	ldr.w	lr, [sp, #16]
    1c3c:	fbb2 fcf3 	udiv	ip, r2, r3
    1c40:	9102      	str	r1, [sp, #8]
    1c42:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    1c46:	481a      	ldr	r0, [pc, #104]	; (1cb0 <load_wav+0x2a4>)
    1c48:	fbb6 f1f1 	udiv	r1, r6, r1
    1c4c:	fb03 221c 	mls	r2, r3, ip, r2
    1c50:	f1be 0f00 	cmp.w	lr, #0
    1c54:	bf0c      	ite	eq
    1c56:	2308      	moveq	r3, #8
    1c58:	2310      	movne	r3, #16
    1c5a:	f000 f98f 	bl	1f7c <xprintf>

	/* Initialize stream parameters and start sound streming */
	fcb.mode = md;			/* Sampling: b0=mono(0)/stereo(1), b1=8bit(0)/16bit(1) */
	fcb.buff = buff;		/* Pointer to streaming buffer */
	fcb.sz_buff = sz_work;	/* Size of streaming buffer */
    1c5e:	9906      	ldr	r1, [sp, #24]
	if (!sound_start(&fcb, fsmp)) return -1;	/* Start sound streaming */
    1c60:	a829      	add	r0, sp, #164	; 0xa4
	xprintf("Sample=%u.%ukHz/%ubit/%s\nLength=%u:%02u\n", fsmp / 1000, (fsmp / 100) % 10, (md & 2) ? 16 : 8, (md & 1) ? "Stereo" : "Mono", tc / 60, tc % 60);

	/* Initialize stream parameters and start sound streming */
	fcb.mode = md;			/* Sampling: b0=mono(0)/stereo(1), b1=8bit(0)/16bit(1) */
	fcb.buff = buff;		/* Pointer to streaming buffer */
	fcb.sz_buff = sz_work;	/* Size of streaming buffer */
    1c62:	912e      	str	r1, [sp, #184]	; 0xb8
	if (!sound_start(&fcb, fsmp)) return -1;	/* Start sound streaming */
    1c64:	4631      	mov	r1, r6

	xprintf("IART=%s\nINAM=%s\n", art, nam);
	xprintf("Sample=%u.%ukHz/%ubit/%s\nLength=%u:%02u\n", fsmp / 1000, (fsmp / 100) % 10, (md & 2) ? 16 : 8, (md & 1) ? "Stereo" : "Mono", tc / 60, tc % 60);

	/* Initialize stream parameters and start sound streming */
	fcb.mode = md;			/* Sampling: b0=mono(0)/stereo(1), b1=8bit(0)/16bit(1) */
    1c66:	f8cd 90a4 	str.w	r9, [sp, #164]	; 0xa4
	fcb.buff = buff;		/* Pointer to streaming buffer */
    1c6a:	952d      	str	r5, [sp, #180]	; 0xb4
	fcb.sz_buff = sz_work;	/* Size of streaming buffer */
	if (!sound_start(&fcb, fsmp)) return -1;	/* Start sound streaming */
    1c6c:	f7ff fe1a 	bl	18a4 <sound_start>
    1c70:	2800      	cmp	r0, #0
    1c72:	d068      	beq.n	1d46 <load_wav+0x33a>

	k = 0; wi = 0;
	while (szwav || fcb.ct >= 4) {	/* Sount streaming loop */
		if (szwav && fcb.ct <= sz_work / 2) {	/* Refill FIFO when it gets half empty */
    1c74:	9a06      	ldr	r2, [sp, #24]
    1c76:	46b1      	mov	r9, r6
    1c78:	0852      	lsrs	r2, r2, #1
    1c7a:	9204      	str	r2, [sp, #16]
    1c7c:	e055      	b.n	1d2a <load_wav+0x31e>
    1c7e:	bf00      	nop
    1c80:	00005c34 	.word	0x00005c34
    1c84:	46464952 	.word	0x46464952
    1c88:	45564157 	.word	0x45564157
    1c8c:	5453494c 	.word	0x5453494c
    1c90:	20746d66 	.word	0x20746d66
    1c94:	61746164 	.word	0x61746164
    1c98:	74636166 	.word	0x74636166
    1c9c:	4f464e49 	.word	0x4f464e49
    1ca0:	4d414e49 	.word	0x4d414e49
    1ca4:	54524149 	.word	0x54524149
    1ca8:	00005c42 	.word	0x00005c42
    1cac:	00005c2f 	.word	0x00005c2f
    1cb0:	00005c53 	.word	0x00005c53
    1cb4:	00005c28 	.word	0x00005c28
    1cb8:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
    1cba:	f8dd e010 	ldr.w	lr, [sp, #16]
    1cbe:	4573      	cmp	r3, lr
    1cc0:	d818      	bhi.n	1cf4 <load_wav+0x2e8>
			btr = (szwav >= sz_work / 2) ? sz_work / 2 : szwav;
    1cc2:	4676      	mov	r6, lr
    1cc4:	42b7      	cmp	r7, r6
    1cc6:	bf38      	it	cc
    1cc8:	463e      	movcc	r6, r7
			f_read(fp, &buff[wi], btr, &br);
    1cca:	ab2f      	add	r3, sp, #188	; 0xbc
    1ccc:	4620      	mov	r0, r4
    1cce:	eb05 010a 	add.w	r1, r5, sl
    1cd2:	4632      	mov	r2, r6
    1cd4:	f001 fec4 	bl	3a60 <f_read>
			if (br != btr) break;	/* Exit if illigal file termination or FS error */
    1cd8:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
    1cda:	42b3      	cmp	r3, r6
    1cdc:	d12b      	bne.n	1d36 <load_wav+0x32a>
			szwav -= br;
			wi = (wi + br) & (sz_work - 1);
    1cde:	9906      	ldr	r1, [sp, #24]
    1ce0:	449a      	add	sl, r3
    1ce2:	1e4a      	subs	r2, r1, #1
	while (szwav || fcb.ct >= 4) {	/* Sount streaming loop */
		if (szwav && fcb.ct <= sz_work / 2) {	/* Refill FIFO when it gets half empty */
			btr = (szwav >= sz_work / 2) ? sz_work / 2 : szwav;
			f_read(fp, &buff[wi], btr, &br);
			if (br != btr) break;	/* Exit if illigal file termination or FS error */
			szwav -= br;
    1ce4:	1aff      	subs	r7, r7, r3
			wi = (wi + br) & (sz_work - 1);
    1ce6:	ea0a 0a02 	and.w	sl, sl, r2
			__disable_irq();
    1cea:	b672      	cpsid	i
			fcb.ct += br;
    1cec:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
    1cee:	18d3      	adds	r3, r2, r3
    1cf0:	932c      	str	r3, [sp, #176]	; 0xb0
			__enable_irq();
    1cf2:	b662      	cpsie	i
		}
		if (uart0_test()) {		/* Exit if a user command arrived */
    1cf4:	f7ff fc6a 	bl	15cc <uart0_test>
    1cf8:	b118      	cbz	r0, 1d02 <load_wav+0x2f6>
			k = uart0_getc();
    1cfa:	f7ff fc6d 	bl	15d8 <uart0_getc>
    1cfe:	4607      	mov	r7, r0
			break;
    1d00:	e01a      	b.n	1d38 <load_wav+0x32c>
		}
		t = (f_tell(fp) - offw - fcb.ct) / fsmp / wsmp;	/* Refresh time display every 1 sec */
    1d02:	6966      	ldr	r6, [r4, #20]
    1d04:	9a05      	ldr	r2, [sp, #20]
    1d06:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
    1d08:	1ab6      	subs	r6, r6, r2
    1d0a:	1af6      	subs	r6, r6, r3
    1d0c:	fbb6 f6f9 	udiv	r6, r6, r9
    1d10:	fbb6 f6fb 	udiv	r6, r6, fp
		if (t != tc) {
    1d14:	4546      	cmp	r6, r8
    1d16:	d008      	beq.n	1d2a <load_wav+0x31e>
			tc = t;
			xprintf("\rTime=%u:%02u", tc / 60, tc % 60);
    1d18:	223c      	movs	r2, #60	; 0x3c
    1d1a:	fbb6 f1f2 	udiv	r1, r6, r2
    1d1e:	4810      	ldr	r0, [pc, #64]	; (1d60 <load_wav+0x354>)
    1d20:	fb02 6211 	mls	r2, r2, r1, r6
    1d24:	f000 f92a 	bl	1f7c <xprintf>
    1d28:	46b0      	mov	r8, r6
	fcb.buff = buff;		/* Pointer to streaming buffer */
	fcb.sz_buff = sz_work;	/* Size of streaming buffer */
	if (!sound_start(&fcb, fsmp)) return -1;	/* Start sound streaming */

	k = 0; wi = 0;
	while (szwav || fcb.ct >= 4) {	/* Sount streaming loop */
    1d2a:	2f00      	cmp	r7, #0
    1d2c:	d1c4      	bne.n	1cb8 <load_wav+0x2ac>
    1d2e:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
    1d30:	2b03      	cmp	r3, #3
    1d32:	d8df      	bhi.n	1cf4 <load_wav+0x2e8>
    1d34:	e000      	b.n	1d38 <load_wav+0x32c>
	fcb.mode = md;			/* Sampling: b0=mono(0)/stereo(1), b1=8bit(0)/16bit(1) */
	fcb.buff = buff;		/* Pointer to streaming buffer */
	fcb.sz_buff = sz_work;	/* Size of streaming buffer */
	if (!sound_start(&fcb, fsmp)) return -1;	/* Start sound streaming */

	k = 0; wi = 0;
    1d36:	2700      	movs	r7, #0
			tc = t;
			xprintf("\rTime=%u:%02u", tc / 60, tc % 60);
		}
	}

	sound_stop();	/* Stop sound output */
    1d38:	f7ff fe36 	bl	19a8 <sound_stop>

	xputc('\n');
    1d3c:	200a      	movs	r0, #10
    1d3e:	f000 f811 	bl	1d64 <xputc>
	return k;	/* Terminated due to -1:error, 0:eot, >0:key code */
    1d42:	4638      	mov	r0, r7
    1d44:	e001      	b.n	1d4a <load_wav+0x33e>

	/* Initialize stream parameters and start sound streming */
	fcb.mode = md;			/* Sampling: b0=mono(0)/stereo(1), b1=8bit(0)/16bit(1) */
	fcb.buff = buff;		/* Pointer to streaming buffer */
	fcb.sz_buff = sz_work;	/* Size of streaming buffer */
	if (!sound_start(&fcb, fsmp)) return -1;	/* Start sound streaming */
    1d46:	f04f 30ff 	mov.w	r0, #4294967295

	sound_stop();	/* Stop sound output */

	xputc('\n');
	return k;	/* Terminated due to -1:error, 0:eot, >0:key code */
}
    1d4a:	b031      	add	sp, #196	; 0xc4
    1d4c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					if (f_read(fp, buff, 8, &br) || br != 8) return -1;
					ssz = (LD_DWORD(&buff[4]) + 1) & ~1;
					p = 0;
					switch (LD_DWORD(buff)) {
					case FCC('I','N','A','M'):		/* INAM field */
						p = nam; break;
    1d50:	a919      	add	r1, sp, #100	; 0x64
    1d52:	e000      	b.n	1d56 <load_wav+0x34a>
					case FCC('I','A','R','T'):		/* IART field */
						p = art; break;
    1d54:	a909      	add	r1, sp, #36	; 0x24
					}
					if (p && ssz <= NBSIZE) {
    1d56:	2e40      	cmp	r6, #64	; 0x40
    1d58:	f63f af25 	bhi.w	1ba6 <load_wav+0x19a>
    1d5c:	e717      	b.n	1b8e <load_wav+0x182>
    1d5e:	bf00      	nop
    1d60:	00005c7c 	.word	0x00005c7c

00001d64 <xputc>:
/* Put a character                              */
/*----------------------------------------------*/

void xputc (char c)
{
	if (_CR_CRLF && c == '\n') xputc('\r');		/* CR -> CRLF */
    1d64:	280a      	cmp	r0, #10
/*----------------------------------------------*/
/* Put a character                              */
/*----------------------------------------------*/

void xputc (char c)
{
    1d66:	b510      	push	{r4, lr}
    1d68:	4604      	mov	r4, r0
	if (_CR_CRLF && c == '\n') xputc('\r');		/* CR -> CRLF */
    1d6a:	d102      	bne.n	1d72 <xputc+0xe>
    1d6c:	200d      	movs	r0, #13
    1d6e:	f7ff fff9 	bl	1d64 <xputc>

	if (outptr) {
    1d72:	4a06      	ldr	r2, [pc, #24]	; (1d8c <xputc+0x28>)
    1d74:	6813      	ldr	r3, [r2, #0]
    1d76:	b11b      	cbz	r3, 1d80 <xputc+0x1c>
		*outptr++ = (unsigned char)c;
    1d78:	f803 4b01 	strb.w	r4, [r3], #1
    1d7c:	6013      	str	r3, [r2, #0]
		return;
    1d7e:	bd10      	pop	{r4, pc}
	}

	if (xfunc_out) xfunc_out((unsigned char)c);
    1d80:	4b03      	ldr	r3, [pc, #12]	; (1d90 <xputc+0x2c>)
    1d82:	681b      	ldr	r3, [r3, #0]
    1d84:	b10b      	cbz	r3, 1d8a <xputc+0x26>
    1d86:	4620      	mov	r0, r4
    1d88:	4798      	blx	r3
    1d8a:	bd10      	pop	{r4, pc}
    1d8c:	1000011c 	.word	0x1000011c
    1d90:	10004914 	.word	0x10004914

00001d94 <xputs>:
/*----------------------------------------------*/

void xputs (					/* Put a string to the default device */
	const char* str				/* Pointer to the string */
)
{
    1d94:	b510      	push	{r4, lr}
    1d96:	4604      	mov	r4, r0
	while (*str)
    1d98:	e001      	b.n	1d9e <xputs+0xa>
		xputc(*str++);
    1d9a:	f7ff ffe3 	bl	1d64 <xputc>

void xputs (					/* Put a string to the default device */
	const char* str				/* Pointer to the string */
)
{
	while (*str)
    1d9e:	f814 0b01 	ldrb.w	r0, [r4], #1
    1da2:	2800      	cmp	r0, #0
    1da4:	d1f9      	bne.n	1d9a <xputs+0x6>
		xputc(*str++);
}
    1da6:	bd10      	pop	{r4, pc}

00001da8 <xvprintf>:
static
void xvprintf (
	const char*	fmt,	/* Pointer to the format string */
	va_list arp			/* Pointer to arguments */
)
{
    1da8:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    1dac:	4604      	mov	r4, r0
    1dae:	460d      	mov	r5, r1
    1db0:	e000      	b.n	1db4 <xvprintf+0xc>
		case 'U' :					/* Unsigned decimal */
			r = 10; break;
		case 'X' :					/* Hexdecimal */
			r = 16; break;
		default:					/* Unknown type (passthrough) */
			xputc(c); continue;
    1db2:	463d      	mov	r5, r7
	unsigned long v;
	char s[16], c, d, *p;


	for (;;) {
		c = *fmt++;					/* Get a char */
    1db4:	7820      	ldrb	r0, [r4, #0]
		if (!c) break;				/* End of format? */
    1db6:	2800      	cmp	r0, #0
    1db8:	f000 80cd 	beq.w	1f56 <xvprintf+0x1ae>
	unsigned long v;
	char s[16], c, d, *p;


	for (;;) {
		c = *fmt++;					/* Get a char */
    1dbc:	3401      	adds	r4, #1
		if (!c) break;				/* End of format? */
		if (c != '%') {				/* Pass through it if not a % sequense */
    1dbe:	2825      	cmp	r0, #37	; 0x25
    1dc0:	d168      	bne.n	1e94 <xvprintf+0xec>
			xputc(c); continue;
		}
		f = 0;
		c = *fmt++;					/* Get first char of the sequense */
    1dc2:	f814 0b01 	ldrb.w	r0, [r4], #1
		if (c == '0') {				/* Flag: '0' padded */
    1dc6:	2830      	cmp	r0, #48	; 0x30
    1dc8:	d103      	bne.n	1dd2 <xvprintf+0x2a>
			f = 1; c = *fmt++;
    1dca:	f814 0b01 	ldrb.w	r0, [r4], #1
    1dce:	2601      	movs	r6, #1
    1dd0:	e006      	b.n	1de0 <xvprintf+0x38>
		} else {
			if (c == '-') {			/* Flag: left justified */
    1dd2:	282d      	cmp	r0, #45	; 0x2d
    1dd4:	d103      	bne.n	1dde <xvprintf+0x36>
				f = 2; c = *fmt++;
    1dd6:	f814 0b01 	ldrb.w	r0, [r4], #1
    1dda:	2602      	movs	r6, #2
    1ddc:	e000      	b.n	1de0 <xvprintf+0x38>
		c = *fmt++;					/* Get a char */
		if (!c) break;				/* End of format? */
		if (c != '%') {				/* Pass through it if not a % sequense */
			xputc(c); continue;
		}
		f = 0;
    1dde:	2600      	movs	r6, #0
		} else {
			if (c == '-') {			/* Flag: left justified */
				f = 2; c = *fmt++;
			}
		}
		for (w = 0; c >= '0' && c <= '9'; c = *fmt++)	/* Minimum width */
    1de0:	f04f 0900 	mov.w	r9, #0
    1de4:	e006      	b.n	1df4 <xvprintf+0x4c>
			w = w * 10 + c - '0';
    1de6:	230a      	movs	r3, #10
    1de8:	fb03 0909 	mla	r9, r3, r9, r0
		} else {
			if (c == '-') {			/* Flag: left justified */
				f = 2; c = *fmt++;
			}
		}
		for (w = 0; c >= '0' && c <= '9'; c = *fmt++)	/* Minimum width */
    1dec:	f814 0b01 	ldrb.w	r0, [r4], #1
			w = w * 10 + c - '0';
    1df0:	f1a9 0930 	sub.w	r9, r9, #48	; 0x30
		} else {
			if (c == '-') {			/* Flag: left justified */
				f = 2; c = *fmt++;
			}
		}
		for (w = 0; c >= '0' && c <= '9'; c = *fmt++)	/* Minimum width */
    1df4:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
    1df8:	b2db      	uxtb	r3, r3
    1dfa:	2b09      	cmp	r3, #9
    1dfc:	d9f3      	bls.n	1de6 <xvprintf+0x3e>
			w = w * 10 + c - '0';
		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
    1dfe:	286c      	cmp	r0, #108	; 0x6c
    1e00:	d001      	beq.n	1e06 <xvprintf+0x5e>
    1e02:	284c      	cmp	r0, #76	; 0x4c
    1e04:	d103      	bne.n	1e0e <xvprintf+0x66>
			f |= 4; c = *fmt++;
    1e06:	f814 0b01 	ldrb.w	r0, [r4], #1
    1e0a:	f046 0604 	orr.w	r6, r6, #4
		}
		if (!c) break;				/* End of format? */
    1e0e:	2800      	cmp	r0, #0
    1e10:	f000 80a1 	beq.w	1f56 <xvprintf+0x1ae>
		d = c;
		if (d >= 'a') d -= 0x20;
    1e14:	2860      	cmp	r0, #96	; 0x60
    1e16:	bf86      	itte	hi
    1e18:	f1a0 0320 	subhi.w	r3, r0, #32
    1e1c:	b2db      	uxtbhi	r3, r3
    1e1e:	4603      	movls	r3, r0
		switch (d) {				/* Type is... */
    1e20:	2b4f      	cmp	r3, #79	; 0x4f
    1e22:	d03d      	beq.n	1ea0 <xvprintf+0xf8>
    1e24:	d806      	bhi.n	1e34 <xvprintf+0x8c>
    1e26:	2b43      	cmp	r3, #67	; 0x43
    1e28:	d02d      	beq.n	1e86 <xvprintf+0xde>
    1e2a:	2b44      	cmp	r3, #68	; 0x44
    1e2c:	d009      	beq.n	1e42 <xvprintf+0x9a>
    1e2e:	2b42      	cmp	r3, #66	; 0x42
    1e30:	d130      	bne.n	1e94 <xvprintf+0xec>
    1e32:	e033      	b.n	1e9c <xvprintf+0xf4>
    1e34:	2b55      	cmp	r3, #85	; 0x55
    1e36:	d004      	beq.n	1e42 <xvprintf+0x9a>
    1e38:	2b58      	cmp	r3, #88	; 0x58
    1e3a:	d029      	beq.n	1e90 <xvprintf+0xe8>
    1e3c:	2b53      	cmp	r3, #83	; 0x53
    1e3e:	d129      	bne.n	1e94 <xvprintf+0xec>
    1e40:	e001      	b.n	1e46 <xvprintf+0x9e>
			r = 2; break;
		case 'O' :					/* Octal */
			r = 8; break;
		case 'D' :					/* Signed decimal */
		case 'U' :					/* Unsigned decimal */
			r = 10; break;
    1e42:	210a      	movs	r1, #10
    1e44:	e02d      	b.n	1ea2 <xvprintf+0xfa>
		if (!c) break;				/* End of format? */
		d = c;
		if (d >= 'a') d -= 0x20;
		switch (d) {				/* Type is... */
		case 'S' :					/* String */
			p = va_arg(arp, char*);
    1e46:	1d2f      	adds	r7, r5, #4
    1e48:	f8d5 8000 	ldr.w	r8, [r5]
			for (j = 0; p[j]; j++) ;
    1e4c:	2500      	movs	r5, #0
    1e4e:	e000      	b.n	1e52 <xvprintf+0xaa>
    1e50:	3501      	adds	r5, #1
    1e52:	f818 3005 	ldrb.w	r3, [r8, r5]
    1e56:	2b00      	cmp	r3, #0
    1e58:	d1fa      	bne.n	1e50 <xvprintf+0xa8>
    1e5a:	e002      	b.n	1e62 <xvprintf+0xba>
			while (!(f & 2) && j++ < w) xputc(' ');
    1e5c:	2020      	movs	r0, #32
    1e5e:	f7ff ff81 	bl	1d64 <xputc>
    1e62:	f016 0f02 	tst.w	r6, #2
    1e66:	d103      	bne.n	1e70 <xvprintf+0xc8>
    1e68:	3501      	adds	r5, #1
    1e6a:	1e6b      	subs	r3, r5, #1
    1e6c:	454b      	cmp	r3, r9
    1e6e:	d3f5      	bcc.n	1e5c <xvprintf+0xb4>
			xputs(p);
    1e70:	4640      	mov	r0, r8
    1e72:	f7ff ff8f 	bl	1d94 <xputs>
			while (j++ < w) xputc(' ');
    1e76:	e003      	b.n	1e80 <xvprintf+0xd8>
    1e78:	2020      	movs	r0, #32
    1e7a:	f7ff ff73 	bl	1d64 <xputc>
    1e7e:	3501      	adds	r5, #1
    1e80:	454d      	cmp	r5, r9
    1e82:	d3f9      	bcc.n	1e78 <xvprintf+0xd0>
    1e84:	e795      	b.n	1db2 <xvprintf+0xa>
			continue;
		case 'C' :					/* Character */
			xputc((char)va_arg(arp, int)); continue;
    1e86:	7828      	ldrb	r0, [r5, #0]
    1e88:	1d2f      	adds	r7, r5, #4
    1e8a:	f7ff ff6b 	bl	1d64 <xputc>
    1e8e:	e790      	b.n	1db2 <xvprintf+0xa>
			r = 8; break;
		case 'D' :					/* Signed decimal */
		case 'U' :					/* Unsigned decimal */
			r = 10; break;
		case 'X' :					/* Hexdecimal */
			r = 16; break;
    1e90:	2110      	movs	r1, #16
    1e92:	e006      	b.n	1ea2 <xvprintf+0xfa>
		default:					/* Unknown type (passthrough) */
			xputc(c); continue;
    1e94:	f7ff ff66 	bl	1d64 <xputc>
    1e98:	462f      	mov	r7, r5
    1e9a:	e78a      	b.n	1db2 <xvprintf+0xa>
			while (j++ < w) xputc(' ');
			continue;
		case 'C' :					/* Character */
			xputc((char)va_arg(arp, int)); continue;
		case 'B' :					/* Binary */
			r = 2; break;
    1e9c:	2102      	movs	r1, #2
    1e9e:	e000      	b.n	1ea2 <xvprintf+0xfa>
		case 'O' :					/* Octal */
			r = 8; break;
    1ea0:	2108      	movs	r1, #8
		default:					/* Unknown type (passthrough) */
			xputc(c); continue;
		}

		/* Get an argument and put it in numeral */
		v = (f & 4) ? va_arg(arp, long) : ((d == 'D') ? (long)va_arg(arp, int) : (long)va_arg(arp, unsigned int));
    1ea2:	f016 0f04 	tst.w	r6, #4
    1ea6:	f105 0704 	add.w	r7, r5, #4
    1eaa:	d002      	beq.n	1eb2 <xvprintf+0x10a>
    1eac:	682a      	ldr	r2, [r5, #0]
		if (d == 'D' && (v & 0x80000000)) {
    1eae:	2b44      	cmp	r3, #68	; 0x44
    1eb0:	e001      	b.n	1eb6 <xvprintf+0x10e>
    1eb2:	682a      	ldr	r2, [r5, #0]
		default:					/* Unknown type (passthrough) */
			xputc(c); continue;
		}

		/* Get an argument and put it in numeral */
		v = (f & 4) ? va_arg(arp, long) : ((d == 'D') ? (long)va_arg(arp, int) : (long)va_arg(arp, unsigned int));
    1eb4:	2b44      	cmp	r3, #68	; 0x44
    1eb6:	d104      	bne.n	1ec2 <xvprintf+0x11a>
		if (d == 'D' && (v & 0x80000000)) {
    1eb8:	2a00      	cmp	r2, #0
    1eba:	da02      	bge.n	1ec2 <xvprintf+0x11a>
			v = 0 - v;
    1ebc:	4252      	negs	r2, r2
			f |= 8;
    1ebe:	f046 0608 	orr.w	r6, r6, #8
		}
		i = 0;
    1ec2:	2500      	movs	r5, #0
		do {
			d = (char)(v % r); v /= r;
    1ec4:	fbb2 fef1 	udiv	lr, r2, r1
    1ec8:	fb01 221e 	mls	r2, r1, lr, r2
    1ecc:	b2d3      	uxtb	r3, r2
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
    1ece:	2b09      	cmp	r3, #9
			v = 0 - v;
			f |= 8;
		}
		i = 0;
		do {
			d = (char)(v % r); v /= r;
    1ed0:	4672      	mov	r2, lr
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
    1ed2:	d907      	bls.n	1ee4 <xvprintf+0x13c>
    1ed4:	2878      	cmp	r0, #120	; 0x78
    1ed6:	bf14      	ite	ne
    1ed8:	f04f 0c07 	movne.w	ip, #7
    1edc:	f04f 0c27 	moveq.w	ip, #39	; 0x27
    1ee0:	4463      	add	r3, ip
    1ee2:	b2db      	uxtb	r3, r3
			s[i++] = d + '0';
    1ee4:	3330      	adds	r3, #48	; 0x30
    1ee6:	f80d 3005 	strb.w	r3, [sp, r5]
    1eea:	3501      	adds	r5, #1
		} while (v && i < sizeof(s));
    1eec:	f1be 0f00 	cmp.w	lr, #0
    1ef0:	d001      	beq.n	1ef6 <xvprintf+0x14e>
    1ef2:	2d10      	cmp	r5, #16
    1ef4:	d1e6      	bne.n	1ec4 <xvprintf+0x11c>
		if (f & 8) s[i++] = '-';
    1ef6:	f016 0f08 	tst.w	r6, #8
    1efa:	d005      	beq.n	1f08 <xvprintf+0x160>
    1efc:	aa04      	add	r2, sp, #16
    1efe:	1953      	adds	r3, r2, r5
    1f00:	222d      	movs	r2, #45	; 0x2d
    1f02:	f803 2c10 	strb.w	r2, [r3, #-16]
    1f06:	3501      	adds	r5, #1
		j = i; d = (f & 1) ? '0' : ' ';
    1f08:	f006 0a01 	and.w	sl, r6, #1
    1f0c:	f1ba 0f00 	cmp.w	sl, #0
    1f10:	bf0c      	ite	eq
    1f12:	f04f 0a20 	moveq.w	sl, #32
    1f16:	f04f 0a30 	movne.w	sl, #48	; 0x30
    1f1a:	46a8      	mov	r8, r5
		while (!(f & 2) && j++ < w) xputc(d);
    1f1c:	e002      	b.n	1f24 <xvprintf+0x17c>
    1f1e:	4650      	mov	r0, sl
    1f20:	f7ff ff20 	bl	1d64 <xputc>
    1f24:	f016 0f02 	tst.w	r6, #2
    1f28:	d105      	bne.n	1f36 <xvprintf+0x18e>
    1f2a:	f108 0801 	add.w	r8, r8, #1
    1f2e:	f108 33ff 	add.w	r3, r8, #4294967295
    1f32:	454b      	cmp	r3, r9
    1f34:	d3f3      	bcc.n	1f1e <xvprintf+0x176>
		do xputc(s[--i]); while(i);
    1f36:	3d01      	subs	r5, #1
    1f38:	f81d 0005 	ldrb.w	r0, [sp, r5]
    1f3c:	f7ff ff12 	bl	1d64 <xputc>
    1f40:	2d00      	cmp	r5, #0
    1f42:	d1f8      	bne.n	1f36 <xvprintf+0x18e>
    1f44:	e004      	b.n	1f50 <xvprintf+0x1a8>
		while (j++ < w) xputc(' ');
    1f46:	2020      	movs	r0, #32
    1f48:	f7ff ff0c 	bl	1d64 <xputc>
    1f4c:	f108 0801 	add.w	r8, r8, #1
    1f50:	45c8      	cmp	r8, r9
    1f52:	d3f8      	bcc.n	1f46 <xvprintf+0x19e>
    1f54:	e72d      	b.n	1db2 <xvprintf+0xa>
	}
}
    1f56:	e8bd 87ff 	ldmia.w	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, pc}

00001f5a <xfputs>:
)
{
	void (*pf)(unsigned char);


	pf = xfunc_out;		/* Save current output device */
    1f5a:	4b07      	ldr	r3, [pc, #28]	; (1f78 <xfputs+0x1e>)

void xfputs (					/* Put a string to the specified device */
	void(*func)(unsigned char),	/* Pointer to the output function */
	const char*	str				/* Pointer to the string */
)
{
    1f5c:	b570      	push	{r4, r5, r6, lr}
	void (*pf)(unsigned char);


	pf = xfunc_out;		/* Save current output device */
    1f5e:	681c      	ldr	r4, [r3, #0]
	xfunc_out = func;	/* Switch output to specified device */
    1f60:	460d      	mov	r5, r1
    1f62:	6018      	str	r0, [r3, #0]
    1f64:	461e      	mov	r6, r3
	while (*str)		/* Put the string */
    1f66:	e001      	b.n	1f6c <xfputs+0x12>
		xputc(*str++);
    1f68:	f7ff fefc 	bl	1d64 <xputc>
	void (*pf)(unsigned char);


	pf = xfunc_out;		/* Save current output device */
	xfunc_out = func;	/* Switch output to specified device */
	while (*str)		/* Put the string */
    1f6c:	f815 0b01 	ldrb.w	r0, [r5], #1
    1f70:	2800      	cmp	r0, #0
    1f72:	d1f9      	bne.n	1f68 <xfputs+0xe>
		xputc(*str++);
	xfunc_out = pf;		/* Restore output device */
    1f74:	6034      	str	r4, [r6, #0]
}
    1f76:	bd70      	pop	{r4, r5, r6, pc}
    1f78:	10004914 	.word	0x10004914

00001f7c <xprintf>:

void xprintf (			/* Put a formatted string to the default device */
	const char*	fmt,	/* Pointer to the format string */
	...					/* Optional arguments */
)
{
    1f7c:	b40f      	push	{r0, r1, r2, r3}
    1f7e:	b507      	push	{r0, r1, r2, lr}
    1f80:	a904      	add	r1, sp, #16
    1f82:	f851 0b04 	ldr.w	r0, [r1], #4
	va_list arp;


	va_start(arp, fmt);
    1f86:	9101      	str	r1, [sp, #4]
	xvprintf(fmt, arp);
    1f88:	f7ff ff0e 	bl	1da8 <xvprintf>
	va_end(arp);
}
    1f8c:	e8bd 400e 	ldmia.w	sp!, {r1, r2, r3, lr}
    1f90:	b004      	add	sp, #16
    1f92:	4770      	bx	lr

00001f94 <xsprintf>:
void xsprintf (			/* Put a formatted string to the memory */
	char* buff,			/* Pointer to the output buffer */
	const char*	fmt,	/* Pointer to the format string */
	...					/* Optional arguments */
)
{
    1f94:	b40e      	push	{r1, r2, r3}
    1f96:	b517      	push	{r0, r1, r2, r4, lr}
    1f98:	a905      	add	r1, sp, #20
    1f9a:	f851 3b04 	ldr.w	r3, [r1], #4
	va_list arp;


	outptr = buff;		/* Switch destination for memory */
    1f9e:	4c07      	ldr	r4, [pc, #28]	; (1fbc <xsprintf+0x28>)

	va_start(arp, fmt);
    1fa0:	9101      	str	r1, [sp, #4]
)
{
	va_list arp;


	outptr = buff;		/* Switch destination for memory */
    1fa2:	6020      	str	r0, [r4, #0]

	va_start(arp, fmt);
	xvprintf(fmt, arp);
    1fa4:	4618      	mov	r0, r3
    1fa6:	f7ff feff 	bl	1da8 <xvprintf>
	va_end(arp);

	*outptr = 0;		/* Terminate output string with a \0 */
    1faa:	6822      	ldr	r2, [r4, #0]
    1fac:	2300      	movs	r3, #0
    1fae:	7013      	strb	r3, [r2, #0]
	outptr = 0;			/* Switch destination for device */
    1fb0:	6023      	str	r3, [r4, #0]
}
    1fb2:	e8bd 401e 	ldmia.w	sp!, {r1, r2, r3, r4, lr}
    1fb6:	b003      	add	sp, #12
    1fb8:	4770      	bx	lr
    1fba:	bf00      	nop
    1fbc:	1000011c 	.word	0x1000011c

00001fc0 <xfprintf>:
void xfprintf (					/* Put a formatted string to the specified device */
	void(*func)(unsigned char),	/* Pointer to the output function */
	const char*	fmt,			/* Pointer to the format string */
	...							/* Optional arguments */
)
{
    1fc0:	b40e      	push	{r1, r2, r3}
    1fc2:	b533      	push	{r0, r1, r4, r5, lr}
	va_list arp;
	void (*pf)(unsigned char);


	pf = xfunc_out;		/* Save current output device */
    1fc4:	4c07      	ldr	r4, [pc, #28]	; (1fe4 <xfprintf+0x24>)
void xfprintf (					/* Put a formatted string to the specified device */
	void(*func)(unsigned char),	/* Pointer to the output function */
	const char*	fmt,			/* Pointer to the format string */
	...							/* Optional arguments */
)
{
    1fc6:	a905      	add	r1, sp, #20
    1fc8:	f851 3b04 	ldr.w	r3, [r1], #4
	va_list arp;
	void (*pf)(unsigned char);


	pf = xfunc_out;		/* Save current output device */
    1fcc:	6825      	ldr	r5, [r4, #0]
	xfunc_out = func;	/* Switch output to specified device */
    1fce:	6020      	str	r0, [r4, #0]

	va_start(arp, fmt);
	xvprintf(fmt, arp);
    1fd0:	4618      	mov	r0, r3


	pf = xfunc_out;		/* Save current output device */
	xfunc_out = func;	/* Switch output to specified device */

	va_start(arp, fmt);
    1fd2:	9101      	str	r1, [sp, #4]
	xvprintf(fmt, arp);
    1fd4:	f7ff fee8 	bl	1da8 <xvprintf>
	va_end(arp);

	xfunc_out = pf;		/* Restore output device */
    1fd8:	6025      	str	r5, [r4, #0]
}
    1fda:	e8bd 403c 	ldmia.w	sp!, {r2, r3, r4, r5, lr}
    1fde:	b003      	add	sp, #12
    1fe0:	4770      	bx	lr
    1fe2:	bf00      	nop
    1fe4:	10004914 	.word	0x10004914

00001fe8 <put_dump>:
	const void* buff,		/* Pointer to the array to be dumped */
	unsigned long addr,		/* Heading address value */
	int len,				/* Number of items to be dumped */
	int width				/* Size of the items (DW_CHAR, DW_SHORT, DW_LONG) */
)
{
    1fe8:	b570      	push	{r4, r5, r6, lr}
    1fea:	461e      	mov	r6, r3
    1fec:	4604      	mov	r4, r0
	const unsigned char *bp;
	const unsigned short *sp;
	const unsigned long *lp;


	xprintf("%08lX:", addr);		/* address */
    1fee:	481e      	ldr	r0, [pc, #120]	; (2068 <put_dump+0x80>)
	const void* buff,		/* Pointer to the array to be dumped */
	unsigned long addr,		/* Heading address value */
	int len,				/* Number of items to be dumped */
	int width				/* Size of the items (DW_CHAR, DW_SHORT, DW_LONG) */
)
{
    1ff0:	4615      	mov	r5, r2
	const unsigned char *bp;
	const unsigned short *sp;
	const unsigned long *lp;


	xprintf("%08lX:", addr);		/* address */
    1ff2:	f7ff ffc3 	bl	1f7c <xprintf>

	switch (width) {
    1ff6:	2e02      	cmp	r6, #2
    1ff8:	d020      	beq.n	203c <put_dump+0x54>
    1ffa:	2e04      	cmp	r6, #4
    1ffc:	d026      	beq.n	204c <put_dump+0x64>
    1ffe:	2e01      	cmp	r6, #1
    2000:	d12b      	bne.n	205a <put_dump+0x72>
    2002:	e005      	b.n	2010 <put_dump+0x28>
	case DW_CHAR:
		bp = buff;
		for (i = 0; i < len; i++)		/* Hexdecimal dump */
			xprintf(" %02X", bp[i]);
    2004:	5da1      	ldrb	r1, [r4, r6]
    2006:	4819      	ldr	r0, [pc, #100]	; (206c <put_dump+0x84>)
    2008:	f7ff ffb8 	bl	1f7c <xprintf>
	xprintf("%08lX:", addr);		/* address */

	switch (width) {
	case DW_CHAR:
		bp = buff;
		for (i = 0; i < len; i++)		/* Hexdecimal dump */
    200c:	3601      	adds	r6, #1
    200e:	e000      	b.n	2012 <put_dump+0x2a>
    2010:	2600      	movs	r6, #0
    2012:	42ae      	cmp	r6, r5
    2014:	dbf6      	blt.n	2004 <put_dump+0x1c>
			xprintf(" %02X", bp[i]);
		xputc(' ');
    2016:	2020      	movs	r0, #32
    2018:	f7ff fea4 	bl	1d64 <xputc>
		for (i = 0; i < len; i++)		/* ASCII dump */
    201c:	2600      	movs	r6, #0
    201e:	e00a      	b.n	2036 <put_dump+0x4e>
			xputc((bp[i] >= ' ' && bp[i] <= '~') ? bp[i] : '.');
    2020:	5da3      	ldrb	r3, [r4, r6]
	case DW_CHAR:
		bp = buff;
		for (i = 0; i < len; i++)		/* Hexdecimal dump */
			xprintf(" %02X", bp[i]);
		xputc(' ');
		for (i = 0; i < len; i++)		/* ASCII dump */
    2022:	3601      	adds	r6, #1
			xputc((bp[i] >= ' ' && bp[i] <= '~') ? bp[i] : '.');
    2024:	f1a3 0020 	sub.w	r0, r3, #32
    2028:	b2c0      	uxtb	r0, r0
    202a:	285e      	cmp	r0, #94	; 0x5e
    202c:	bf94      	ite	ls
    202e:	4618      	movls	r0, r3
    2030:	202e      	movhi	r0, #46	; 0x2e
    2032:	f7ff fe97 	bl	1d64 <xputc>
	case DW_CHAR:
		bp = buff;
		for (i = 0; i < len; i++)		/* Hexdecimal dump */
			xprintf(" %02X", bp[i]);
		xputc(' ');
		for (i = 0; i < len; i++)		/* ASCII dump */
    2036:	42ae      	cmp	r6, r5
    2038:	dbf2      	blt.n	2020 <put_dump+0x38>
    203a:	e00e      	b.n	205a <put_dump+0x72>
			xputc((bp[i] >= ' ' && bp[i] <= '~') ? bp[i] : '.');
		break;
	case DW_SHORT:
		sp = buff;
		do								/* Hexdecimal dump */
			xprintf(" %04X", *sp++);
    203c:	480c      	ldr	r0, [pc, #48]	; (2070 <put_dump+0x88>)
    203e:	f834 1b02 	ldrh.w	r1, [r4], #2
    2042:	f7ff ff9b 	bl	1f7c <xprintf>
		while (--len);
    2046:	3d01      	subs	r5, #1
    2048:	d1f8      	bne.n	203c <put_dump+0x54>
    204a:	e006      	b.n	205a <put_dump+0x72>
		break;
	case DW_LONG:
		lp = buff;
		do								/* Hexdecimal dump */
			xprintf(" %08LX", *lp++);
    204c:	4809      	ldr	r0, [pc, #36]	; (2074 <put_dump+0x8c>)
    204e:	f854 1b04 	ldr.w	r1, [r4], #4
    2052:	f7ff ff93 	bl	1f7c <xprintf>
		while (--len);
    2056:	3d01      	subs	r5, #1
    2058:	d1f8      	bne.n	204c <put_dump+0x64>
		break;
	}

#if !_LF_CRLF
	xputc('\r');
    205a:	200d      	movs	r0, #13
    205c:	f7ff fe82 	bl	1d64 <xputc>
#endif
	xputc('\n');
    2060:	200a      	movs	r0, #10
}
    2062:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	}

#if !_LF_CRLF
	xputc('\r');
#endif
	xputc('\n');
    2066:	e67d      	b.n	1d64 <xputc>
    2068:	00005c8a 	.word	0x00005c8a
    206c:	00005c91 	.word	0x00005c91
    2070:	00005c97 	.word	0x00005c97
    2074:	00005c9d 	.word	0x00005c9d

00002078 <xgets>:

int xgets (		/* 0:End of stream, 1:A line arrived */
	char* buff,	/* Pointer to the buffer */
	int len		/* Buffer length */
)
{
    2078:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int c, i;


	if (!xfunc_in) return 0;		/* No input function specified */
    207a:	4f12      	ldr	r7, [pc, #72]	; (20c4 <xgets+0x4c>)

int xgets (		/* 0:End of stream, 1:A line arrived */
	char* buff,	/* Pointer to the buffer */
	int len		/* Buffer length */
)
{
    207c:	4604      	mov	r4, r0
	int c, i;


	if (!xfunc_in) return 0;		/* No input function specified */
    207e:	6838      	ldr	r0, [r7, #0]

int xgets (		/* 0:End of stream, 1:A line arrived */
	char* buff,	/* Pointer to the buffer */
	int len		/* Buffer length */
)
{
    2080:	460e      	mov	r6, r1
	int c, i;


	if (!xfunc_in) return 0;		/* No input function specified */
    2082:	b1f0      	cbz	r0, 20c2 <xgets+0x4a>
    2084:	2500      	movs	r5, #0

	i = 0;
	for (;;) {
		c = xfunc_in();				/* Get a char from the incoming stream */
    2086:	683b      	ldr	r3, [r7, #0]
    2088:	4798      	blx	r3
		if (!c) return 0;			/* End of stream? */
    208a:	b1d0      	cbz	r0, 20c2 <xgets+0x4a>
		if (c == '\r') break;		/* End of line? */
    208c:	280d      	cmp	r0, #13
    208e:	d00f      	beq.n	20b0 <xgets+0x38>
		if (c == '\b' && i) {		/* Back space? */
    2090:	2808      	cmp	r0, #8
    2092:	d103      	bne.n	209c <xgets+0x24>
    2094:	2d00      	cmp	r5, #0
    2096:	d0f6      	beq.n	2086 <xgets+0xe>
			i--;
    2098:	3d01      	subs	r5, #1
    209a:	e006      	b.n	20aa <xgets+0x32>
#if _LINE_ECHO
			xputc(c);
#endif
			continue;
		}
		if (c >= ' ' && i < len - 1) {	/* Visible chars */
    209c:	281f      	cmp	r0, #31
    209e:	ddf2      	ble.n	2086 <xgets+0xe>
    20a0:	1e72      	subs	r2, r6, #1
    20a2:	4295      	cmp	r5, r2
    20a4:	daef      	bge.n	2086 <xgets+0xe>
			buff[i++] = c;
    20a6:	5560      	strb	r0, [r4, r5]
    20a8:	3501      	adds	r5, #1
#if _LINE_ECHO
			xputc(c);
    20aa:	f7ff fe5b 	bl	1d64 <xputc>
    20ae:	e7ea      	b.n	2086 <xgets+0xe>
#endif
		}
	}
	buff[i] = 0;	/* Terminate with a \0 */
    20b0:	2300      	movs	r3, #0
    20b2:	5563      	strb	r3, [r4, r5]
#if _LINE_ECHO
#if !_LF_CRLF
		xputc('\r');
    20b4:	f7ff fe56 	bl	1d64 <xputc>
#endif
		xputc('\n');
    20b8:	200a      	movs	r0, #10
    20ba:	f7ff fe53 	bl	1d64 <xputc>
#endif
	return 1;
    20be:	2001      	movs	r0, #1
    20c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
}
    20c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    20c4:	10004910 	.word	0x10004910

000020c8 <xfgets>:
int xfgets (	/* 0:End of stream, 1:A line arrived */
	unsigned char (*func)(void),	/* Pointer to the input stream function */
	char* buff,	/* Pointer to the buffer */
	int len		/* Buffer length */
)
{
    20c8:	b538      	push	{r3, r4, r5, lr}
	unsigned char (*pf)(void);
	int n;


	pf = xfunc_in;			/* Save current input device */
    20ca:	4c04      	ldr	r4, [pc, #16]	; (20dc <xfgets+0x14>)
    20cc:	6825      	ldr	r5, [r4, #0]
	xfunc_in = func;		/* Switch input to specified device */
    20ce:	6020      	str	r0, [r4, #0]
	n = xgets(buff, len);	/* Get a line */
    20d0:	4608      	mov	r0, r1
    20d2:	4611      	mov	r1, r2
    20d4:	f7ff ffd0 	bl	2078 <xgets>
	xfunc_in = pf;			/* Restore input device */
    20d8:	6025      	str	r5, [r4, #0]

	return n;
}
    20da:	bd38      	pop	{r3, r4, r5, pc}
    20dc:	10004910 	.word	0x10004910

000020e0 <xatoi>:
{
	unsigned long val;
	unsigned char c, r, s = 0;


	*res = 0;
    20e0:	2300      	movs	r3, #0

int xatoi (			/* 0:Failed, 1:Successful */
	char **str,		/* Pointer to pointer to the string */
	long *res		/* Pointer to the valiable to store the value */
)
{
    20e2:	b570      	push	{r4, r5, r6, lr}
	unsigned long val;
	unsigned char c, r, s = 0;


	*res = 0;
    20e4:	600b      	str	r3, [r1, #0]

	while ((c = **str) == ' ') (*str)++;	/* Skip leading spaces */
    20e6:	e001      	b.n	20ec <xatoi+0xc>
    20e8:	3201      	adds	r2, #1
    20ea:	6002      	str	r2, [r0, #0]
    20ec:	6802      	ldr	r2, [r0, #0]
    20ee:	7813      	ldrb	r3, [r2, #0]
    20f0:	2b20      	cmp	r3, #32
    20f2:	d0f9      	beq.n	20e8 <xatoi+0x8>

	if (c == '-') {		/* negative? */
    20f4:	2b2d      	cmp	r3, #45	; 0x2d
    20f6:	d104      	bne.n	2102 <xatoi+0x22>
		s = 1;
		c = *(++(*str));
    20f8:	1c53      	adds	r3, r2, #1
    20fa:	6003      	str	r3, [r0, #0]
    20fc:	7853      	ldrb	r3, [r2, #1]
	*res = 0;

	while ((c = **str) == ' ') (*str)++;	/* Skip leading spaces */

	if (c == '-') {		/* negative? */
		s = 1;
    20fe:	2501      	movs	r5, #1
    2100:	e000      	b.n	2104 <xatoi+0x24>
	char **str,		/* Pointer to pointer to the string */
	long *res		/* Pointer to the valiable to store the value */
)
{
	unsigned long val;
	unsigned char c, r, s = 0;
    2102:	2500      	movs	r5, #0
	if (c == '-') {		/* negative? */
		s = 1;
		c = *(++(*str));
	}

	if (c == '0') {
    2104:	2b30      	cmp	r3, #48	; 0x30
    2106:	d11a      	bne.n	213e <xatoi+0x5e>
		c = *(++(*str));
    2108:	6803      	ldr	r3, [r0, #0]
    210a:	1c5a      	adds	r2, r3, #1
    210c:	6002      	str	r2, [r0, #0]
    210e:	785b      	ldrb	r3, [r3, #1]
		switch (c) {
    2110:	2b62      	cmp	r3, #98	; 0x62
    2112:	d006      	beq.n	2122 <xatoi+0x42>
    2114:	2b78      	cmp	r3, #120	; 0x78
    2116:	d109      	bne.n	212c <xatoi+0x4c>
		case 'x':		/* hexdecimal */
			r = 16; c = *(++(*str));
    2118:	1c53      	adds	r3, r2, #1
    211a:	6003      	str	r3, [r0, #0]
    211c:	7853      	ldrb	r3, [r2, #1]
    211e:	2410      	movs	r4, #16
			break;
    2120:	e013      	b.n	214a <xatoi+0x6a>
		case 'b':		/* binary */
			r = 2; c = *(++(*str));
    2122:	1c53      	adds	r3, r2, #1
    2124:	6003      	str	r3, [r0, #0]
    2126:	7853      	ldrb	r3, [r2, #1]
    2128:	2402      	movs	r4, #2
			break;
    212a:	e00e      	b.n	214a <xatoi+0x6a>
		default:
			if (c <= ' ') return 1;	/* single zero */
    212c:	2b20      	cmp	r3, #32
    212e:	d925      	bls.n	217c <xatoi+0x9c>
			if (c < '0' || c > '9') return 0;	/* invalid char */
    2130:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
    2134:	b2d2      	uxtb	r2, r2
    2136:	2a09      	cmp	r2, #9
    2138:	d822      	bhi.n	2180 <xatoi+0xa0>
			r = 8;		/* octal */
    213a:	2408      	movs	r4, #8
    213c:	e005      	b.n	214a <xatoi+0x6a>
		}
	} else {
		if (c < '0' || c > '9') return 0;	/* EOL or invalid char */
    213e:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
    2142:	b2d2      	uxtb	r2, r2
    2144:	2a09      	cmp	r2, #9
    2146:	d81b      	bhi.n	2180 <xatoi+0xa0>
		r = 10;			/* decimal */
    2148:	240a      	movs	r4, #10
	}

	val = 0;
    214a:	2200      	movs	r2, #0
	while (c > ' ') {
    214c:	e011      	b.n	2172 <xatoi+0x92>
		if (c >= 'a') c -= 0x20;
    214e:	2b60      	cmp	r3, #96	; 0x60
    2150:	d901      	bls.n	2156 <xatoi+0x76>
    2152:	3b20      	subs	r3, #32
    2154:	b2db      	uxtb	r3, r3
		c -= '0';
    2156:	3b30      	subs	r3, #48	; 0x30
    2158:	b2db      	uxtb	r3, r3
		if (c >= 17) {
    215a:	2b10      	cmp	r3, #16
    215c:	d901      	bls.n	2162 <xatoi+0x82>
			c -= 7;
    215e:	3b07      	subs	r3, #7
    2160:	b2db      	uxtb	r3, r3
			if (c <= 9) return 0;	/* invalid char */
		}
		if (c >= r) return 0;		/* invalid char for current radix */
    2162:	42a3      	cmp	r3, r4
    2164:	d20e      	bcs.n	2184 <xatoi+0xa4>
		val = val * r + c;
    2166:	fb04 3202 	mla	r2, r4, r2, r3
		c = *(++(*str));
    216a:	6803      	ldr	r3, [r0, #0]
    216c:	1c5e      	adds	r6, r3, #1
    216e:	6006      	str	r6, [r0, #0]
    2170:	785b      	ldrb	r3, [r3, #1]
		if (c < '0' || c > '9') return 0;	/* EOL or invalid char */
		r = 10;			/* decimal */
	}

	val = 0;
	while (c > ' ') {
    2172:	2b20      	cmp	r3, #32
    2174:	d8eb      	bhi.n	214e <xatoi+0x6e>
		}
		if (c >= r) return 0;		/* invalid char for current radix */
		val = val * r + c;
		c = *(++(*str));
	}
	if (s) val = 0 - val;			/* apply sign if needed */
    2176:	b105      	cbz	r5, 217a <xatoi+0x9a>
    2178:	4252      	negs	r2, r2

	*res = val;
    217a:	600a      	str	r2, [r1, #0]
			break;
		case 'b':		/* binary */
			r = 2; c = *(++(*str));
			break;
		default:
			if (c <= ' ') return 1;	/* single zero */
    217c:	2001      	movs	r0, #1
    217e:	bd70      	pop	{r4, r5, r6, pc}
			if (c < '0' || c > '9') return 0;	/* invalid char */
			r = 8;		/* octal */
		}
	} else {
		if (c < '0' || c > '9') return 0;	/* EOL or invalid char */
    2180:	2000      	movs	r0, #0
    2182:	bd70      	pop	{r4, r5, r6, pc}
		c -= '0';
		if (c >= 17) {
			c -= 7;
			if (c <= 9) return 0;	/* invalid char */
		}
		if (c >= r) return 0;		/* invalid char for current radix */
    2184:	2000      	movs	r0, #0
	}
	if (s) val = 0 - val;			/* apply sign if needed */

	*res = val;
	return 1;
}
    2186:	bd70      	pop	{r4, r5, r6, pc}

00002188 <xchg_spi>:
static
BYTE xchg_spi (
	BYTE dat	/* Data to send */
)
{
	SSPxDR = dat;
    2188:	4b05      	ldr	r3, [pc, #20]	; (21a0 <xchg_spi+0x18>)
    218a:	6018      	str	r0, [r3, #0]
	while (SSPxSR & 0x10) ;
    218c:	4b05      	ldr	r3, [pc, #20]	; (21a4 <xchg_spi+0x1c>)
    218e:	681b      	ldr	r3, [r3, #0]
    2190:	f013 0f10 	tst.w	r3, #16
    2194:	d1fa      	bne.n	218c <xchg_spi+0x4>
	return SSPxDR;
    2196:	4b02      	ldr	r3, [pc, #8]	; (21a0 <xchg_spi+0x18>)
    2198:	6818      	ldr	r0, [r3, #0]
}
    219a:	b2c0      	uxtb	r0, r0
    219c:	4770      	bx	lr
    219e:	bf00      	nop
    21a0:	40030008 	.word	0x40030008
    21a4:	4003000c 	.word	0x4003000c

000021a8 <wait_ready>:

static
int wait_ready (	/* 1:Ready, 0:Timeout */
	UINT wt			/* Timeout [ms] */
)
{
    21a8:	b510      	push	{r4, lr}
	BYTE d;


	Timer2 = wt;
    21aa:	4c08      	ldr	r4, [pc, #32]	; (21cc <wait_ready+0x24>)
    21ac:	6020      	str	r0, [r4, #0]
	do {
		d = xchg_spi(0xFF);
    21ae:	20ff      	movs	r0, #255	; 0xff
    21b0:	f7ff ffea 	bl	2188 <xchg_spi>

		/* This loop takes a time. Insert rot_rdq() here for multitask envilonment. */

	} while (d != 0xFF && Timer2);	/* Wait for card goes ready or timeout */
    21b4:	28ff      	cmp	r0, #255	; 0xff
    21b6:	d002      	beq.n	21be <wait_ready+0x16>
    21b8:	6823      	ldr	r3, [r4, #0]
    21ba:	2b00      	cmp	r3, #0
    21bc:	d1f7      	bne.n	21ae <wait_ready+0x6>

	return (d == 0xFF) ? 1 : 0;
}
    21be:	f1a0 03ff 	sub.w	r3, r0, #255	; 0xff
    21c2:	4258      	negs	r0, r3
    21c4:	eb40 0003 	adc.w	r0, r0, r3
    21c8:	bd10      	pop	{r4, pc}
    21ca:	bf00      	nop
    21cc:	10000120 	.word	0x10000120

000021d0 <deselect>:
/*-----------------------------------------------------------------------*/

static
void deselect (void)
{
	CS_HIGH();		/* CS = H */
    21d0:	4b02      	ldr	r3, [pc, #8]	; (21dc <deselect+0xc>)
    21d2:	2240      	movs	r2, #64	; 0x40
	xchg_spi(0xFF);	/* Dummy clock (force DO hi-z for multiple slave SPI) */
    21d4:	20ff      	movs	r0, #255	; 0xff
/*-----------------------------------------------------------------------*/

static
void deselect (void)
{
	CS_HIGH();		/* CS = H */
    21d6:	701a      	strb	r2, [r3, #0]
	xchg_spi(0xFF);	/* Dummy clock (force DO hi-z for multiple slave SPI) */
    21d8:	e7d6      	b.n	2188 <xchg_spi>
    21da:	bf00      	nop
    21dc:	2009c018 	.word	0x2009c018

000021e0 <select>:
/*-----------------------------------------------------------------------*/

static
int select (void)	/* 1:OK, 0:Timeout */
{
	CS_LOW();		/* CS = L */
    21e0:	4b09      	ldr	r3, [pc, #36]	; (2208 <select+0x28>)
    21e2:	2240      	movs	r2, #64	; 0x40
/* Select card and wait for ready                                        */
/*-----------------------------------------------------------------------*/

static
int select (void)	/* 1:OK, 0:Timeout */
{
    21e4:	b510      	push	{r4, lr}
	CS_LOW();		/* CS = L */
	xchg_spi(0xFF);	/* Dummy clock (force DO enabled) */
    21e6:	20ff      	movs	r0, #255	; 0xff
/*-----------------------------------------------------------------------*/

static
int select (void)	/* 1:OK, 0:Timeout */
{
	CS_LOW();		/* CS = L */
    21e8:	701a      	strb	r2, [r3, #0]
	xchg_spi(0xFF);	/* Dummy clock (force DO enabled) */
    21ea:	f7ff ffcd 	bl	2188 <xchg_spi>

	if (wait_ready(500)) return 1;	/* Leading busy check: Wait for card ready */
    21ee:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    21f2:	f7ff ffd9 	bl	21a8 <wait_ready>
    21f6:	4604      	mov	r4, r0
    21f8:	b918      	cbnz	r0, 2202 <select+0x22>

	deselect();		/* Timeout */
    21fa:	f7ff ffe9 	bl	21d0 <deselect>
	return 0;
    21fe:	4620      	mov	r0, r4
    2200:	bd10      	pop	{r4, pc}
int select (void)	/* 1:OK, 0:Timeout */
{
	CS_LOW();		/* CS = L */
	xchg_spi(0xFF);	/* Dummy clock (force DO enabled) */

	if (wait_ready(500)) return 1;	/* Leading busy check: Wait for card ready */
    2202:	2001      	movs	r0, #1

	deselect();		/* Timeout */
	return 0;
}
    2204:	bd10      	pop	{r4, pc}
    2206:	bf00      	nop
    2208:	2009c01c 	.word	0x2009c01c

0000220c <rcvr_datablock>:
static
int rcvr_datablock (	/* 1:OK, 0:Error */
	BYTE *buff,			/* Data buffer */
	UINT btr			/* Data block length (byte) */
)
{
    220c:	b570      	push	{r4, r5, r6, lr}
	BYTE token;


	Timer1 = 200;
    220e:	4e2c      	ldr	r6, [pc, #176]	; (22c0 <rcvr_datablock+0xb4>)
    2210:	23c8      	movs	r3, #200	; 0xc8
static
int rcvr_datablock (	/* 1:OK, 0:Error */
	BYTE *buff,			/* Data buffer */
	UINT btr			/* Data block length (byte) */
)
{
    2212:	4604      	mov	r4, r0
    2214:	460d      	mov	r5, r1
	BYTE token;


	Timer1 = 200;
    2216:	6073      	str	r3, [r6, #4]
	do {							/* Wait for DataStart token in timeout of 200ms */
		token = xchg_spi(0xFF);
    2218:	20ff      	movs	r0, #255	; 0xff
    221a:	f7ff ffb5 	bl	2188 <xchg_spi>

		/* This loop will take a time. Insert rot_rdq() here for multitask envilonment. */

	} while ((token == 0xFF) && Timer1);
    221e:	28ff      	cmp	r0, #255	; 0xff
    2220:	d103      	bne.n	222a <rcvr_datablock+0x1e>
    2222:	6870      	ldr	r0, [r6, #4]
    2224:	2800      	cmp	r0, #0
    2226:	d1f7      	bne.n	2218 <rcvr_datablock+0xc>
    2228:	bd70      	pop	{r4, r5, r6, pc}
	if(token != 0xFE) return 0;		/* Function fails if invalid DataStart token or timeout */
    222a:	28fe      	cmp	r0, #254	; 0xfe
    222c:	d146      	bne.n	22bc <rcvr_datablock+0xb0>
{
	UINT n;
	WORD d;


	SSPxCR0 |= 0x000F;	/* Select 16-bit mode */
    222e:	4b25      	ldr	r3, [pc, #148]	; (22c4 <rcvr_datablock+0xb8>)

	for (n = 0; n < 8; n++) {		/* Push 8 frames into FIFO  */
		SSPxDR = 0xFFFF;
	}
	btr -= 16;
    2230:	3d10      	subs	r5, #16
{
	UINT n;
	WORD d;


	SSPxCR0 |= 0x000F;	/* Select 16-bit mode */
    2232:	681a      	ldr	r2, [r3, #0]
    2234:	f042 020f 	orr.w	r2, r2, #15
    2238:	601a      	str	r2, [r3, #0]

	for (n = 0; n < 8; n++) {		/* Push 8 frames into FIFO  */
		SSPxDR = 0xFFFF;
    223a:	f64f 72ff 	movw	r2, #65535	; 0xffff
    223e:	609a      	str	r2, [r3, #8]
    2240:	609a      	str	r2, [r3, #8]
    2242:	609a      	str	r2, [r3, #8]
    2244:	609a      	str	r2, [r3, #8]
    2246:	609a      	str	r2, [r3, #8]
    2248:	609a      	str	r2, [r3, #8]
    224a:	609a      	str	r2, [r3, #8]
    224c:	609a      	str	r2, [r3, #8]
	}
	btr -= 16;
    224e:	462a      	mov	r2, r5
    2250:	4623      	mov	r3, r4
    2252:	e00f      	b.n	2274 <rcvr_datablock+0x68>

	while (btr >= 2) {				/* Receive the data block into buffer */
		btr -= 2;
    2254:	3a02      	subs	r2, #2
		while (!(SSPxSR & _BV(2))) ;	/* Wait for any data in receive FIFO */
    2256:	491c      	ldr	r1, [pc, #112]	; (22c8 <rcvr_datablock+0xbc>)
    2258:	6809      	ldr	r1, [r1, #0]
    225a:	f011 0f04 	tst.w	r1, #4
    225e:	d0fa      	beq.n	2256 <rcvr_datablock+0x4a>
		d = SSPxDR;
    2260:	481a      	ldr	r0, [pc, #104]	; (22cc <rcvr_datablock+0xc0>)
		SSPxDR = 0xFFFF;
    2262:	f64f 76ff 	movw	r6, #65535	; 0xffff
	btr -= 16;

	while (btr >= 2) {				/* Receive the data block into buffer */
		btr -= 2;
		while (!(SSPxSR & _BV(2))) ;	/* Wait for any data in receive FIFO */
		d = SSPxDR;
    2266:	6801      	ldr	r1, [r0, #0]
		SSPxDR = 0xFFFF;
    2268:	6006      	str	r6, [r0, #0]
	btr -= 16;

	while (btr >= 2) {				/* Receive the data block into buffer */
		btr -= 2;
		while (!(SSPxSR & _BV(2))) ;	/* Wait for any data in receive FIFO */
		d = SSPxDR;
    226a:	b289      	uxth	r1, r1
		SSPxDR = 0xFFFF;
		*buff++ = d >> 8;
    226c:	0a08      	lsrs	r0, r1, #8
    226e:	7018      	strb	r0, [r3, #0]
		*buff++ = d;
    2270:	7059      	strb	r1, [r3, #1]
/*-----------------------------------------------------------------------*/
/* Receive a data packet from the MMC                                    */
/*-----------------------------------------------------------------------*/

static
int rcvr_datablock (	/* 1:OK, 0:Error */
    2272:	3302      	adds	r3, #2
	for (n = 0; n < 8; n++) {		/* Push 8 frames into FIFO  */
		SSPxDR = 0xFFFF;
	}
	btr -= 16;

	while (btr >= 2) {				/* Receive the data block into buffer */
    2274:	2a01      	cmp	r2, #1
    2276:	d8ed      	bhi.n	2254 <rcvr_datablock+0x48>
/*-----------------------------------------------------------------------*/
/* Receive a data packet from the MMC                                    */
/*-----------------------------------------------------------------------*/

static
int rcvr_datablock (	/* 1:OK, 0:Error */
    2278:	f025 0501 	bic.w	r5, r5, #1
	for (n = 0; n < 8; n++) {		/* Push 8 frames into FIFO  */
		SSPxDR = 0xFFFF;
	}
	btr -= 16;

	while (btr >= 2) {				/* Receive the data block into buffer */
    227c:	1964      	adds	r4, r4, r5
/*-----------------------------------------------------------------------*/
/* Receive a data packet from the MMC                                    */
/*-----------------------------------------------------------------------*/

static
int rcvr_datablock (	/* 1:OK, 0:Error */
    227e:	2300      	movs	r3, #0
		*buff++ = d >> 8;
		*buff++ = d;
	}

	for (n = 0; n < 8; n++) {		/* Pop remaining frames from FIFO */
		while (!(SSPxSR & _BV(2))) ;
    2280:	4a11      	ldr	r2, [pc, #68]	; (22c8 <rcvr_datablock+0xbc>)
    2282:	6812      	ldr	r2, [r2, #0]
    2284:	f012 0f04 	tst.w	r2, #4
    2288:	d0fa      	beq.n	2280 <rcvr_datablock+0x74>
		d = SSPxDR;
    228a:	4a10      	ldr	r2, [pc, #64]	; (22cc <rcvr_datablock+0xc0>)
    228c:	6812      	ldr	r2, [r2, #0]
    228e:	b292      	uxth	r2, r2
		*buff++ = d >> 8;
    2290:	0a11      	lsrs	r1, r2, #8
    2292:	54e1      	strb	r1, [r4, r3]
/*-----------------------------------------------------------------------*/
/* Receive a data packet from the MMC                                    */
/*-----------------------------------------------------------------------*/

static
int rcvr_datablock (	/* 1:OK, 0:Error */
    2294:	18e1      	adds	r1, r4, r3

	for (n = 0; n < 8; n++) {		/* Pop remaining frames from FIFO */
		while (!(SSPxSR & _BV(2))) ;
		d = SSPxDR;
		*buff++ = d >> 8;
		*buff++ = d;
    2296:	3302      	adds	r3, #2
		SSPxDR = 0xFFFF;
		*buff++ = d >> 8;
		*buff++ = d;
	}

	for (n = 0; n < 8; n++) {		/* Pop remaining frames from FIFO */
    2298:	2b10      	cmp	r3, #16
		while (!(SSPxSR & _BV(2))) ;
		d = SSPxDR;
		*buff++ = d >> 8;
		*buff++ = d;
    229a:	704a      	strb	r2, [r1, #1]
		SSPxDR = 0xFFFF;
		*buff++ = d >> 8;
		*buff++ = d;
	}

	for (n = 0; n < 8; n++) {		/* Pop remaining frames from FIFO */
    229c:	d1f0      	bne.n	2280 <rcvr_datablock+0x74>
		d = SSPxDR;
		*buff++ = d >> 8;
		*buff++ = d;
	}

	SSPxCR0 &= 0xFFF7;				/* Select 8-bit mode */
    229e:	4a09      	ldr	r2, [pc, #36]	; (22c4 <rcvr_datablock+0xb8>)
    22a0:	f64f 73f7 	movw	r3, #65527	; 0xfff7
    22a4:	6811      	ldr	r1, [r2, #0]

	} while ((token == 0xFF) && Timer1);
	if(token != 0xFE) return 0;		/* Function fails if invalid DataStart token or timeout */

	rcvr_spi_multi(buff, btr);		/* Store trailing data to the buffer */
	xchg_spi(0xFF); xchg_spi(0xFF);	/* Discard CRC */
    22a6:	20ff      	movs	r0, #255	; 0xff
		d = SSPxDR;
		*buff++ = d >> 8;
		*buff++ = d;
	}

	SSPxCR0 &= 0xFFF7;				/* Select 8-bit mode */
    22a8:	ea01 0303 	and.w	r3, r1, r3
    22ac:	6013      	str	r3, [r2, #0]

	} while ((token == 0xFF) && Timer1);
	if(token != 0xFE) return 0;		/* Function fails if invalid DataStart token or timeout */

	rcvr_spi_multi(buff, btr);		/* Store trailing data to the buffer */
	xchg_spi(0xFF); xchg_spi(0xFF);	/* Discard CRC */
    22ae:	f7ff ff6b 	bl	2188 <xchg_spi>
    22b2:	20ff      	movs	r0, #255	; 0xff
    22b4:	f7ff ff68 	bl	2188 <xchg_spi>

	return 1;						/* Function succeeded */
    22b8:	2001      	movs	r0, #1
    22ba:	bd70      	pop	{r4, r5, r6, pc}
		token = xchg_spi(0xFF);

		/* This loop will take a time. Insert rot_rdq() here for multitask envilonment. */

	} while ((token == 0xFF) && Timer1);
	if(token != 0xFE) return 0;		/* Function fails if invalid DataStart token or timeout */
    22bc:	2000      	movs	r0, #0

	rcvr_spi_multi(buff, btr);		/* Store trailing data to the buffer */
	xchg_spi(0xFF); xchg_spi(0xFF);	/* Discard CRC */

	return 1;						/* Function succeeded */
}
    22be:	bd70      	pop	{r4, r5, r6, pc}
    22c0:	10000120 	.word	0x10000120
    22c4:	40030000 	.word	0x40030000
    22c8:	4003000c 	.word	0x4003000c
    22cc:	40030008 	.word	0x40030008

000022d0 <send_cmd>:
)
{
	BYTE n, res;


	if (cmd & 0x80) {	/* Send a CMD55 prior to ACMD<n> */
    22d0:	f010 0f80 	tst.w	r0, #128	; 0x80
static
BYTE send_cmd (		/* Return value: R1 resp (bit7==1:Failed to send) */
	BYTE cmd,		/* Command index */
	DWORD arg		/* Argument */
)
{
    22d4:	b538      	push	{r3, r4, r5, lr}
    22d6:	4604      	mov	r4, r0
    22d8:	460d      	mov	r5, r1
	BYTE n, res;


	if (cmd & 0x80) {	/* Send a CMD55 prior to ACMD<n> */
    22da:	d007      	beq.n	22ec <send_cmd+0x1c>
		cmd &= 0x7F;
		res = send_cmd(CMD55, 0);
    22dc:	2037      	movs	r0, #55	; 0x37
    22de:	2100      	movs	r1, #0
    22e0:	f7ff fff6 	bl	22d0 <send_cmd>
		if (res > 1) return res;
    22e4:	2801      	cmp	r0, #1
    22e6:	d835      	bhi.n	2354 <send_cmd+0x84>
{
	BYTE n, res;


	if (cmd & 0x80) {	/* Send a CMD55 prior to ACMD<n> */
		cmd &= 0x7F;
    22e8:	f004 047f 	and.w	r4, r4, #127	; 0x7f
		res = send_cmd(CMD55, 0);
		if (res > 1) return res;
	}

	/* Select the card and wait for ready except to stop multiple block read */
	if (cmd != CMD12) {
    22ec:	2c0c      	cmp	r4, #12
    22ee:	d004      	beq.n	22fa <send_cmd+0x2a>
		deselect();
    22f0:	f7ff ff6e 	bl	21d0 <deselect>
		if (!select()) return 0xFF;
    22f4:	f7ff ff74 	bl	21e0 <select>
    22f8:	b358      	cbz	r0, 2352 <send_cmd+0x82>
	}

	/* Send command packet */
	xchg_spi(0x40 | cmd);				/* Start + command index */
    22fa:	f044 0040 	orr.w	r0, r4, #64	; 0x40
    22fe:	f7ff ff43 	bl	2188 <xchg_spi>
	xchg_spi((BYTE)(arg >> 24));		/* Argument[31..24] */
    2302:	0e28      	lsrs	r0, r5, #24
    2304:	f7ff ff40 	bl	2188 <xchg_spi>
	xchg_spi((BYTE)(arg >> 16));		/* Argument[23..16] */
    2308:	0c28      	lsrs	r0, r5, #16
    230a:	b2c0      	uxtb	r0, r0
    230c:	f7ff ff3c 	bl	2188 <xchg_spi>
	xchg_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
    2310:	0a28      	lsrs	r0, r5, #8
    2312:	b2c0      	uxtb	r0, r0
    2314:	f7ff ff38 	bl	2188 <xchg_spi>
	xchg_spi((BYTE)arg);				/* Argument[7..0] */
    2318:	b2e8      	uxtb	r0, r5
    231a:	f7ff ff35 	bl	2188 <xchg_spi>
	n = 0x01;							/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) */
    231e:	b124      	cbz	r4, 232a <send_cmd+0x5a>
	xchg_spi(0x40 | cmd);				/* Start + command index */
	xchg_spi((BYTE)(arg >> 24));		/* Argument[31..24] */
	xchg_spi((BYTE)(arg >> 16));		/* Argument[23..16] */
	xchg_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
	xchg_spi((BYTE)arg);				/* Argument[7..0] */
	n = 0x01;							/* Dummy CRC + Stop */
    2320:	2c08      	cmp	r4, #8
    2322:	bf0c      	ite	eq
    2324:	2087      	moveq	r0, #135	; 0x87
    2326:	2001      	movne	r0, #1
    2328:	e000      	b.n	232c <send_cmd+0x5c>
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) */
    232a:	2095      	movs	r0, #149	; 0x95
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) */
	xchg_spi(n);
    232c:	f7ff ff2c 	bl	2188 <xchg_spi>

	/* Receive command resp */
	if (cmd == CMD12) xchg_spi(0xFF);	/* Diacard following one byte when CMD12 */
    2330:	2c0c      	cmp	r4, #12
    2332:	d102      	bne.n	233a <send_cmd+0x6a>
    2334:	20ff      	movs	r0, #255	; 0xff
    2336:	f7ff ff27 	bl	2188 <xchg_spi>
	xchg_spi((BYTE)(arg >> 16));		/* Argument[23..16] */
	xchg_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
	xchg_spi((BYTE)arg);				/* Argument[7..0] */
	n = 0x01;							/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) */
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) */
    233a:	240a      	movs	r4, #10

	/* Receive command resp */
	if (cmd == CMD12) xchg_spi(0xFF);	/* Diacard following one byte when CMD12 */
	n = 10;								/* Wait for response (10 bytes max) */
	do
		res = xchg_spi(0xFF);
    233c:	20ff      	movs	r0, #255	; 0xff
    233e:	f7ff ff23 	bl	2188 <xchg_spi>
	while ((res & 0x80) && --n);
    2342:	f010 0f80 	tst.w	r0, #128	; 0x80
    2346:	d005      	beq.n	2354 <send_cmd+0x84>
    2348:	3c01      	subs	r4, #1
    234a:	b2e4      	uxtb	r4, r4
    234c:	2c00      	cmp	r4, #0
    234e:	d1f5      	bne.n	233c <send_cmd+0x6c>
    2350:	bd38      	pop	{r3, r4, r5, pc}
	}

	/* Select the card and wait for ready except to stop multiple block read */
	if (cmd != CMD12) {
		deselect();
		if (!select()) return 0xFF;
    2352:	20ff      	movs	r0, #255	; 0xff
	do
		res = xchg_spi(0xFF);
	while ((res & 0x80) && --n);

	return res;							/* Return received response */
}
    2354:	bd38      	pop	{r3, r4, r5, pc}

00002356 <xmit_datablock>:
static
int xmit_datablock (	/* 1:OK, 0:Failed */
	const BYTE *buff,	/* Ponter to 512 byte data to be sent */
	BYTE token			/* Token */
)
{
    2356:	b538      	push	{r3, r4, r5, lr}
    2358:	4604      	mov	r4, r0
	BYTE resp;


	if (!wait_ready(500)) return 0;		/* Leading busy check: Wait for card ready to accept data block */
    235a:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
static
int xmit_datablock (	/* 1:OK, 0:Failed */
	const BYTE *buff,	/* Ponter to 512 byte data to be sent */
	BYTE token			/* Token */
)
{
    235e:	460d      	mov	r5, r1
	BYTE resp;


	if (!wait_ready(500)) return 0;		/* Leading busy check: Wait for card ready to accept data block */
    2360:	f7ff ff22 	bl	21a8 <wait_ready>
    2364:	2800      	cmp	r0, #0
    2366:	d049      	beq.n	23fc <xmit_datablock+0xa6>

	xchg_spi(token);					/* Send token */
    2368:	4628      	mov	r0, r5
    236a:	f7ff ff0d 	bl	2188 <xchg_spi>
	if (token == 0xFD) return 1;		/* Do not send data if token is StopTran */
    236e:	2dfd      	cmp	r5, #253	; 0xfd
    2370:	d043      	beq.n	23fa <xmit_datablock+0xa4>
{
	UINT n;
	WORD d;


	SSPxCR0 |= 0x000F;			/* Select 16-bit mode */
    2372:	4b23      	ldr	r3, [pc, #140]	; (2400 <xmit_datablock+0xaa>)
    2374:	681a      	ldr	r2, [r3, #0]
    2376:	f042 020f 	orr.w	r2, r2, #15
    237a:	601a      	str	r2, [r3, #0]
    237c:	2300      	movs	r3, #0
/* Send a data packet to the MMC                                         */
/*-----------------------------------------------------------------------*/

#if FF_FS_READONLY == 0
static
int xmit_datablock (	/* 1:OK, 0:Failed */
    237e:	18e2      	adds	r2, r4, r3

	SSPxCR0 |= 0x000F;			/* Select 16-bit mode */

	for (n = 0; n < 8; n++) {	/* Push 8 frames into pipeline  */
		d = *buff++;
		d = d << 8 | *buff++;
    2380:	5ce1      	ldrb	r1, [r4, r3]
    2382:	7852      	ldrb	r2, [r2, #1]
		SSPxDR = d;
    2384:	3302      	adds	r3, #2
    2386:	ea42 2101 	orr.w	r1, r2, r1, lsl #8
    238a:	4a1e      	ldr	r2, [pc, #120]	; (2404 <xmit_datablock+0xae>)
	WORD d;


	SSPxCR0 |= 0x000F;			/* Select 16-bit mode */

	for (n = 0; n < 8; n++) {	/* Push 8 frames into pipeline  */
    238c:	2b10      	cmp	r3, #16
		d = *buff++;
		d = d << 8 | *buff++;
		SSPxDR = d;
    238e:	6011      	str	r1, [r2, #0]
	WORD d;


	SSPxCR0 |= 0x000F;			/* Select 16-bit mode */

	for (n = 0; n < 8; n++) {	/* Push 8 frames into pipeline  */
    2390:	d1f5      	bne.n	237e <xmit_datablock+0x28>
/* Send a data packet to the MMC                                         */
/*-----------------------------------------------------------------------*/

#if FF_FS_READONLY == 0
static
int xmit_datablock (	/* 1:OK, 0:Failed */
    2392:	f504 72f8 	add.w	r2, r4, #496	; 0x1f0
	btx -= 16;

	while (btx >= 2) {			/* Transmit data block */
		btx -= 2;
		d = *buff++;
		d = d << 8 | *buff++;
    2396:	7c21      	ldrb	r1, [r4, #16]
    2398:	7c63      	ldrb	r3, [r4, #17]
    239a:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
		while (!(SSPxSR & _BV(2))) ;	/* Wait for any data in receive FIFO */
    239e:	4b1a      	ldr	r3, [pc, #104]	; (2408 <xmit_datablock+0xb2>)
    23a0:	681b      	ldr	r3, [r3, #0]
    23a2:	f013 0f04 	tst.w	r3, #4
    23a6:	d0fa      	beq.n	239e <xmit_datablock+0x48>
		SSPxDR; SSPxDR = d;
    23a8:	4b16      	ldr	r3, [pc, #88]	; (2404 <xmit_datablock+0xae>)
    23aa:	3402      	adds	r4, #2
		d = d << 8 | *buff++;
		SSPxDR = d;
	}
	btx -= 16;

	while (btx >= 2) {			/* Transmit data block */
    23ac:	4294      	cmp	r4, r2
		btx -= 2;
		d = *buff++;
		d = d << 8 | *buff++;
		while (!(SSPxSR & _BV(2))) ;	/* Wait for any data in receive FIFO */
		SSPxDR; SSPxDR = d;
    23ae:	6818      	ldr	r0, [r3, #0]
    23b0:	6019      	str	r1, [r3, #0]
		d = d << 8 | *buff++;
		SSPxDR = d;
	}
	btx -= 16;

	while (btx >= 2) {			/* Transmit data block */
    23b2:	d1f0      	bne.n	2396 <xmit_datablock+0x40>
    23b4:	2300      	movs	r3, #0
		while (!(SSPxSR & _BV(2))) ;	/* Wait for any data in receive FIFO */
		SSPxDR; SSPxDR = d;
	}

	for (n = 0; n < 8; n++) {	/* Flush pipeline */
		while (!(SSPxSR & _BV(2))) ;
    23b6:	4a14      	ldr	r2, [pc, #80]	; (2408 <xmit_datablock+0xb2>)
    23b8:	6812      	ldr	r2, [r2, #0]
    23ba:	f012 0f04 	tst.w	r2, #4
    23be:	d0fa      	beq.n	23b6 <xmit_datablock+0x60>
		SSPxDR;
    23c0:	4a10      	ldr	r2, [pc, #64]	; (2404 <xmit_datablock+0xae>)
		d = d << 8 | *buff++;
		while (!(SSPxSR & _BV(2))) ;	/* Wait for any data in receive FIFO */
		SSPxDR; SSPxDR = d;
	}

	for (n = 0; n < 8; n++) {	/* Flush pipeline */
    23c2:	3301      	adds	r3, #1
    23c4:	2b08      	cmp	r3, #8
		while (!(SSPxSR & _BV(2))) ;
		SSPxDR;
    23c6:	6812      	ldr	r2, [r2, #0]
		d = d << 8 | *buff++;
		while (!(SSPxSR & _BV(2))) ;	/* Wait for any data in receive FIFO */
		SSPxDR; SSPxDR = d;
	}

	for (n = 0; n < 8; n++) {	/* Flush pipeline */
    23c8:	d1f5      	bne.n	23b6 <xmit_datablock+0x60>
		while (!(SSPxSR & _BV(2))) ;
		SSPxDR;
	}

	SSPxCR0 &= 0xFFF7;			/* Select 8-bit mode */
    23ca:	4a0d      	ldr	r2, [pc, #52]	; (2400 <xmit_datablock+0xaa>)
    23cc:	f64f 73f7 	movw	r3, #65527	; 0xfff7
    23d0:	6811      	ldr	r1, [r2, #0]

	xchg_spi(token);					/* Send token */
	if (token == 0xFD) return 1;		/* Do not send data if token is StopTran */

	xmit_spi_multi(buff, 512);			/* Data */
	xchg_spi(0xFF); xchg_spi(0xFF);		/* Dummy CRC */
    23d2:	20ff      	movs	r0, #255	; 0xff
	for (n = 0; n < 8; n++) {	/* Flush pipeline */
		while (!(SSPxSR & _BV(2))) ;
		SSPxDR;
	}

	SSPxCR0 &= 0xFFF7;			/* Select 8-bit mode */
    23d4:	ea01 0303 	and.w	r3, r1, r3
    23d8:	6013      	str	r3, [r2, #0]

	xchg_spi(token);					/* Send token */
	if (token == 0xFD) return 1;		/* Do not send data if token is StopTran */

	xmit_spi_multi(buff, 512);			/* Data */
	xchg_spi(0xFF); xchg_spi(0xFF);		/* Dummy CRC */
    23da:	f7ff fed5 	bl	2188 <xchg_spi>
    23de:	20ff      	movs	r0, #255	; 0xff
    23e0:	f7ff fed2 	bl	2188 <xchg_spi>

	resp = xchg_spi(0xFF);				/* Receive data resp */
    23e4:	20ff      	movs	r0, #255	; 0xff
    23e6:	f7ff fecf 	bl	2188 <xchg_spi>

	return (resp & 0x1F) == 0x05 ? 1 : 0;	/* Data was accepted or not */
    23ea:	f000 001f 	and.w	r0, r0, #31
    23ee:	f1a0 0205 	sub.w	r2, r0, #5
    23f2:	4250      	negs	r0, r2
    23f4:	eb40 0002 	adc.w	r0, r0, r2
    23f8:	bd38      	pop	{r3, r4, r5, pc}


	if (!wait_ready(500)) return 0;		/* Leading busy check: Wait for card ready to accept data block */

	xchg_spi(token);					/* Send token */
	if (token == 0xFD) return 1;		/* Do not send data if token is StopTran */
    23fa:	2001      	movs	r0, #1
	resp = xchg_spi(0xFF);				/* Receive data resp */

	return (resp & 0x1F) == 0x05 ? 1 : 0;	/* Data was accepted or not */

	/* Busy check is done at next transmission */
}
    23fc:	bd38      	pop	{r3, r4, r5, pc}
    23fe:	bf00      	nop
    2400:	40030000 	.word	0x40030000
    2404:	40030008 	.word	0x40030008
    2408:	4003000c 	.word	0x4003000c

0000240c <disk_initialize>:
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
	BYTE drv		/* Physical drive number (0) */
)
{
    240c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	BYTE n, cmd, ty, ocr[4];


	if (drv) return STA_NOINIT;			/* Supports only drive 0 */
    240e:	2800      	cmp	r0, #0
    2410:	f040 80c6 	bne.w	25a0 <disk_initialize+0x194>
/*-----------------------------------------------------------------------*/

static
void power_on (void)	/* Enable SSP module and attach it to I/O pads */
{
	__set_PCONP(PCSSPx, 1);	/* Enable SSP module */
    2414:	4b63      	ldr	r3, [pc, #396]	; (25a4 <disk_initialize+0x198>)
	__set_PCLKSEL(PCLKSSPx, PCLKDIV_SSP);	/* Select PCLK frequency for SSP */
	SSPxCPSR = 2;			/* CPSDVSR=2 */
	SSPxCR0 = 0x0007;		/* Set mode: SPI mode 0, 8-bit */
    2416:	2107      	movs	r1, #7
/*-----------------------------------------------------------------------*/

static
void power_on (void)	/* Enable SSP module and attach it to I/O pads */
{
	__set_PCONP(PCSSPx, 1);	/* Enable SSP module */
    2418:	681a      	ldr	r2, [r3, #0]
	SSPxCR0 = 0x0007;		/* Set mode: SPI mode 0, 8-bit */
	SSPxCR1 = 0x2;			/* Enable SSP with Master */
	ATTACH_SSP();			/* Attach SSP module to I/O pads */
	CS_HIGH();				/* Set CS# high */

	for (Timer1 = 10; Timer1; ) ;	/* 10ms */
    241a:	4d63      	ldr	r5, [pc, #396]	; (25a8 <disk_initialize+0x19c>)
/*-----------------------------------------------------------------------*/

static
void power_on (void)	/* Enable SSP module and attach it to I/O pads */
{
	__set_PCONP(PCSSPx, 1);	/* Enable SSP module */
    241c:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    2420:	601a      	str	r2, [r3, #0]
	__set_PCLKSEL(PCLKSSPx, PCLKDIV_SSP);	/* Select PCLK frequency for SSP */
    2422:	f8d3 20e4 	ldr.w	r2, [r3, #228]	; 0xe4
    2426:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
    242a:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
    242e:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
	SSPxCPSR = 2;			/* CPSDVSR=2 */
    2432:	4a5e      	ldr	r2, [pc, #376]	; (25ac <disk_initialize+0x1a0>)
    2434:	2302      	movs	r3, #2
    2436:	6013      	str	r3, [r2, #0]
	SSPxCR0 = 0x0007;		/* Set mode: SPI mode 0, 8-bit */
    2438:	f842 1c10 	str.w	r1, [r2, #-16]
	SSPxCR1 = 0x2;			/* Enable SSP with Master */
    243c:	f842 3c0c 	str.w	r3, [r2, #-12]
	ATTACH_SSP();			/* Attach SSP module to I/O pads */
    2440:	4b5b      	ldr	r3, [pc, #364]	; (25b0 <disk_initialize+0x1a4>)
    2442:	681a      	ldr	r2, [r3, #0]
    2444:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
    2448:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
    244c:	601a      	str	r2, [r3, #0]
    244e:	681a      	ldr	r2, [r3, #0]
    2450:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
    2454:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
    2458:	601a      	str	r2, [r3, #0]
    245a:	681a      	ldr	r2, [r3, #0]
    245c:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
    2460:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
    2464:	601a      	str	r2, [r3, #0]
    2466:	4b53      	ldr	r3, [pc, #332]	; (25b4 <disk_initialize+0x1a8>)
    2468:	681a      	ldr	r2, [r3, #0]
    246a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    246e:	601a      	str	r2, [r3, #0]
	CS_HIGH();				/* Set CS# high */
    2470:	2240      	movs	r2, #64	; 0x40
    2472:	761a      	strb	r2, [r3, #24]

	for (Timer1 = 10; Timer1; ) ;	/* 10ms */
    2474:	230a      	movs	r3, #10
    2476:	606b      	str	r3, [r5, #4]
    2478:	686b      	ldr	r3, [r5, #4]
    247a:	2b00      	cmp	r3, #0
    247c:	d1fc      	bne.n	2478 <disk_initialize+0x6c>


	if (drv) return STA_NOINIT;			/* Supports only drive 0 */
	power_on();							/* Initialize SPI */

	if (Stat & STA_NODISK) return Stat;	/* Is a card existing in the soket? */
    247e:	4b4e      	ldr	r3, [pc, #312]	; (25b8 <disk_initialize+0x1ac>)
    2480:	781a      	ldrb	r2, [r3, #0]
    2482:	461e      	mov	r6, r3
    2484:	f012 0f02 	tst.w	r2, #2
    2488:	d001      	beq.n	248e <disk_initialize+0x82>
    248a:	7818      	ldrb	r0, [r3, #0]
    248c:	e089      	b.n	25a2 <disk_initialize+0x196>

	FCLK_SLOW();
    248e:	4b4b      	ldr	r3, [pc, #300]	; (25bc <disk_initialize+0x1b0>)
    2490:	240a      	movs	r4, #10
    2492:	681a      	ldr	r2, [r3, #0]
    2494:	f002 02ff 	and.w	r2, r2, #255	; 0xff
    2498:	f442 5274 	orr.w	r2, r2, #15616	; 0x3d00
    249c:	601a      	str	r2, [r3, #0]
	for (n = 10; n; n--) xchg_spi(0xFF);	/* Send 80 dummy clocks */
    249e:	3c01      	subs	r4, #1
    24a0:	20ff      	movs	r0, #255	; 0xff
    24a2:	b2e4      	uxtb	r4, r4
    24a4:	f7ff fe70 	bl	2188 <xchg_spi>
    24a8:	2c00      	cmp	r4, #0
    24aa:	d1f8      	bne.n	249e <disk_initialize+0x92>

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Put the card SPI state */
    24ac:	4620      	mov	r0, r4
    24ae:	4621      	mov	r1, r4
    24b0:	f7ff ff0e 	bl	22d0 <send_cmd>
    24b4:	2801      	cmp	r0, #1
    24b6:	4607      	mov	r7, r0
    24b8:	d15d      	bne.n	2576 <disk_initialize+0x16a>
		Timer1 = 1000;						/* Initialization timeout = 1 sec */
    24ba:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* Is the catd SDv2? */
    24be:	2008      	movs	r0, #8
    24c0:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
	FCLK_SLOW();
	for (n = 10; n; n--) xchg_spi(0xFF);	/* Send 80 dummy clocks */

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Put the card SPI state */
		Timer1 = 1000;						/* Initialization timeout = 1 sec */
    24c4:	606b      	str	r3, [r5, #4]
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* Is the catd SDv2? */
    24c6:	f7ff ff03 	bl	22d0 <send_cmd>
    24ca:	2801      	cmp	r0, #1
    24cc:	d133      	bne.n	2536 <disk_initialize+0x12a>
			for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);	/* Get 32 bit return value of R7 resp */
    24ce:	20ff      	movs	r0, #255	; 0xff
    24d0:	f7ff fe5a 	bl	2188 <xchg_spi>
    24d4:	ab01      	add	r3, sp, #4
    24d6:	5518      	strb	r0, [r3, r4]
    24d8:	3401      	adds	r4, #1
    24da:	2c04      	cmp	r4, #4
    24dc:	d1f7      	bne.n	24ce <disk_initialize+0xc2>
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* Does the card support 2.7-3.6V? */
    24de:	f89d 3006 	ldrb.w	r3, [sp, #6]
    24e2:	2b01      	cmp	r3, #1
    24e4:	d144      	bne.n	2570 <disk_initialize+0x164>
    24e6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    24ea:	2baa      	cmp	r3, #170	; 0xaa
    24ec:	d140      	bne.n	2570 <disk_initialize+0x164>
				while (Timer1 && send_cmd(ACMD41, 1UL << 30)) ;	/* Wait for end of initialization with ACMD41(HCS) */
    24ee:	686b      	ldr	r3, [r5, #4]
    24f0:	b133      	cbz	r3, 2500 <disk_initialize+0xf4>
    24f2:	20a9      	movs	r0, #169	; 0xa9
    24f4:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    24f8:	f7ff feea 	bl	22d0 <send_cmd>
    24fc:	2800      	cmp	r0, #0
    24fe:	d1f6      	bne.n	24ee <disk_initialize+0xe2>
				if (Timer1 && send_cmd(CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
    2500:	686c      	ldr	r4, [r5, #4]
    2502:	2c00      	cmp	r4, #0
    2504:	d037      	beq.n	2576 <disk_initialize+0x16a>
    2506:	203a      	movs	r0, #58	; 0x3a
    2508:	2100      	movs	r1, #0
    250a:	f7ff fee1 	bl	22d0 <send_cmd>
    250e:	2800      	cmp	r0, #0
    2510:	d12e      	bne.n	2570 <disk_initialize+0x164>
    2512:	4604      	mov	r4, r0
					for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);
    2514:	20ff      	movs	r0, #255	; 0xff
    2516:	f7ff fe37 	bl	2188 <xchg_spi>
    251a:	ab01      	add	r3, sp, #4
    251c:	5518      	strb	r0, [r3, r4]
    251e:	3401      	adds	r4, #1
    2520:	2c04      	cmp	r4, #4
    2522:	d1f7      	bne.n	2514 <disk_initialize+0x108>
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* Check if the card is SDv2 */
    2524:	f89d 4004 	ldrb.w	r4, [sp, #4]
    2528:	f004 0440 	and.w	r4, r4, #64	; 0x40
    252c:	2c00      	cmp	r4, #0
    252e:	bf0c      	ite	eq
    2530:	2404      	moveq	r4, #4
    2532:	240c      	movne	r4, #12
    2534:	e01f      	b.n	2576 <disk_initialize+0x16a>
				}
			}
		} else {	/* Not an SDv2 card */
			if (send_cmd(ACMD41, 0) <= 1) 	{	/* SDv1 or MMCv3? */
    2536:	20a9      	movs	r0, #169	; 0xa9
    2538:	4621      	mov	r1, r4
    253a:	f7ff fec9 	bl	22d0 <send_cmd>
    253e:	2801      	cmp	r0, #1
    2540:	d802      	bhi.n	2548 <disk_initialize+0x13c>
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 (ACMD41(0)) */
    2542:	2402      	movs	r4, #2
    2544:	27a9      	movs	r7, #169	; 0xa9
    2546:	e000      	b.n	254a <disk_initialize+0x13e>
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 (CMD1(0)) */
    2548:	463c      	mov	r4, r7
			}
			while (Timer1 && send_cmd(cmd, 0)) ;		/* Wait for the card leaves idle state */
    254a:	686b      	ldr	r3, [r5, #4]
    254c:	b12b      	cbz	r3, 255a <disk_initialize+0x14e>
    254e:	4638      	mov	r0, r7
    2550:	2100      	movs	r1, #0
    2552:	f7ff febd 	bl	22d0 <send_cmd>
    2556:	2800      	cmp	r0, #0
    2558:	d1f7      	bne.n	254a <disk_initialize+0x13e>
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set block length: 512 */
    255a:	686b      	ldr	r3, [r5, #4]
    255c:	b153      	cbz	r3, 2574 <disk_initialize+0x168>
    255e:	2010      	movs	r0, #16
    2560:	f44f 7100 	mov.w	r1, #512	; 0x200
    2564:	f7ff feb4 	bl	22d0 <send_cmd>
				ty = 0;
    2568:	2800      	cmp	r0, #0
    256a:	bf18      	it	ne
    256c:	2400      	movne	r4, #0
    256e:	e002      	b.n	2576 <disk_initialize+0x16a>
	if (Stat & STA_NODISK) return Stat;	/* Is a card existing in the soket? */

	FCLK_SLOW();
	for (n = 10; n; n--) xchg_spi(0xFF);	/* Send 80 dummy clocks */

	ty = 0;
    2570:	2400      	movs	r4, #0
    2572:	e000      	b.n	2576 <disk_initialize+0x16a>
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 (CMD1(0)) */
			}
			while (Timer1 && send_cmd(cmd, 0)) ;		/* Wait for the card leaves idle state */
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set block length: 512 */
				ty = 0;
    2574:	461c      	mov	r4, r3
		}
	}
	CardType = ty;	/* Card type */
    2576:	722c      	strb	r4, [r5, #8]
	deselect();
    2578:	f7ff fe2a 	bl	21d0 <deselect>

	if (ty) {		/* OK */
    257c:	b144      	cbz	r4, 2590 <disk_initialize+0x184>
		FCLK_FAST();			/* Set fast clock */
    257e:	4b0f      	ldr	r3, [pc, #60]	; (25bc <disk_initialize+0x1b0>)
    2580:	681a      	ldr	r2, [r3, #0]
    2582:	f002 02ff 	and.w	r2, r2, #255	; 0xff
    2586:	601a      	str	r2, [r3, #0]
		Stat &= ~STA_NOINIT;	/* Clear STA_NOINIT flag */
    2588:	7833      	ldrb	r3, [r6, #0]
    258a:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
    258e:	e004      	b.n	259a <disk_initialize+0x18e>


static
void power_off (void)		/* Disable SPI function */
{
	select();				/* Wait for card ready */
    2590:	f7ff fe26 	bl	21e0 <select>
	deselect();
    2594:	f7ff fe1c 	bl	21d0 <deselect>
	if (ty) {		/* OK */
		FCLK_FAST();			/* Set fast clock */
		Stat &= ~STA_NOINIT;	/* Clear STA_NOINIT flag */
	} else {		/* Failed */
		power_off();
		Stat = STA_NOINIT;
    2598:	2301      	movs	r3, #1
    259a:	7033      	strb	r3, [r6, #0]
	}

	return Stat;
    259c:	7830      	ldrb	r0, [r6, #0]
    259e:	e000      	b.n	25a2 <disk_initialize+0x196>
)
{
	BYTE n, cmd, ty, ocr[4];


	if (drv) return STA_NOINIT;			/* Supports only drive 0 */
    25a0:	2001      	movs	r0, #1
		power_off();
		Stat = STA_NOINIT;
	}

	return Stat;
}
    25a2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    25a4:	400fc0c4 	.word	0x400fc0c4
    25a8:	10000120 	.word	0x10000120
    25ac:	40030010 	.word	0x40030010
    25b0:	4002c000 	.word	0x4002c000
    25b4:	2009c000 	.word	0x2009c000
    25b8:	10000000 	.word	0x10000000
    25bc:	40030000 	.word	0x40030000

000025c0 <disk_status>:

DSTATUS disk_status (
	BYTE drv		/* Physical drive number (0) */
)
{
	if (drv) return STA_NOINIT;		/* Supports only drive 0 */
    25c0:	b910      	cbnz	r0, 25c8 <disk_status+0x8>

	return Stat;	/* Return disk status */
    25c2:	4b02      	ldr	r3, [pc, #8]	; (25cc <disk_status+0xc>)
    25c4:	7818      	ldrb	r0, [r3, #0]
    25c6:	4770      	bx	lr

DSTATUS disk_status (
	BYTE drv		/* Physical drive number (0) */
)
{
	if (drv) return STA_NOINIT;		/* Supports only drive 0 */
    25c8:	2001      	movs	r0, #1

	return Stat;	/* Return disk status */
}
    25ca:	4770      	bx	lr
    25cc:	10000000 	.word	0x10000000

000025d0 <disk_read>:
	BYTE drv,		/* Physical drive number (0) */
	BYTE *buff,		/* Pointer to the data buffer to store read data */
	DWORD sector,	/* Start sector number (LBA) */
	UINT count		/* Number of sectors to read (1..128) */
)
{
    25d0:	b570      	push	{r4, r5, r6, lr}
    25d2:	460c      	mov	r4, r1
    25d4:	461d      	mov	r5, r3
	BYTE cmd;


	if (drv || !count) return RES_PARERR;		/* Check parameter */
    25d6:	2800      	cmp	r0, #0
    25d8:	d12c      	bne.n	2634 <disk_read+0x64>
    25da:	2b00      	cmp	r3, #0
    25dc:	d02a      	beq.n	2634 <disk_read+0x64>
	if (Stat & STA_NOINIT) return RES_NOTRDY;	/* Check if drive is ready */
    25de:	4b17      	ldr	r3, [pc, #92]	; (263c <disk_read+0x6c>)
    25e0:	781b      	ldrb	r3, [r3, #0]
    25e2:	f013 0f01 	tst.w	r3, #1
    25e6:	d127      	bne.n	2638 <disk_read+0x68>
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* LBA ot BA conversion (byte addressing cards) */
    25e8:	4b15      	ldr	r3, [pc, #84]	; (2640 <disk_read+0x70>)
    25ea:	7a1b      	ldrb	r3, [r3, #8]
    25ec:	f013 0f08 	tst.w	r3, #8
    25f0:	bf08      	it	eq
    25f2:	0252      	lsleq	r2, r2, #9

	cmd = count > 1 ? CMD18 : CMD17;			/*  READ_MULTIPLE_BLOCK : READ_SINGLE_BLOCK */
    25f4:	2d01      	cmp	r5, #1
    25f6:	bf94      	ite	ls
    25f8:	2611      	movls	r6, #17
    25fa:	2612      	movhi	r6, #18
	if (send_cmd(cmd, sector) == 0) {
    25fc:	4630      	mov	r0, r6
    25fe:	4611      	mov	r1, r2
    2600:	f7ff fe66 	bl	22d0 <send_cmd>
    2604:	b980      	cbnz	r0, 2628 <disk_read+0x58>
		do {
			if (!rcvr_datablock(buff, 512)) break;
    2606:	4620      	mov	r0, r4
    2608:	f44f 7100 	mov.w	r1, #512	; 0x200
    260c:	f7ff fdfe 	bl	220c <rcvr_datablock>
    2610:	b120      	cbz	r0, 261c <disk_read+0x4c>
			buff += 512;
		} while (--count);
    2612:	3d01      	subs	r5, #1
    2614:	d002      	beq.n	261c <disk_read+0x4c>

	cmd = count > 1 ? CMD18 : CMD17;			/*  READ_MULTIPLE_BLOCK : READ_SINGLE_BLOCK */
	if (send_cmd(cmd, sector) == 0) {
		do {
			if (!rcvr_datablock(buff, 512)) break;
			buff += 512;
    2616:	f504 7400 	add.w	r4, r4, #512	; 0x200
    261a:	e7f4      	b.n	2606 <disk_read+0x36>
		} while (--count);
		if (cmd == CMD18) send_cmd(CMD12, 0);	/* STOP_TRANSMISSION */
    261c:	2e12      	cmp	r6, #18
    261e:	d103      	bne.n	2628 <disk_read+0x58>
    2620:	200c      	movs	r0, #12
    2622:	2100      	movs	r1, #0
    2624:	f7ff fe54 	bl	22d0 <send_cmd>
	}
	deselect();
    2628:	f7ff fdd2 	bl	21d0 <deselect>

	return count ? RES_ERROR : RES_OK;	/* Return result */
    262c:	1e28      	subs	r0, r5, #0
    262e:	bf18      	it	ne
    2630:	2001      	movne	r0, #1
    2632:	bd70      	pop	{r4, r5, r6, pc}
)
{
	BYTE cmd;


	if (drv || !count) return RES_PARERR;		/* Check parameter */
    2634:	2004      	movs	r0, #4
    2636:	bd70      	pop	{r4, r5, r6, pc}
	if (Stat & STA_NOINIT) return RES_NOTRDY;	/* Check if drive is ready */
    2638:	2003      	movs	r0, #3
		if (cmd == CMD18) send_cmd(CMD12, 0);	/* STOP_TRANSMISSION */
	}
	deselect();

	return count ? RES_ERROR : RES_OK;	/* Return result */
}
    263a:	bd70      	pop	{r4, r5, r6, pc}
    263c:	10000000 	.word	0x10000000
    2640:	10000120 	.word	0x10000120

00002644 <disk_write>:
	BYTE drv,			/* Physical drive number (0) */
	const BYTE *buff,	/* Ponter to the data to write */
	DWORD sector,		/* Start sector number (LBA) */
	UINT count			/* Number of sectors to write (1..128) */
)
{
    2644:	b570      	push	{r4, r5, r6, lr}
    2646:	460c      	mov	r4, r1
    2648:	4615      	mov	r5, r2
    264a:	461e      	mov	r6, r3
	if (drv || !count) return RES_PARERR;		/* Check parameter */
    264c:	2800      	cmp	r0, #0
    264e:	d143      	bne.n	26d8 <disk_write+0x94>
    2650:	2b00      	cmp	r3, #0
    2652:	d041      	beq.n	26d8 <disk_write+0x94>
	if (Stat & STA_NOINIT) return RES_NOTRDY;	/* Check drive status */
    2654:	4b23      	ldr	r3, [pc, #140]	; (26e4 <disk_write+0xa0>)
    2656:	781a      	ldrb	r2, [r3, #0]
    2658:	f012 0f01 	tst.w	r2, #1
    265c:	d13e      	bne.n	26dc <disk_write+0x98>
	if (Stat & STA_PROTECT) return RES_WRPRT;	/* Check write protect */
    265e:	781b      	ldrb	r3, [r3, #0]
    2660:	f013 0f04 	tst.w	r3, #4
    2664:	d13c      	bne.n	26e0 <disk_write+0x9c>

	if (!(CardType & CT_BLOCK)) sector *= 512;	/* LBA ==> BA conversion (byte addressing cards) */
    2666:	4b20      	ldr	r3, [pc, #128]	; (26e8 <disk_write+0xa4>)
    2668:	7a1b      	ldrb	r3, [r3, #8]
    266a:	f013 0f08 	tst.w	r3, #8
    266e:	bf08      	it	eq
    2670:	026d      	lsleq	r5, r5, #9

	if (count == 1) {	/* Single sector write */
    2672:	2e01      	cmp	r6, #1
    2674:	d10d      	bne.n	2692 <disk_write+0x4e>
		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
    2676:	2018      	movs	r0, #24
    2678:	4629      	mov	r1, r5
    267a:	f7ff fe29 	bl	22d0 <send_cmd>
    267e:	bb28      	cbnz	r0, 26cc <disk_write+0x88>
			&& xmit_datablock(buff, 0xFE)) {
    2680:	21fe      	movs	r1, #254	; 0xfe
    2682:	4620      	mov	r0, r4
    2684:	f7ff fe67 	bl	2356 <xmit_datablock>
			count = 0;
    2688:	f1d0 0601 	rsbs	r6, r0, #1
    268c:	bf38      	it	cc
    268e:	2600      	movcc	r6, #0
    2690:	e01c      	b.n	26cc <disk_write+0x88>
		}
	}
	else {				/* Multiple sector write */
		if (CardType & CT_SDC) send_cmd(ACMD23, count);	/* Predefine number of sectors */
    2692:	f013 0f06 	tst.w	r3, #6
    2696:	d003      	beq.n	26a0 <disk_write+0x5c>
    2698:	2097      	movs	r0, #151	; 0x97
    269a:	4631      	mov	r1, r6
    269c:	f7ff fe18 	bl	22d0 <send_cmd>
		if (send_cmd(CMD25, sector) == 0) {	/* WRITE_MULTIPLE_BLOCK */
    26a0:	2019      	movs	r0, #25
    26a2:	4629      	mov	r1, r5
    26a4:	f7ff fe14 	bl	22d0 <send_cmd>
    26a8:	b980      	cbnz	r0, 26cc <disk_write+0x88>
			do {
				if (!xmit_datablock(buff, 0xFC)) break;
    26aa:	4620      	mov	r0, r4
    26ac:	21fc      	movs	r1, #252	; 0xfc
    26ae:	f7ff fe52 	bl	2356 <xmit_datablock>
    26b2:	b120      	cbz	r0, 26be <disk_write+0x7a>
				buff += 512;
			} while (--count);
    26b4:	3e01      	subs	r6, #1
    26b6:	d002      	beq.n	26be <disk_write+0x7a>
	else {				/* Multiple sector write */
		if (CardType & CT_SDC) send_cmd(ACMD23, count);	/* Predefine number of sectors */
		if (send_cmd(CMD25, sector) == 0) {	/* WRITE_MULTIPLE_BLOCK */
			do {
				if (!xmit_datablock(buff, 0xFC)) break;
				buff += 512;
    26b8:	f504 7400 	add.w	r4, r4, #512	; 0x200
    26bc:	e7f5      	b.n	26aa <disk_write+0x66>
			} while (--count);
			if (!xmit_datablock(0, 0xFD)) count = 1;	/* STOP_TRAN token */
    26be:	2000      	movs	r0, #0
    26c0:	21fd      	movs	r1, #253	; 0xfd
    26c2:	f7ff fe48 	bl	2356 <xmit_datablock>
    26c6:	2800      	cmp	r0, #0
    26c8:	bf08      	it	eq
    26ca:	2601      	moveq	r6, #1
		}
	}
	deselect();
    26cc:	f7ff fd80 	bl	21d0 <deselect>

	return count ? RES_ERROR : RES_OK;	/* Return result */
    26d0:	1e30      	subs	r0, r6, #0
    26d2:	bf18      	it	ne
    26d4:	2001      	movne	r0, #1
    26d6:	bd70      	pop	{r4, r5, r6, pc}
	const BYTE *buff,	/* Ponter to the data to write */
	DWORD sector,		/* Start sector number (LBA) */
	UINT count			/* Number of sectors to write (1..128) */
)
{
	if (drv || !count) return RES_PARERR;		/* Check parameter */
    26d8:	2004      	movs	r0, #4
    26da:	bd70      	pop	{r4, r5, r6, pc}
	if (Stat & STA_NOINIT) return RES_NOTRDY;	/* Check drive status */
    26dc:	2003      	movs	r0, #3
    26de:	bd70      	pop	{r4, r5, r6, pc}
	if (Stat & STA_PROTECT) return RES_WRPRT;	/* Check write protect */
    26e0:	2002      	movs	r0, #2
		}
	}
	deselect();

	return count ? RES_ERROR : RES_OK;	/* Return result */
}
    26e2:	bd70      	pop	{r4, r5, r6, pc}
    26e4:	10000000 	.word	0x10000000
    26e8:	10000120 	.word	0x10000120

000026ec <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE drv,		/* Physical drive number (0) */
	BYTE cmd,		/* Control command code */
	void *buff		/* Pointer to the conrtol data */
)
{
    26ec:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    26ee:	460d      	mov	r5, r1
    26f0:	4614      	mov	r4, r2
	SDIO_CMD *sdio = buff;
	BYTE rc, *buf;
	UINT dc;
#endif

	if (drv) return RES_PARERR;					/* Check parameter */
    26f2:	2800      	cmp	r0, #0
    26f4:	f040 8118 	bne.w	2928 <disk_ioctl+0x23c>
	if (Stat & STA_NOINIT) return RES_NOTRDY;	/* Check if drive is ready */
    26f8:	4b8e      	ldr	r3, [pc, #568]	; (2934 <disk_ioctl+0x248>)
    26fa:	7819      	ldrb	r1, [r3, #0]
    26fc:	f011 0101 	ands.w	r1, r1, #1
    2700:	f040 8114 	bne.w	292c <disk_ioctl+0x240>

	res = RES_ERROR;

	switch (cmd) {
    2704:	2d32      	cmp	r5, #50	; 0x32
    2706:	f000 80db 	beq.w	28c0 <disk_ioctl+0x1d4>
    270a:	d808      	bhi.n	271e <disk_ioctl+0x32>
    270c:	2d01      	cmp	r5, #1
    270e:	d015      	beq.n	273c <disk_ioctl+0x50>
    2710:	d311      	bcc.n	2736 <disk_ioctl+0x4a>
    2712:	2d03      	cmp	r5, #3
    2714:	d050      	beq.n	27b8 <disk_ioctl+0xcc>
    2716:	2d04      	cmp	r5, #4
    2718:	f040 80fe 	bne.w	2918 <disk_ioctl+0x22c>
    271c:	e09f      	b.n	285e <disk_ioctl+0x172>
    271e:	2d34      	cmp	r5, #52	; 0x34
    2720:	f000 80d5 	beq.w	28ce <disk_ioctl+0x1e2>
    2724:	f0c0 80d1 	bcc.w	28ca <disk_ioctl+0x1de>
    2728:	2d35      	cmp	r5, #53	; 0x35
    272a:	f000 80d7 	beq.w	28dc <disk_ioctl+0x1f0>
    272e:	2d36      	cmp	r5, #54	; 0x36
    2730:	f040 80f2 	bne.w	2918 <disk_ioctl+0x22c>
    2734:	e0e0      	b.n	28f8 <disk_ioctl+0x20c>
	case CTRL_SYNC:			/* Wait for end of internal write process of the drive */
		if (select()) res = RES_OK;
    2736:	f7ff fd53 	bl	21e0 <select>
    273a:	e0e8      	b.n	290e <disk_ioctl+0x222>
		break;

	case GET_SECTOR_COUNT:	/* Get drive capacity in unit of sector (DWORD) */
		if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
    273c:	2009      	movs	r0, #9
    273e:	f7ff fdc7 	bl	22d0 <send_cmd>
    2742:	4606      	mov	r6, r0
    2744:	2800      	cmp	r0, #0
    2746:	f040 80e9 	bne.w	291c <disk_ioctl+0x230>
    274a:	4668      	mov	r0, sp
    274c:	2110      	movs	r1, #16
    274e:	f7ff fd5d 	bl	220c <rcvr_datablock>
    2752:	2800      	cmp	r0, #0
    2754:	f000 80e2 	beq.w	291c <disk_ioctl+0x230>
			if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
    2758:	f89d 3000 	ldrb.w	r3, [sp]
    275c:	f89d 2007 	ldrb.w	r2, [sp, #7]
    2760:	099b      	lsrs	r3, r3, #6
    2762:	2b01      	cmp	r3, #1
    2764:	f89d 3008 	ldrb.w	r3, [sp, #8]
    2768:	d10a      	bne.n	2780 <disk_ioctl+0x94>
				csize = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
    276a:	f002 023f 	and.w	r2, r2, #63	; 0x3f
    276e:	f89d 1009 	ldrb.w	r1, [sp, #9]
    2772:	0412      	lsls	r2, r2, #16
    2774:	021b      	lsls	r3, r3, #8
    2776:	3201      	adds	r2, #1
    2778:	185b      	adds	r3, r3, r1
    277a:	18d3      	adds	r3, r2, r3
				*(DWORD*)buff = csize << 10;
    277c:	029b      	lsls	r3, r3, #10
    277e:	e06c      	b.n	285a <disk_ioctl+0x16e>
			} else {					/* SDC ver 1.XX or MMC ver 3 */
				n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
				csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
    2780:	f89d 1006 	ldrb.w	r1, [sp, #6]
    2784:	0092      	lsls	r2, r2, #2
    2786:	eb02 1393 	add.w	r3, r2, r3, lsr #6
    278a:	f001 0103 	and.w	r1, r1, #3
    278e:	0289      	lsls	r1, r1, #10
    2790:	3301      	adds	r3, #1
		if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
			if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
				csize = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
				*(DWORD*)buff = csize << 10;
			} else {					/* SDC ver 1.XX or MMC ver 3 */
				n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
    2792:	f89d 2005 	ldrb.w	r2, [sp, #5]
				csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
    2796:	185b      	adds	r3, r3, r1
		if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
			if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
				csize = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
				*(DWORD*)buff = csize << 10;
			} else {					/* SDC ver 1.XX or MMC ver 3 */
				n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
    2798:	f89d 100a 	ldrb.w	r1, [sp, #10]
    279c:	f002 020f 	and.w	r2, r2, #15
    27a0:	eb02 12d1 	add.w	r2, r2, r1, lsr #7
    27a4:	f89d 1009 	ldrb.w	r1, [sp, #9]
    27a8:	3202      	adds	r2, #2
    27aa:	f001 0103 	and.w	r1, r1, #3
				csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
				*(DWORD*)buff = csize << (n - 9);
    27ae:	eb02 0141 	add.w	r1, r2, r1, lsl #1
    27b2:	3909      	subs	r1, #9
    27b4:	408b      	lsls	r3, r1
    27b6:	e050      	b.n	285a <disk_ioctl+0x16e>
			res = RES_OK;
		}
		break;

	case GET_BLOCK_SIZE:	/* Get erase block size in unit of sector (DWORD) */
		if (CardType & CT_SD2) {	/* SDC ver 2.00 */
    27b8:	4b5f      	ldr	r3, [pc, #380]	; (2938 <disk_ioctl+0x24c>)
    27ba:	7a1e      	ldrb	r6, [r3, #8]
    27bc:	f016 0304 	ands.w	r3, r6, #4
    27c0:	d01e      	beq.n	2800 <disk_ioctl+0x114>
			if (send_cmd(ACMD13, 0) == 0) {	/* Read SD status */
    27c2:	208d      	movs	r0, #141	; 0x8d
    27c4:	f7ff fd84 	bl	22d0 <send_cmd>
    27c8:	2800      	cmp	r0, #0
    27ca:	f040 80a9 	bne.w	2920 <disk_ioctl+0x234>
				xchg_spi(0xFF);
    27ce:	30ff      	adds	r0, #255	; 0xff
    27d0:	f7ff fcda 	bl	2188 <xchg_spi>
				if (rcvr_datablock(csd, 16)) {				/* Read partial block */
    27d4:	4668      	mov	r0, sp
    27d6:	2110      	movs	r1, #16
    27d8:	f7ff fd18 	bl	220c <rcvr_datablock>
    27dc:	2800      	cmp	r0, #0
    27de:	f000 809f 	beq.w	2920 <disk_ioctl+0x234>
    27e2:	2630      	movs	r6, #48	; 0x30
					for (n = 64 - 16; n; n--) xchg_spi(0xFF);	/* Purge trailing data */
    27e4:	3e01      	subs	r6, #1
    27e6:	20ff      	movs	r0, #255	; 0xff
    27e8:	b2f6      	uxtb	r6, r6
    27ea:	f7ff fccd 	bl	2188 <xchg_spi>
    27ee:	2e00      	cmp	r6, #0
    27f0:	d1f8      	bne.n	27e4 <disk_ioctl+0xf8>
					*(DWORD*)buff = 16UL << (csd[10] >> 4);
    27f2:	f89d 300a 	ldrb.w	r3, [sp, #10]
    27f6:	2210      	movs	r2, #16
    27f8:	091b      	lsrs	r3, r3, #4
    27fa:	fa12 f303 	lsls.w	r3, r2, r3
    27fe:	e02c      	b.n	285a <disk_ioctl+0x16e>
					res = RES_OK;
				}
			}
		} else {					/* SDC ver 1.XX or MMC */
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {	/* Read CSD */
    2800:	2009      	movs	r0, #9
    2802:	4619      	mov	r1, r3
    2804:	f7ff fd64 	bl	22d0 <send_cmd>
    2808:	2800      	cmp	r0, #0
    280a:	f040 8089 	bne.w	2920 <disk_ioctl+0x234>
    280e:	4668      	mov	r0, sp
    2810:	2110      	movs	r1, #16
    2812:	f7ff fcfb 	bl	220c <rcvr_datablock>
    2816:	2800      	cmp	r0, #0
    2818:	f000 8082 	beq.w	2920 <disk_ioctl+0x234>
				if (CardType & CT_SD1) {	/* SDC ver 1.XX */
    281c:	f016 0602 	ands.w	r6, r6, #2
    2820:	f89d 200a 	ldrb.w	r2, [sp, #10]
    2824:	f89d 300b 	ldrb.w	r3, [sp, #11]
    2828:	d00c      	beq.n	2844 <disk_ioctl+0x158>
					*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
    282a:	f89d 100d 	ldrb.w	r1, [sp, #13]
    282e:	09db      	lsrs	r3, r3, #7
    2830:	3301      	adds	r3, #1
    2832:	f002 023f 	and.w	r2, r2, #63	; 0x3f
    2836:	0989      	lsrs	r1, r1, #6
    2838:	eb03 0242 	add.w	r2, r3, r2, lsl #1
    283c:	3901      	subs	r1, #1
    283e:	408a      	lsls	r2, r1
    2840:	6022      	str	r2, [r4, #0]
    2842:	e057      	b.n	28f4 <disk_ioctl+0x208>
				} else {					/* MMC */
					*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1);
    2844:	0959      	lsrs	r1, r3, #5
    2846:	f002 027c 	and.w	r2, r2, #124	; 0x7c
    284a:	0892      	lsrs	r2, r2, #2
    284c:	3101      	adds	r1, #1
    284e:	f003 0303 	and.w	r3, r3, #3
    2852:	3201      	adds	r2, #1
    2854:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
    2858:	4353      	muls	r3, r2
    285a:	6023      	str	r3, [r4, #0]
    285c:	e061      	b.n	2922 <disk_ioctl+0x236>
			}
		}
		break;

	case CTRL_TRIM:		/* Erase a block of sectors (used when _USE_TRIM in ffconf.h is 1) */
		if (!(CardType & CT_SDC)) break;				/* Check if the card is SDC */
    285e:	4b36      	ldr	r3, [pc, #216]	; (2938 <disk_ioctl+0x24c>)
    2860:	7a1d      	ldrb	r5, [r3, #8]
    2862:	f015 0f06 	tst.w	r5, #6
    2866:	d05b      	beq.n	2920 <disk_ioctl+0x234>
		if (disk_ioctl(drv, MMC_GET_CSD, csd)) break;	/* Get CSD */
    2868:	2133      	movs	r1, #51	; 0x33
    286a:	466a      	mov	r2, sp
    286c:	f7ff ff3e 	bl	26ec <disk_ioctl>
    2870:	2800      	cmp	r0, #0
    2872:	d155      	bne.n	2920 <disk_ioctl+0x234>
		if (!(csd[0] >> 6) && !(csd[10] & 0x40)) break;	/* Check if sector erase can be applied to the card */
    2874:	f89d 3000 	ldrb.w	r3, [sp]
    2878:	099b      	lsrs	r3, r3, #6
    287a:	d104      	bne.n	2886 <disk_ioctl+0x19a>
    287c:	f89d 300a 	ldrb.w	r3, [sp, #10]
    2880:	f013 0f40 	tst.w	r3, #64	; 0x40
    2884:	d04c      	beq.n	2920 <disk_ioctl+0x234>
		dp = buff; st = dp[0]; ed = dp[1];				/* Load sector block */
		if (!(CardType & CT_BLOCK)) {
    2886:	f015 0f08 	tst.w	r5, #8

	case CTRL_TRIM:		/* Erase a block of sectors (used when _USE_TRIM in ffconf.h is 1) */
		if (!(CardType & CT_SDC)) break;				/* Check if the card is SDC */
		if (disk_ioctl(drv, MMC_GET_CSD, csd)) break;	/* Get CSD */
		if (!(csd[0] >> 6) && !(csd[10] & 0x40)) break;	/* Check if sector erase can be applied to the card */
		dp = buff; st = dp[0]; ed = dp[1];				/* Load sector block */
    288a:	6821      	ldr	r1, [r4, #0]
    288c:	6864      	ldr	r4, [r4, #4]
		if (!(CardType & CT_BLOCK)) {
    288e:	d101      	bne.n	2894 <disk_ioctl+0x1a8>
			st *= 512; ed *= 512;
    2890:	0249      	lsls	r1, r1, #9
    2892:	0264      	lsls	r4, r4, #9
		}
		if (send_cmd(CMD32, st) == 0 && send_cmd(CMD33, ed) == 0 && send_cmd(CMD38, 0) == 0 && wait_ready(30000)) {	/* Erase sector block */
    2894:	2020      	movs	r0, #32
    2896:	f7ff fd1b 	bl	22d0 <send_cmd>
    289a:	2800      	cmp	r0, #0
    289c:	d140      	bne.n	2920 <disk_ioctl+0x234>
    289e:	4621      	mov	r1, r4
    28a0:	3021      	adds	r0, #33	; 0x21
    28a2:	f7ff fd15 	bl	22d0 <send_cmd>
    28a6:	4601      	mov	r1, r0
    28a8:	2800      	cmp	r0, #0
    28aa:	d139      	bne.n	2920 <disk_ioctl+0x234>
    28ac:	2026      	movs	r0, #38	; 0x26
    28ae:	f7ff fd0f 	bl	22d0 <send_cmd>
    28b2:	2800      	cmp	r0, #0
    28b4:	d134      	bne.n	2920 <disk_ioctl+0x234>
    28b6:	f247 5030 	movw	r0, #30000	; 0x7530
    28ba:	f7ff fc75 	bl	21a8 <wait_ready>
    28be:	e026      	b.n	290e <disk_ioctl+0x222>
		break;

	/* Following commands are never used by FatFs module */

	case MMC_GET_TYPE:		/* Get MMC/SDC type (BYTE) */
		*ptr = CardType;
    28c0:	4b1d      	ldr	r3, [pc, #116]	; (2938 <disk_ioctl+0x24c>)
		res = RES_OK;
    28c2:	460e      	mov	r6, r1
		break;

	/* Following commands are never used by FatFs module */

	case MMC_GET_TYPE:		/* Get MMC/SDC type (BYTE) */
		*ptr = CardType;
    28c4:	7a1b      	ldrb	r3, [r3, #8]
    28c6:	7013      	strb	r3, [r2, #0]
		res = RES_OK;
		break;
    28c8:	e02b      	b.n	2922 <disk_ioctl+0x236>

	case MMC_GET_CSD:		/* Read CSD (16 bytes) */
		if (send_cmd(CMD9, 0) == 0 && rcvr_datablock(ptr, 16)) {	/* READ_CSD */
    28ca:	2009      	movs	r0, #9
    28cc:	e000      	b.n	28d0 <disk_ioctl+0x1e4>
			res = RES_OK;
		}
		break;

	case MMC_GET_CID:		/* Read CID (16 bytes) */
		if (send_cmd(CMD10, 0) == 0 && rcvr_datablock(ptr, 16)) {	/* READ_CID */
    28ce:	200a      	movs	r0, #10
    28d0:	f7ff fcfe 	bl	22d0 <send_cmd>
    28d4:	bb20      	cbnz	r0, 2920 <disk_ioctl+0x234>
    28d6:	4620      	mov	r0, r4
    28d8:	2110      	movs	r1, #16
    28da:	e016      	b.n	290a <disk_ioctl+0x21e>
			res = RES_OK;
		}
		break;

	case MMC_GET_OCR:		/* Read OCR (4 bytes) */
		if (send_cmd(CMD58, 0) == 0) {	/* READ_OCR */
    28dc:	203a      	movs	r0, #58	; 0x3a
    28de:	f7ff fcf7 	bl	22d0 <send_cmd>
    28e2:	b9e8      	cbnz	r0, 2920 <disk_ioctl+0x234>
    28e4:	4605      	mov	r5, r0
			for (n = 4; n; n--) *ptr++ = xchg_spi(0xFF);
    28e6:	20ff      	movs	r0, #255	; 0xff
    28e8:	f7ff fc4e 	bl	2188 <xchg_spi>
    28ec:	5560      	strb	r0, [r4, r5]
    28ee:	3501      	adds	r5, #1
    28f0:	2d04      	cmp	r5, #4
    28f2:	d1f8      	bne.n	28e6 <disk_ioctl+0x1fa>
			res = RES_OK;
    28f4:	2600      	movs	r6, #0
    28f6:	e014      	b.n	2922 <disk_ioctl+0x236>
		}
		break;

	case MMC_GET_SDSTAT:	/* Read SD status (64 bytes) */
		if (send_cmd(ACMD13, 0) == 0) {	/* SD_STATUS */
    28f8:	208d      	movs	r0, #141	; 0x8d
    28fa:	f7ff fce9 	bl	22d0 <send_cmd>
    28fe:	b978      	cbnz	r0, 2920 <disk_ioctl+0x234>
			xchg_spi(0xFF);
    2900:	30ff      	adds	r0, #255	; 0xff
    2902:	f7ff fc41 	bl	2188 <xchg_spi>
			if (rcvr_datablock(ptr, 64)) res = RES_OK;
    2906:	4620      	mov	r0, r4
    2908:	2140      	movs	r1, #64	; 0x40
    290a:	f7ff fc7f 	bl	220c <rcvr_datablock>
#endif

	if (drv) return RES_PARERR;					/* Check parameter */
	if (Stat & STA_NOINIT) return RES_NOTRDY;	/* Check if drive is ready */

	res = RES_ERROR;
    290e:	f1d0 0601 	rsbs	r6, r0, #1
    2912:	bf38      	it	cc
    2914:	2600      	movcc	r6, #0
    2916:	e004      	b.n	2922 <disk_ioctl+0x236>
			if ((xchg_spi(0xFF) & 0x1F) == 0x05) res = RES_OK;
		}
		break;
#endif
	default:
		res = RES_PARERR;
    2918:	2604      	movs	r6, #4
    291a:	e002      	b.n	2922 <disk_ioctl+0x236>
#endif

	if (drv) return RES_PARERR;					/* Check parameter */
	if (Stat & STA_NOINIT) return RES_NOTRDY;	/* Check if drive is ready */

	res = RES_ERROR;
    291c:	462e      	mov	r6, r5
    291e:	e000      	b.n	2922 <disk_ioctl+0x236>
    2920:	2601      	movs	r6, #1
#endif
	default:
		res = RES_PARERR;
	}

	deselect();
    2922:	f7ff fc55 	bl	21d0 <deselect>
	return res;
    2926:	e002      	b.n	292e <disk_ioctl+0x242>
	SDIO_CMD *sdio = buff;
	BYTE rc, *buf;
	UINT dc;
#endif

	if (drv) return RES_PARERR;					/* Check parameter */
    2928:	2604      	movs	r6, #4
    292a:	e000      	b.n	292e <disk_ioctl+0x242>
	if (Stat & STA_NOINIT) return RES_NOTRDY;	/* Check if drive is ready */
    292c:	2603      	movs	r6, #3
		res = RES_PARERR;
	}

	deselect();
	return res;
}
    292e:	4630      	mov	r0, r6
    2930:	b004      	add	sp, #16
    2932:	bd70      	pop	{r4, r5, r6, pc}
    2934:	10000000 	.word	0x10000000
    2938:	10000120 	.word	0x10000120

0000293c <disk_timerproc>:
{
	WORD n;
	BYTE s;


	n = Timer1;						/* 1kHz decrement timer stopped at 0 */
    293c:	4b0e      	ldr	r3, [pc, #56]	; (2978 <disk_timerproc+0x3c>)
    293e:	685a      	ldr	r2, [r3, #4]
    2940:	b292      	uxth	r2, r2
	if (n) Timer1 = --n;
    2942:	b112      	cbz	r2, 294a <disk_timerproc+0xe>
    2944:	3a01      	subs	r2, #1
    2946:	b292      	uxth	r2, r2
    2948:	605a      	str	r2, [r3, #4]
	n = Timer2;
    294a:	681b      	ldr	r3, [r3, #0]
    294c:	b29b      	uxth	r3, r3
	if (n) Timer2 = --n;
    294e:	b11b      	cbz	r3, 2958 <disk_timerproc+0x1c>
    2950:	3b01      	subs	r3, #1
    2952:	4a09      	ldr	r2, [pc, #36]	; (2978 <disk_timerproc+0x3c>)
    2954:	b29b      	uxth	r3, r3
    2956:	6013      	str	r3, [r2, #0]

	s = Stat;
    2958:	4a08      	ldr	r2, [pc, #32]	; (297c <disk_timerproc+0x40>)
	if (MMC_WP) {	/* Write protected */
		s |= STA_PROTECT;
	} else {		/* Write enabled */
		s &= ~STA_PROTECT;
	}
	if (MMC_CD) {	/* Card is in socket */
    295a:	4909      	ldr	r1, [pc, #36]	; (2980 <disk_timerproc+0x44>)
	n = Timer1;						/* 1kHz decrement timer stopped at 0 */
	if (n) Timer1 = --n;
	n = Timer2;
	if (n) Timer2 = --n;

	s = Stat;
    295c:	7813      	ldrb	r3, [r2, #0]
	if (MMC_WP) {	/* Write protected */
		s |= STA_PROTECT;
	} else {		/* Write enabled */
		s &= ~STA_PROTECT;
	}
	if (MMC_CD) {	/* Card is in socket */
    295e:	7809      	ldrb	r1, [r1, #0]

	s = Stat;
	if (MMC_WP) {	/* Write protected */
		s |= STA_PROTECT;
	} else {		/* Write enabled */
		s &= ~STA_PROTECT;
    2960:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
	}
	if (MMC_CD) {	/* Card is in socket */
    2964:	f011 0f02 	tst.w	r1, #2
		s &= ~STA_NODISK;
    2968:	bf0c      	ite	eq
    296a:	f003 03f9 	andeq.w	r3, r3, #249	; 0xf9
	} else {		/* Socket empty */
		s |= (STA_NODISK | STA_NOINIT);
    296e:	f043 0303 	orrne.w	r3, r3, #3
	}
	Stat = s;
    2972:	7013      	strb	r3, [r2, #0]
}
    2974:	4770      	bx	lr
    2976:	bf00      	nop
    2978:	10000120 	.word	0x10000120
    297c:	10000000 	.word	0x10000000
    2980:	2009c055 	.word	0x2009c055

00002984 <ld_word>:
static WORD ld_word (const BYTE* ptr)	/*	 Load a 2-byte little-endian word */
{
	WORD rv;

	rv = ptr[1];
	rv = rv << 8 | ptr[0];
    2984:	7842      	ldrb	r2, [r0, #1]
    2986:	7803      	ldrb	r3, [r0, #0]
	return rv;
}
    2988:	ea43 2002 	orr.w	r0, r3, r2, lsl #8
    298c:	4770      	bx	lr

0000298e <ld_dword>:
static DWORD ld_dword (const BYTE* ptr)	/* Load a 4-byte little-endian word */
{
	DWORD rv;

	rv = ptr[3];
	rv = rv << 8 | ptr[2];
    298e:	7883      	ldrb	r3, [r0, #2]

static DWORD ld_dword (const BYTE* ptr)	/* Load a 4-byte little-endian word */
{
	DWORD rv;

	rv = ptr[3];
    2990:	78c2      	ldrb	r2, [r0, #3]
	rv = rv << 8 | ptr[2];
    2992:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
	rv = rv << 8 | ptr[1];
    2996:	7843      	ldrb	r3, [r0, #1]
    2998:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
	rv = rv << 8 | ptr[0];
    299c:	7803      	ldrb	r3, [r0, #0]
	return rv;
}
    299e:	ea43 2002 	orr.w	r0, r3, r2, lsl #8
    29a2:	4770      	bx	lr

000029a4 <st_word>:
#endif

#if !FF_FS_READONLY
static void st_word (BYTE* ptr, WORD val)	/* Store a 2-byte word in little-endian */
{
	*ptr++ = (BYTE)val; val >>= 8;
    29a4:	7001      	strb	r1, [r0, #0]
    29a6:	0a09      	lsrs	r1, r1, #8
	*ptr++ = (BYTE)val;
    29a8:	7041      	strb	r1, [r0, #1]
}
    29aa:	4770      	bx	lr

000029ac <st_dword>:

static void st_dword (BYTE* ptr, DWORD val)	/* Store a 4-byte word in little-endian */
{
	*ptr++ = (BYTE)val; val >>= 8;
    29ac:	4603      	mov	r3, r0
    29ae:	0a0a      	lsrs	r2, r1, #8
    29b0:	f803 1b01 	strb.w	r1, [r3], #1
	*ptr++ = (BYTE)val; val >>= 8;
    29b4:	7042      	strb	r2, [r0, #1]
    29b6:	0c0a      	lsrs	r2, r1, #16
	*ptr++ = (BYTE)val; val >>= 8;
    29b8:	0e09      	lsrs	r1, r1, #24
    29ba:	705a      	strb	r2, [r3, #1]
	*ptr++ = (BYTE)val;
    29bc:	7099      	strb	r1, [r3, #2]
}
    29be:	4770      	bx	lr

000029c0 <mem_cpy>:
static void mem_cpy (void* dst, const void* src, UINT cnt)
{
	BYTE *d = (BYTE*)dst;
	const BYTE *s = (const BYTE*)src;

	if (cnt != 0) {
    29c0:	b12a      	cbz	r2, 29ce <mem_cpy+0xe>
		do {
			*d++ = *s++;
    29c2:	f811 3b01 	ldrb.w	r3, [r1], #1
		} while (--cnt);
    29c6:	3a01      	subs	r2, #1
	BYTE *d = (BYTE*)dst;
	const BYTE *s = (const BYTE*)src;

	if (cnt != 0) {
		do {
			*d++ = *s++;
    29c8:	f800 3b01 	strb.w	r3, [r0], #1
		} while (--cnt);
    29cc:	d1f9      	bne.n	29c2 <mem_cpy+0x2>
    29ce:	4770      	bx	lr

000029d0 <mem_set>:
{
	BYTE *d = (BYTE*)dst;

	do {
		*d++ = (BYTE)val;
	} while (--cnt);
    29d0:	3a01      	subs	r2, #1
static void mem_set (void* dst, int val, UINT cnt)
{
	BYTE *d = (BYTE*)dst;

	do {
		*d++ = (BYTE)val;
    29d2:	f800 1b01 	strb.w	r1, [r0], #1
	} while (--cnt);
    29d6:	d1fb      	bne.n	29d0 <mem_set>
}
    29d8:	4770      	bx	lr

000029da <mem_cmp>:


/* Compare memory block */
static int mem_cmp (const void* dst, const void* src, UINT cnt)	/* ZR:same, NZ:different */
{
    29da:	b510      	push	{r4, lr}
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
    29dc:	4603      	mov	r3, r0
	int r = 0;

	do {
		r = *d++ - *s++;
    29de:	f813 4b01 	ldrb.w	r4, [r3], #1
    29e2:	f811 0b01 	ldrb.w	r0, [r1], #1
	} while (--cnt && r == 0);
    29e6:	3a01      	subs	r2, #1
{
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	do {
		r = *d++ - *s++;
    29e8:	ebc0 0004 	rsb	r0, r0, r4
	} while (--cnt && r == 0);
    29ec:	d001      	beq.n	29f2 <mem_cmp+0x18>
    29ee:	2800      	cmp	r0, #0
    29f0:	d0f5      	beq.n	29de <mem_cmp+0x4>

	return r;
}
    29f2:	bd10      	pop	{r4, pc}

000029f4 <chk_chr>:


/* Check if chr is contained in the string */
static int chk_chr (const char* str, int chr)	/* NZ:contained, ZR:not contained */
{
	while (*str && *str != chr) str++;
    29f4:	f810 3b01 	ldrb.w	r3, [r0], #1
    29f8:	b10b      	cbz	r3, 29fe <chk_chr+0xa>
    29fa:	428b      	cmp	r3, r1
    29fc:	d1fa      	bne.n	29f4 <chk_chr>
	return *str;
}
    29fe:	4618      	mov	r0, r3
    2a00:	4770      	bx	lr

00002a02 <dbc_1st>:
	if (DbcTbl && c >= DbcTbl[0]) {
		if (c <= DbcTbl[1]) return 1;					/* 1st byte range 1 */
		if (c >= DbcTbl[2] && c <= DbcTbl[3]) return 1;	/* 1st byte range 2 */
	}
#elif FF_CODE_PAGE >= 900	/* DBCS fixed code page */
	if (c >= DbcTbl[0]) {
    2a02:	2880      	cmp	r0, #128	; 0x80
    2a04:	d908      	bls.n	2a18 <dbc_1st+0x16>
		if (c <= DbcTbl[1]) return 1;
    2a06:	289f      	cmp	r0, #159	; 0x9f
    2a08:	d908      	bls.n	2a1c <dbc_1st+0x1a>
		if (c >= DbcTbl[2] && c <= DbcTbl[3]) return 1;
    2a0a:	28df      	cmp	r0, #223	; 0xdf
    2a0c:	d908      	bls.n	2a20 <dbc_1st+0x1e>
	return *str;
}


/* Test if the character is DBC 1st byte */
static int dbc_1st (BYTE c)
    2a0e:	28fc      	cmp	r0, #252	; 0xfc
    2a10:	bf8c      	ite	hi
    2a12:	2000      	movhi	r0, #0
    2a14:	2001      	movls	r0, #1
    2a16:	4770      	bx	lr
		if (c >= DbcTbl[2] && c <= DbcTbl[3]) return 1;
	}
#else						/* SBCS fixed code page */
	if (c != 0) return 0;	/* Always false */
#endif
	return 0;
    2a18:	2000      	movs	r0, #0
    2a1a:	4770      	bx	lr
		if (c <= DbcTbl[1]) return 1;					/* 1st byte range 1 */
		if (c >= DbcTbl[2] && c <= DbcTbl[3]) return 1;	/* 1st byte range 2 */
	}
#elif FF_CODE_PAGE >= 900	/* DBCS fixed code page */
	if (c >= DbcTbl[0]) {
		if (c <= DbcTbl[1]) return 1;
    2a1c:	2001      	movs	r0, #1
    2a1e:	4770      	bx	lr
		if (c >= DbcTbl[2] && c <= DbcTbl[3]) return 1;
	}
#else						/* SBCS fixed code page */
	if (c != 0) return 0;	/* Always false */
#endif
	return 0;
    2a20:	2000      	movs	r0, #0
}
    2a22:	4770      	bx	lr

00002a24 <dbc_2nd>:
		if (c <= DbcTbl[5]) return 1;					/* 2nd byte range 1 */
		if (c >= DbcTbl[6] && c <= DbcTbl[7]) return 1;	/* 2nd byte range 2 */
		if (c >= DbcTbl[8] && c <= DbcTbl[9]) return 1;	/* 2nd byte range 3 */
	}
#elif FF_CODE_PAGE >= 900	/* DBCS fixed code page */
	if (c >= DbcTbl[4]) {
    2a24:	283f      	cmp	r0, #63	; 0x3f
    2a26:	d908      	bls.n	2a3a <dbc_2nd+0x16>
		if (c <= DbcTbl[5]) return 1;
    2a28:	287e      	cmp	r0, #126	; 0x7e
    2a2a:	d908      	bls.n	2a3e <dbc_2nd+0x1a>
		if (c >= DbcTbl[6] && c <= DbcTbl[7]) return 1;
    2a2c:	287f      	cmp	r0, #127	; 0x7f
    2a2e:	d008      	beq.n	2a42 <dbc_2nd+0x1e>
		if (c >= DbcTbl[6] && c <= DbcTbl[7]) return 1;	/* 2nd byte range 2 */
		if (c >= DbcTbl[8] && c <= DbcTbl[9]) return 1;	/* 2nd byte range 3 */
	}
#elif FF_CODE_PAGE >= 900	/* DBCS fixed code page */
	if (c >= DbcTbl[4]) {
		if (c <= DbcTbl[5]) return 1;
    2a30:	28fc      	cmp	r0, #252	; 0xfc
    2a32:	bf8c      	ite	hi
    2a34:	2000      	movhi	r0, #0
    2a36:	2001      	movls	r0, #1
    2a38:	4770      	bx	lr
		if (c >= DbcTbl[8] && c <= DbcTbl[9]) return 1;
	}
#else						/* SBCS fixed code page */
	if (c != 0) return 0;	/* Always false */
#endif
	return 0;
    2a3a:	2000      	movs	r0, #0
    2a3c:	4770      	bx	lr
		if (c >= DbcTbl[6] && c <= DbcTbl[7]) return 1;	/* 2nd byte range 2 */
		if (c >= DbcTbl[8] && c <= DbcTbl[9]) return 1;	/* 2nd byte range 3 */
	}
#elif FF_CODE_PAGE >= 900	/* DBCS fixed code page */
	if (c >= DbcTbl[4]) {
		if (c <= DbcTbl[5]) return 1;
    2a3e:	2001      	movs	r0, #1
    2a40:	4770      	bx	lr
		if (c >= DbcTbl[8] && c <= DbcTbl[9]) return 1;
	}
#else						/* SBCS fixed code page */
	if (c != 0) return 0;	/* Always false */
#endif
	return 0;
    2a42:	2000      	movs	r0, #0
}
    2a44:	4770      	bx	lr

00002a46 <clst2sect>:
	FATFS* fs,		/* Filesystem object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;		/* Cluster number is origin from 2 */
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
    2a46:	6983      	ldr	r3, [r0, #24]
static DWORD clst2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
	FATFS* fs,		/* Filesystem object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;		/* Cluster number is origin from 2 */
    2a48:	3902      	subs	r1, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
    2a4a:	3b02      	subs	r3, #2
    2a4c:	4299      	cmp	r1, r3
    2a4e:	d204      	bcs.n	2a5a <clst2sect+0x14>
	return fs->database + fs->csize * clst;		/* Start sector number of the cluster */
    2a50:	8942      	ldrh	r2, [r0, #10]
    2a52:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    2a54:	fb02 3001 	mla	r0, r2, r1, r3
    2a58:	4770      	bx	lr
	FATFS* fs,		/* Filesystem object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;		/* Cluster number is origin from 2 */
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
    2a5a:	2000      	movs	r0, #0
	return fs->database + fs->csize * clst;		/* Start sector number of the cluster */
}
    2a5c:	4770      	bx	lr

00002a5e <get_fileinfo>:
#else
	TCHAR c;
#endif


	fno->fname[0] = 0;			/* Invaidate file info */
    2a5e:	2300      	movs	r3, #0

static void get_fileinfo (
	DIR* dp,			/* Pointer to the directory object */
	FILINFO* fno		/* Pointer to the file information to be filled */
)
{
    2a60:	b570      	push	{r4, r5, r6, lr}
#else
	TCHAR c;
#endif


	fno->fname[0] = 0;			/* Invaidate file info */
    2a62:	724b      	strb	r3, [r1, #9]
	if (dp->sect == 0) return;	/* Exit if read pointer has reached end of directory */
    2a64:	6982      	ldr	r2, [r0, #24]

static void get_fileinfo (
	DIR* dp,			/* Pointer to the directory object */
	FILINFO* fno		/* Pointer to the file information to be filled */
)
{
    2a66:	460c      	mov	r4, r1
	TCHAR c;
#endif


	fno->fname[0] = 0;			/* Invaidate file info */
	if (dp->sect == 0) return;	/* Exit if read pointer has reached end of directory */
    2a68:	b34a      	cbz	r2, 2abe <get_fileinfo+0x60>
    2a6a:	461a      	mov	r2, r3
	}

#else	/* Non-LFN configuration */
	si = di = 0;
	while (si < 11) {		/* Copy name body and extension */
		c = (TCHAR)dp->dir[si++];
    2a6c:	69c1      	ldr	r1, [r0, #28]
    2a6e:	5c89      	ldrb	r1, [r1, r2]
    2a70:	3201      	adds	r2, #1
		if (c == ' ') continue;		/* Skip padding spaces */
    2a72:	2920      	cmp	r1, #32
    2a74:	d00b      	beq.n	2a8e <get_fileinfo+0x30>
		if (c == RDDEM) c = DDEM;	/* Restore replaced DDEM character */
    2a76:	2905      	cmp	r1, #5
    2a78:	bf08      	it	eq
    2a7a:	21e5      	moveq	r1, #229	; 0xe5
		if (si == 9) fno->fname[di++] = '.';/* Insert a . if extension is exist */
    2a7c:	2a09      	cmp	r2, #9
    2a7e:	d103      	bne.n	2a88 <get_fileinfo+0x2a>
    2a80:	18e5      	adds	r5, r4, r3
    2a82:	262e      	movs	r6, #46	; 0x2e
    2a84:	726e      	strb	r6, [r5, #9]
    2a86:	3301      	adds	r3, #1
		fno->fname[di++] = c;
    2a88:	18e5      	adds	r5, r4, r3
    2a8a:	7269      	strb	r1, [r5, #9]
    2a8c:	3301      	adds	r3, #1
		if (!dp->dir[DIR_NTres]) fno->altname[0] = 0;	/* Altname is not needed if neither LFN nor case info is exist. */
	}

#else	/* Non-LFN configuration */
	si = di = 0;
	while (si < 11) {		/* Copy name body and extension */
    2a8e:	2a0b      	cmp	r2, #11
    2a90:	d1ec      	bne.n	2a6c <get_fileinfo+0xe>
		if (c == ' ') continue;		/* Skip padding spaces */
		if (c == RDDEM) c = DDEM;	/* Restore replaced DDEM character */
		if (si == 9) fno->fname[di++] = '.';/* Insert a . if extension is exist */
		fno->fname[di++] = c;
	}
	fno->fname[di] = 0;
    2a92:	3a0b      	subs	r2, #11
    2a94:	18e3      	adds	r3, r4, r3
    2a96:	725a      	strb	r2, [r3, #9]
#endif

	fno->fattrib = dp->dir[DIR_Attr];					/* Attribute */
    2a98:	69c3      	ldr	r3, [r0, #28]
    2a9a:	7adb      	ldrb	r3, [r3, #11]
    2a9c:	7223      	strb	r3, [r4, #8]
	fno->fsize = ld_dword(dp->dir + DIR_FileSize);		/* Size */
    2a9e:	69c5      	ldr	r5, [r0, #28]
    2aa0:	f105 001c 	add.w	r0, r5, #28
    2aa4:	f7ff ff73 	bl	298e <ld_dword>
    2aa8:	6020      	str	r0, [r4, #0]
	fno->ftime = ld_word(dp->dir + DIR_ModTime + 0);	/* Time */
    2aaa:	f105 0016 	add.w	r0, r5, #22
    2aae:	f7ff ff69 	bl	2984 <ld_word>
    2ab2:	80e0      	strh	r0, [r4, #6]
	fno->fdate = ld_word(dp->dir + DIR_ModTime + 2);	/* Date */
    2ab4:	f105 0018 	add.w	r0, r5, #24
    2ab8:	f7ff ff64 	bl	2984 <ld_word>
    2abc:	80a0      	strh	r0, [r4, #4]
    2abe:	bd70      	pop	{r4, r5, r6, pc}

00002ac0 <get_achar>:
/*-----------------------------------------------------------------------*/

static DWORD get_achar (	/* Get a character and advances ptr */
	const TCHAR** ptr		/* Pointer to pointer to the ANSI/OEM or Unicode string */
)
{
    2ac0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	chr = tchar2uni(ptr);
	if (chr == 0xFFFFFFFF) chr = 0;		/* Wrong UTF encoding is recognized as end of the string */
	chr = ff_wtoupper(chr);

#else									/* ANSI/OEM input */
	chr = (BYTE)*(*ptr)++;				/* Get a byte */
    2ac2:	6807      	ldr	r7, [r0, #0]
/*-----------------------------------------------------------------------*/

static DWORD get_achar (	/* Get a character and advances ptr */
	const TCHAR** ptr		/* Pointer to pointer to the ANSI/OEM or Unicode string */
)
{
    2ac4:	4606      	mov	r6, r0
	chr = tchar2uni(ptr);
	if (chr == 0xFFFFFFFF) chr = 0;		/* Wrong UTF encoding is recognized as end of the string */
	chr = ff_wtoupper(chr);

#else									/* ANSI/OEM input */
	chr = (BYTE)*(*ptr)++;				/* Get a byte */
    2ac6:	463d      	mov	r5, r7
    2ac8:	f815 4b01 	ldrb.w	r4, [r5], #1
	if (IsLower(chr)) chr -= 0x20;		/* To upper ASCII char */
    2acc:	f1a4 0361 	sub.w	r3, r4, #97	; 0x61
    2ad0:	2b19      	cmp	r3, #25
    2ad2:	bf98      	it	ls
    2ad4:	3c20      	subls	r4, #32
	chr = tchar2uni(ptr);
	if (chr == 0xFFFFFFFF) chr = 0;		/* Wrong UTF encoding is recognized as end of the string */
	chr = ff_wtoupper(chr);

#else									/* ANSI/OEM input */
	chr = (BYTE)*(*ptr)++;				/* Get a byte */
    2ad6:	6005      	str	r5, [r0, #0]
	if (ExCvt && chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
#elif FF_CODE_PAGE < 900
	if (chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
#endif
#if FF_CODE_PAGE == 0 || FF_CODE_PAGE >= 900
	if (dbc_1st((BYTE)chr)) {	/* Get DBC 2nd byte if needed */
    2ad8:	b2e0      	uxtb	r0, r4
    2ada:	f7ff ff92 	bl	2a02 <dbc_1st>
    2ade:	b150      	cbz	r0, 2af6 <get_achar+0x36>
		chr = dbc_2nd((BYTE)**ptr) ? chr << 8 | (BYTE)*(*ptr)++ : 0;
    2ae0:	787f      	ldrb	r7, [r7, #1]
    2ae2:	4638      	mov	r0, r7
    2ae4:	f7ff ff9e 	bl	2a24 <dbc_2nd>
    2ae8:	b120      	cbz	r0, 2af4 <get_achar+0x34>
    2aea:	3501      	adds	r5, #1
    2aec:	ea47 2404 	orr.w	r4, r7, r4, lsl #8
    2af0:	6035      	str	r5, [r6, #0]
    2af2:	e000      	b.n	2af6 <get_achar+0x36>
    2af4:	4604      	mov	r4, r0
	}
#endif

#endif
	return chr;
}
    2af6:	4620      	mov	r0, r4
    2af8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00002afa <pattern_matching>:
	const TCHAR* pat,	/* Matching pattern */
	const TCHAR* nam,	/* String to be tested */
	int skip,			/* Number of pre-skip chars (number of ?s) */
	int inf				/* Infinite search (* specified) */
)
{
    2afa:	b5f0      	push	{r4, r5, r6, r7, lr}
    2afc:	b085      	sub	sp, #20
    2afe:	4605      	mov	r5, r0
    2b00:	9101      	str	r1, [sp, #4]
    2b02:	461c      	mov	r4, r3
			if (pc == 0) return 1;	/* Branch matched? (matched at end of both strings) */
		}
		get_achar(&nam);			/* nam++ */
	} while (inf && nc);			/* Retry until end of name if infinite search is specified */

	return 0;
    2b04:	4617      	mov	r7, r2
	const TCHAR *pp, *np;
	DWORD pc, nc;
	int nm, nx;


	while (skip--) {				/* Pre-skip name chars */
    2b06:	e005      	b.n	2b14 <pattern_matching+0x1a>
		if (!get_achar(&nam)) return 0;	/* Branch mismatched if less name chars */
    2b08:	a801      	add	r0, sp, #4
    2b0a:	f7ff ffd9 	bl	2ac0 <get_achar>
    2b0e:	3f01      	subs	r7, #1
    2b10:	2800      	cmp	r0, #0
    2b12:	d040      	beq.n	2b96 <pattern_matching+0x9c>
	const TCHAR *pp, *np;
	DWORD pc, nc;
	int nm, nx;


	while (skip--) {				/* Pre-skip name chars */
    2b14:	2f00      	cmp	r7, #0
    2b16:	d1f7      	bne.n	2b08 <pattern_matching+0xe>
		if (!get_achar(&nam)) return 0;	/* Branch mismatched if less name chars */
	}
	if (*pat == 0 && inf) return 1;	/* (short circuit) */
    2b18:	782b      	ldrb	r3, [r5, #0]
    2b1a:	b90b      	cbnz	r3, 2b20 <pattern_matching+0x26>
    2b1c:	2c00      	cmp	r4, #0
    2b1e:	d137      	bne.n	2b90 <pattern_matching+0x96>

	do {
		pp = pat; np = nam;			/* Top of pattern and name to match */
    2b20:	9b01      	ldr	r3, [sp, #4]
    2b22:	9503      	str	r5, [sp, #12]
    2b24:	9302      	str	r3, [sp, #8]
		for (;;) {
			if (*pp == '?' || *pp == '*') {	/* Wildcard? */
    2b26:	9b03      	ldr	r3, [sp, #12]
    2b28:	781b      	ldrb	r3, [r3, #0]
    2b2a:	2b3f      	cmp	r3, #63	; 0x3f
    2b2c:	d003      	beq.n	2b36 <pattern_matching+0x3c>
    2b2e:	2b2a      	cmp	r3, #42	; 0x2a
    2b30:	d119      	bne.n	2b66 <pattern_matching+0x6c>
    2b32:	3b2a      	subs	r3, #42	; 0x2a
    2b34:	e000      	b.n	2b38 <pattern_matching+0x3e>
    2b36:	2300      	movs	r3, #0
    2b38:	461a      	mov	r2, r3
				nm = nx = 0;
				do {				/* Analyze the wildcard block */
					if (*pp++ == '?') nm++; else nx = 1;
    2b3a:	9903      	ldr	r1, [sp, #12]
    2b3c:	4608      	mov	r0, r1
    2b3e:	f810 6b01 	ldrb.w	r6, [r0], #1
    2b42:	2e3f      	cmp	r6, #63	; 0x3f
    2b44:	9003      	str	r0, [sp, #12]
    2b46:	d101      	bne.n	2b4c <pattern_matching+0x52>
    2b48:	3201      	adds	r2, #1
    2b4a:	e000      	b.n	2b4e <pattern_matching+0x54>
    2b4c:	2301      	movs	r3, #1
				} while (*pp == '?' || *pp == '*');
    2b4e:	7849      	ldrb	r1, [r1, #1]
    2b50:	293f      	cmp	r1, #63	; 0x3f
    2b52:	d0f2      	beq.n	2b3a <pattern_matching+0x40>
    2b54:	292a      	cmp	r1, #42	; 0x2a
    2b56:	d0f0      	beq.n	2b3a <pattern_matching+0x40>
				if (pattern_matching(pp, np, nm, nx)) return 1;	/* Test new branch (recurs upto number of wildcard blocks in the pattern) */
    2b58:	9902      	ldr	r1, [sp, #8]
    2b5a:	f7ff ffce 	bl	2afa <pattern_matching>
    2b5e:	b9b8      	cbnz	r0, 2b90 <pattern_matching+0x96>
				nc = *np; break;	/* Branch mismatched */
    2b60:	9b02      	ldr	r3, [sp, #8]
    2b62:	781e      	ldrb	r6, [r3, #0]
    2b64:	e00c      	b.n	2b80 <pattern_matching+0x86>
			}
			pc = get_achar(&pp);	/* Get a pattern char */
    2b66:	a803      	add	r0, sp, #12
    2b68:	f7ff ffaa 	bl	2ac0 <get_achar>
    2b6c:	4607      	mov	r7, r0
			nc = get_achar(&np);	/* Get a name char */
    2b6e:	a802      	add	r0, sp, #8
    2b70:	f7ff ffa6 	bl	2ac0 <get_achar>
			if (pc != nc) break;	/* Branch mismatched? */
    2b74:	4287      	cmp	r7, r0
				} while (*pp == '?' || *pp == '*');
				if (pattern_matching(pp, np, nm, nx)) return 1;	/* Test new branch (recurs upto number of wildcard blocks in the pattern) */
				nc = *np; break;	/* Branch mismatched */
			}
			pc = get_achar(&pp);	/* Get a pattern char */
			nc = get_achar(&np);	/* Get a name char */
    2b76:	4606      	mov	r6, r0
			if (pc != nc) break;	/* Branch mismatched? */
    2b78:	d102      	bne.n	2b80 <pattern_matching+0x86>
			if (pc == 0) return 1;	/* Branch matched? (matched at end of both strings) */
    2b7a:	2f00      	cmp	r7, #0
    2b7c:	d1d3      	bne.n	2b26 <pattern_matching+0x2c>
    2b7e:	e007      	b.n	2b90 <pattern_matching+0x96>
		}
		get_achar(&nam);			/* nam++ */
    2b80:	a801      	add	r0, sp, #4
    2b82:	f7ff ff9d 	bl	2ac0 <get_achar>
	} while (inf && nc);			/* Retry until end of name if infinite search is specified */
    2b86:	b12c      	cbz	r4, 2b94 <pattern_matching+0x9a>
    2b88:	2e00      	cmp	r6, #0
    2b8a:	d1c9      	bne.n	2b20 <pattern_matching+0x26>

	return 0;
    2b8c:	4630      	mov	r0, r6
    2b8e:	e002      	b.n	2b96 <pattern_matching+0x9c>
				nc = *np; break;	/* Branch mismatched */
			}
			pc = get_achar(&pp);	/* Get a pattern char */
			nc = get_achar(&np);	/* Get a name char */
			if (pc != nc) break;	/* Branch mismatched? */
			if (pc == 0) return 1;	/* Branch matched? (matched at end of both strings) */
    2b90:	2001      	movs	r0, #1
    2b92:	e000      	b.n	2b96 <pattern_matching+0x9c>
		}
		get_achar(&nam);			/* nam++ */
	} while (inf && nc);			/* Retry until end of name if infinite search is specified */

	return 0;
    2b94:	4620      	mov	r0, r4
}
    2b96:	b005      	add	sp, #20
    2b98:	bdf0      	pop	{r4, r5, r6, r7, pc}

00002b9a <get_ldnumber>:
#if FF_STR_VOLUME_ID		/* Find string volume ID */
	const char *sp;
	char c;
#endif

	tt = tp = *path;
    2b9a:	6803      	ldr	r3, [r0, #0]
/*-----------------------------------------------------------------------*/

static int get_ldnumber (	/* Returns logical drive number (-1:invalid drive number or null pointer) */
	const TCHAR** path		/* Pointer to pointer to the path name */
)
{
    2b9c:	b510      	push	{r4, lr}
	const char *sp;
	char c;
#endif

	tt = tp = *path;
	if (!tp) return vol;	/* Invalid path name? */
    2b9e:	b1db      	cbz	r3, 2bd8 <get_ldnumber+0x3e>
    2ba0:	461a      	mov	r2, r3
	do tc = *tt++; while ((UINT)tc >= (FF_USE_LFN ? ' ' : '!') && tc != ':');	/* Find a colon in the path */
    2ba2:	f812 1b01 	ldrb.w	r1, [r2], #1
    2ba6:	2920      	cmp	r1, #32
    2ba8:	d902      	bls.n	2bb0 <get_ldnumber+0x16>
    2baa:	293a      	cmp	r1, #58	; 0x3a
    2bac:	d1f9      	bne.n	2ba2 <get_ldnumber+0x8>
    2bae:	e00d      	b.n	2bcc <get_ldnumber+0x32>
		}
	}
#endif
	/* No drive prefix is found */
#if FF_FS_RPATH != 0
	vol = CurrVol;	/* Default drive is current drive */
    2bb0:	4b0b      	ldr	r3, [pc, #44]	; (2be0 <get_ldnumber+0x46>)
    2bb2:	7818      	ldrb	r0, [r3, #0]
#else
	vol = 0;		/* Default drive is 0 */
#endif
	return vol;		/* Return the default drive */
    2bb4:	bd10      	pop	{r4, pc}
	if (!tp) return vol;	/* Invalid path name? */
	do tc = *tt++; while ((UINT)tc >= (FF_USE_LFN ? ' ' : '!') && tc != ':');	/* Find a colon in the path */

	if (tc == ':') {	/* DOS/Windows style volume ID? */
		i = FF_VOLUMES;
		if (IsDigit(*tp) && tp + 2 == tt) {	/* Is there a numeric volume ID + colon? */
    2bb6:	3302      	adds	r3, #2
    2bb8:	4293      	cmp	r3, r2
    2bba:	d10d      	bne.n	2bd8 <get_ldnumber+0x3e>
					if (IsLower(tc)) tc -= 0x20;
				} while (c && (TCHAR)c == tc);
			} while ((c || tp != tt) && ++i < FF_VOLUMES);	/* Repeat for each id until pattern match */
		}
#endif
		if (i < FF_VOLUMES) {	/* If a volume ID is found, get the drive number and strip it */
    2bbc:	2930      	cmp	r1, #48	; 0x30
    2bbe:	d102      	bne.n	2bc6 <get_ldnumber+0x2c>
			vol = i;		/* Drive number */
			*path = tt;		/* Snip the drive prefix off */
    2bc0:	6002      	str	r2, [r0, #0]
    2bc2:	2000      	movs	r0, #0
    2bc4:	bd10      	pop	{r4, pc}
	const TCHAR** path		/* Pointer to pointer to the path name */
)
{
	const TCHAR *tp, *tt;
	TCHAR tc;
	int i, vol = -1;
    2bc6:	f04f 30ff 	mov.w	r0, #4294967295
	vol = CurrVol;	/* Default drive is current drive */
#else
	vol = 0;		/* Default drive is 0 */
#endif
	return vol;		/* Return the default drive */
}
    2bca:	bd10      	pop	{r4, pc}
	if (!tp) return vol;	/* Invalid path name? */
	do tc = *tt++; while ((UINT)tc >= (FF_USE_LFN ? ' ' : '!') && tc != ':');	/* Find a colon in the path */

	if (tc == ':') {	/* DOS/Windows style volume ID? */
		i = FF_VOLUMES;
		if (IsDigit(*tp) && tp + 2 == tt) {	/* Is there a numeric volume ID + colon? */
    2bcc:	7819      	ldrb	r1, [r3, #0]
    2bce:	f1a1 0430 	sub.w	r4, r1, #48	; 0x30
    2bd2:	b2e4      	uxtb	r4, r4
    2bd4:	2c09      	cmp	r4, #9
    2bd6:	d9ee      	bls.n	2bb6 <get_ldnumber+0x1c>
	const TCHAR** path		/* Pointer to pointer to the path name */
)
{
	const TCHAR *tp, *tt;
	TCHAR tc;
	int i, vol = -1;
    2bd8:	f04f 30ff 	mov.w	r0, #4294967295
    2bdc:	bd10      	pop	{r4, pc}
    2bde:	bf00      	nop
    2be0:	1000012c 	.word	0x1000012c

00002be4 <sync_window>:
/*-----------------------------------------------------------------------*/
#if !FF_FS_READONLY
static FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERR */
	FATFS* fs			/* Filesystem object */
)
{
    2be4:	b570      	push	{r4, r5, r6, lr}
	FRESULT res = FR_OK;


	if (fs->wflag) {	/* Is the disk access window dirty */
    2be6:	78c5      	ldrb	r5, [r0, #3]
/*-----------------------------------------------------------------------*/
#if !FF_FS_READONLY
static FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERR */
	FATFS* fs			/* Filesystem object */
)
{
    2be8:	4604      	mov	r4, r0
	FRESULT res = FR_OK;


	if (fs->wflag) {	/* Is the disk access window dirty */
    2bea:	b1dd      	cbz	r5, 2c24 <sync_window+0x40>
		if (disk_write(fs->pdrv, fs->win, fs->winsect, 1) == RES_OK) {	/* Write back the window */
    2bec:	f100 0634 	add.w	r6, r0, #52	; 0x34
    2bf0:	4631      	mov	r1, r6
    2bf2:	7840      	ldrb	r0, [r0, #1]
    2bf4:	6b22      	ldr	r2, [r4, #48]	; 0x30
    2bf6:	2301      	movs	r3, #1
    2bf8:	f7ff fd24 	bl	2644 <disk_write>
    2bfc:	4605      	mov	r5, r0
    2bfe:	b980      	cbnz	r0, 2c22 <sync_window+0x3e>
			fs->wflag = 0;	/* Clear window dirty flag */
			if (fs->winsect - fs->fatbase < fs->fsize) {	/* Is it in the 1st FAT? */
    2c00:	6b23      	ldr	r3, [r4, #48]	; 0x30
    2c02:	6a61      	ldr	r1, [r4, #36]	; 0x24
    2c04:	69e2      	ldr	r2, [r4, #28]
    2c06:	1a59      	subs	r1, r3, r1
    2c08:	4291      	cmp	r1, r2
	FRESULT res = FR_OK;


	if (fs->wflag) {	/* Is the disk access window dirty */
		if (disk_write(fs->pdrv, fs->win, fs->winsect, 1) == RES_OK) {	/* Write back the window */
			fs->wflag = 0;	/* Clear window dirty flag */
    2c0a:	70e0      	strb	r0, [r4, #3]
			if (fs->winsect - fs->fatbase < fs->fsize) {	/* Is it in the 1st FAT? */
    2c0c:	d20a      	bcs.n	2c24 <sync_window+0x40>
				if (fs->n_fats == 2) disk_write(fs->pdrv, fs->win, fs->winsect + fs->fsize, 1);	/* Reflect it to 2nd FAT if needed */
    2c0e:	78a1      	ldrb	r1, [r4, #2]
    2c10:	2902      	cmp	r1, #2
    2c12:	d107      	bne.n	2c24 <sync_window+0x40>
    2c14:	18d2      	adds	r2, r2, r3
    2c16:	7860      	ldrb	r0, [r4, #1]
    2c18:	4631      	mov	r1, r6
    2c1a:	2301      	movs	r3, #1
    2c1c:	f7ff fd12 	bl	2644 <disk_write>
    2c20:	e000      	b.n	2c24 <sync_window+0x40>
			}
		} else {
			res = FR_DISK_ERR;
    2c22:	2501      	movs	r5, #1
		}
	}
	return res;
}
    2c24:	4628      	mov	r0, r5
    2c26:	bd70      	pop	{r4, r5, r6, pc}

00002c28 <dir_clear>:
#if !FF_FS_READONLY
static FRESULT dir_clear (	/* Returns FR_OK or FR_DISK_ERR */
	FATFS *fs,		/* Filesystem object */
	DWORD clst		/* Directory table to clear */
)
{
    2c28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2c2a:	4604      	mov	r4, r0
    2c2c:	460e      	mov	r6, r1
	DWORD sect;
	UINT n, szb;
	BYTE *ibuf;


	if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
    2c2e:	f7ff ffd9 	bl	2be4 <sync_window>
    2c32:	4605      	mov	r5, r0
    2c34:	b9f8      	cbnz	r0, 2c76 <dir_clear+0x4e>
	sect = clst2sect(fs, clst);		/* Top of the cluster */
    2c36:	4631      	mov	r1, r6
    2c38:	4620      	mov	r0, r4
    2c3a:	f7ff ff04 	bl	2a46 <clst2sect>
	fs->winsect = sect;				/* Set window to top of the cluster */
	mem_set(fs->win, 0, sizeof fs->win);	/* Clear window buffer */
    2c3e:	f104 0634 	add.w	r6, r4, #52	; 0x34
	UINT n, szb;
	BYTE *ibuf;


	if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
	sect = clst2sect(fs, clst);		/* Top of the cluster */
    2c42:	4607      	mov	r7, r0
	fs->winsect = sect;				/* Set window to top of the cluster */
    2c44:	6320      	str	r0, [r4, #48]	; 0x30
	mem_set(fs->win, 0, sizeof fs->win);	/* Clear window buffer */
    2c46:	4629      	mov	r1, r5
    2c48:	4630      	mov	r0, r6
    2c4a:	f44f 7200 	mov.w	r2, #512	; 0x200
    2c4e:	f7ff febf 	bl	29d0 <mem_set>
		ff_memfree(ibuf);
	} else
#endif
	{
		ibuf = fs->win; szb = 1;	/* Use window buffer (many single-sector writes may take a time) */
		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
    2c52:	e000      	b.n	2c56 <dir_clear+0x2e>
    2c54:	3501      	adds	r5, #1
    2c56:	8963      	ldrh	r3, [r4, #10]
    2c58:	429d      	cmp	r5, r3
    2c5a:	d207      	bcs.n	2c6c <dir_clear+0x44>
    2c5c:	7860      	ldrb	r0, [r4, #1]
    2c5e:	4631      	mov	r1, r6
    2c60:	19ea      	adds	r2, r5, r7
    2c62:	2301      	movs	r3, #1
    2c64:	f7ff fcee 	bl	2644 <disk_write>
    2c68:	2800      	cmp	r0, #0
    2c6a:	d0f3      	beq.n	2c54 <dir_clear+0x2c>
	}
	return (n == fs->csize) ? FR_OK : FR_DISK_ERR;
    2c6c:	8960      	ldrh	r0, [r4, #10]
    2c6e:	1a28      	subs	r0, r5, r0
    2c70:	bf18      	it	ne
    2c72:	2001      	movne	r0, #1
    2c74:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	DWORD sect;
	UINT n, szb;
	BYTE *ibuf;


	if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
    2c76:	2001      	movs	r0, #1
	{
		ibuf = fs->win; szb = 1;	/* Use window buffer (many single-sector writes may take a time) */
		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
	}
	return (n == fs->csize) ? FR_OK : FR_DISK_ERR;
}
    2c78:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00002c7a <sync_fs>:
/*-----------------------------------------------------------------------*/

static FRESULT sync_fs (	/* Returns FR_OK or FR_DISK_ERR */
	FATFS* fs		/* Filesystem object */
)
{
    2c7a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2c7c:	4604      	mov	r4, r0
	FRESULT res;


	res = sync_window(fs);
    2c7e:	f7ff ffb1 	bl	2be4 <sync_window>
    2c82:	4605      	mov	r5, r0
	if (res == FR_OK) {
    2c84:	2d00      	cmp	r5, #0
    2c86:	d138      	bne.n	2cfa <sync_fs+0x80>
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {	/* FAT32: Update FSInfo sector if needed */
    2c88:	7823      	ldrb	r3, [r4, #0]
    2c8a:	2b03      	cmp	r3, #3
    2c8c:	d12d      	bne.n	2cea <sync_fs+0x70>
    2c8e:	7927      	ldrb	r7, [r4, #4]
    2c90:	2f01      	cmp	r7, #1
    2c92:	d12a      	bne.n	2cea <sync_fs+0x70>
			/* Create FSInfo structure */
			mem_set(fs->win, 0, sizeof fs->win);
    2c94:	f104 0634 	add.w	r6, r4, #52	; 0x34
    2c98:	f44f 7200 	mov.w	r2, #512	; 0x200
    2c9c:	4630      	mov	r0, r6
    2c9e:	4629      	mov	r1, r5
    2ca0:	f7ff fe96 	bl	29d0 <mem_set>
			st_word(fs->win + BS_55AA, 0xAA55);
    2ca4:	f504 700c 	add.w	r0, r4, #560	; 0x230
    2ca8:	3002      	adds	r0, #2
    2caa:	f64a 2155 	movw	r1, #43605	; 0xaa55
    2cae:	f7ff fe79 	bl	29a4 <st_word>
			st_dword(fs->win + FSI_LeadSig, 0x41615252);
    2cb2:	4630      	mov	r0, r6
    2cb4:	4911      	ldr	r1, [pc, #68]	; (2cfc <sync_fs+0x82>)
    2cb6:	f7ff fe79 	bl	29ac <st_dword>
			st_dword(fs->win + FSI_StrucSig, 0x61417272);
    2cba:	f504 7006 	add.w	r0, r4, #536	; 0x218
    2cbe:	4910      	ldr	r1, [pc, #64]	; (2d00 <sync_fs+0x86>)
    2cc0:	f7ff fe74 	bl	29ac <st_dword>
			st_dword(fs->win + FSI_Free_Count, fs->free_clst);
    2cc4:	f504 7007 	add.w	r0, r4, #540	; 0x21c
    2cc8:	6921      	ldr	r1, [r4, #16]
    2cca:	f7ff fe6f 	bl	29ac <st_dword>
			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);
    2cce:	f504 7008 	add.w	r0, r4, #544	; 0x220
    2cd2:	68e1      	ldr	r1, [r4, #12]
    2cd4:	f7ff fe6a 	bl	29ac <st_dword>
			/* Write it into the FSInfo sector */
			fs->winsect = fs->volbase + 1;
    2cd8:	6a22      	ldr	r2, [r4, #32]
			disk_write(fs->pdrv, fs->win, fs->winsect, 1);
    2cda:	7860      	ldrb	r0, [r4, #1]
			st_dword(fs->win + FSI_LeadSig, 0x41615252);
			st_dword(fs->win + FSI_StrucSig, 0x61417272);
			st_dword(fs->win + FSI_Free_Count, fs->free_clst);
			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);
			/* Write it into the FSInfo sector */
			fs->winsect = fs->volbase + 1;
    2cdc:	3201      	adds	r2, #1
    2cde:	6322      	str	r2, [r4, #48]	; 0x30
			disk_write(fs->pdrv, fs->win, fs->winsect, 1);
    2ce0:	4631      	mov	r1, r6
    2ce2:	463b      	mov	r3, r7
    2ce4:	f7ff fcae 	bl	2644 <disk_write>
			fs->fsi_flag = 0;
    2ce8:	7125      	strb	r5, [r4, #4]
		}
		/* Make sure that no pending write process in the lower layer */
		if (disk_ioctl(fs->pdrv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
    2cea:	2100      	movs	r1, #0
    2cec:	7860      	ldrb	r0, [r4, #1]
    2cee:	460a      	mov	r2, r1
    2cf0:	f7ff fcfc 	bl	26ec <disk_ioctl>
    2cf4:	3800      	subs	r0, #0
    2cf6:	bf18      	it	ne
    2cf8:	2001      	movne	r0, #1
	}

	return res;
}
    2cfa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2cfc:	41615252 	.word	0x41615252
    2d00:	61417272 	.word	0x61417272

00002d04 <validate>:

static FRESULT validate (	/* Returns FR_OK or FR_INVALID_OBJECT */
	FFOBJID* obj,			/* Pointer to the FFOBJID, the 1st member in the FIL/DIR object, to check validity */
	FATFS** rfs				/* Pointer to pointer to the owner filesystem object to return */
)
{
    2d04:	b538      	push	{r3, r4, r5, lr}
    2d06:	460d      	mov	r5, r1
	FRESULT res = FR_INVALID_OBJECT;


	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
    2d08:	4604      	mov	r4, r0
    2d0a:	b168      	cbz	r0, 2d28 <validate+0x24>
    2d0c:	6803      	ldr	r3, [r0, #0]
    2d0e:	b15b      	cbz	r3, 2d28 <validate+0x24>
    2d10:	781a      	ldrb	r2, [r3, #0]
    2d12:	b14a      	cbz	r2, 2d28 <validate+0x24>
    2d14:	8881      	ldrh	r1, [r0, #4]
    2d16:	88da      	ldrh	r2, [r3, #6]
    2d18:	4291      	cmp	r1, r2
    2d1a:	d105      	bne.n	2d28 <validate+0x24>
			}
		} else {
			res = FR_TIMEOUT;
		}
#else
		if (!(disk_status(obj->fs->pdrv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
    2d1c:	7858      	ldrb	r0, [r3, #1]
    2d1e:	f7ff fc4f 	bl	25c0 <disk_status>
    2d22:	f010 0001 	ands.w	r0, r0, #1
    2d26:	d003      	beq.n	2d30 <validate+0x2c>
			res = FR_OK;
    2d28:	2009      	movs	r0, #9
		}
#endif
	}
	*rfs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
    2d2a:	2300      	movs	r3, #0
    2d2c:	602b      	str	r3, [r5, #0]
	return res;
}
    2d2e:	bd38      	pop	{r3, r4, r5, pc}
		if (!(disk_status(obj->fs->pdrv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
			res = FR_OK;
		}
#endif
	}
	*rfs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
    2d30:	6823      	ldr	r3, [r4, #0]
    2d32:	e7fb      	b.n	2d2c <validate+0x28>

00002d34 <move_window>:

static FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERR */
	FATFS* fs,			/* Filesystem object */
	DWORD sector		/* Sector number to make appearance in the fs->win[] */
)
{
    2d34:	b538      	push	{r3, r4, r5, lr}
	FRESULT res = FR_OK;


	if (sector != fs->winsect) {	/* Window offset changed? */
    2d36:	6b03      	ldr	r3, [r0, #48]	; 0x30

static FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERR */
	FATFS* fs,			/* Filesystem object */
	DWORD sector		/* Sector number to make appearance in the fs->win[] */
)
{
    2d38:	4605      	mov	r5, r0
	FRESULT res = FR_OK;


	if (sector != fs->winsect) {	/* Window offset changed? */
    2d3a:	4299      	cmp	r1, r3

static FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERR */
	FATFS* fs,			/* Filesystem object */
	DWORD sector		/* Sector number to make appearance in the fs->win[] */
)
{
    2d3c:	460c      	mov	r4, r1
	FRESULT res = FR_OK;


	if (sector != fs->winsect) {	/* Window offset changed? */
    2d3e:	d012      	beq.n	2d66 <move_window+0x32>
#if !FF_FS_READONLY
		res = sync_window(fs);		/* Write-back changes */
    2d40:	f7ff ff50 	bl	2be4 <sync_window>
#endif
		if (res == FR_OK) {			/* Fill sector window with new data */
    2d44:	b980      	cbnz	r0, 2d68 <move_window+0x34>
			if (disk_read(fs->pdrv, fs->win, sector, 1) != RES_OK) {
    2d46:	4622      	mov	r2, r4
    2d48:	2301      	movs	r3, #1
    2d4a:	7868      	ldrb	r0, [r5, #1]
    2d4c:	f105 0134 	add.w	r1, r5, #52	; 0x34
    2d50:	f7ff fc3e 	bl	25d0 <disk_read>
    2d54:	2800      	cmp	r0, #0
				sector = 0xFFFFFFFF;	/* Invalidate window if read data is not valid */
				res = FR_DISK_ERR;
    2d56:	bf18      	it	ne
    2d58:	f04f 34ff 	movne.w	r4, #4294967295
    2d5c:	bf0c      	ite	eq
    2d5e:	2000      	moveq	r0, #0
    2d60:	2001      	movne	r0, #1
			}
			fs->winsect = sector;
    2d62:	632c      	str	r4, [r5, #48]	; 0x30
    2d64:	bd38      	pop	{r3, r4, r5, pc}
static FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERR */
	FATFS* fs,			/* Filesystem object */
	DWORD sector		/* Sector number to make appearance in the fs->win[] */
)
{
	FRESULT res = FR_OK;
    2d66:	2000      	movs	r0, #0
			}
			fs->winsect = sector;
		}
	}
	return res;
}
    2d68:	bd38      	pop	{r3, r4, r5, pc}

00002d6a <check_fs>:
static BYTE check_fs (	/* 0:FAT, 1:exFAT, 2:Valid BS but not FAT, 3:Not a BS, 4:Disk error */
	FATFS* fs,			/* Filesystem object */
	DWORD sect			/* Sector# (lba) to load and check if it is an FAT-VBR or not */
)
{
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
    2d6a:	2300      	movs	r3, #0

static BYTE check_fs (	/* 0:FAT, 1:exFAT, 2:Valid BS but not FAT, 3:Not a BS, 4:Disk error */
	FATFS* fs,			/* Filesystem object */
	DWORD sect			/* Sector# (lba) to load and check if it is an FAT-VBR or not */
)
{
    2d6c:	b510      	push	{r4, lr}
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
    2d6e:	70c3      	strb	r3, [r0, #3]
    2d70:	3b01      	subs	r3, #1
    2d72:	6303      	str	r3, [r0, #48]	; 0x30

static BYTE check_fs (	/* 0:FAT, 1:exFAT, 2:Valid BS but not FAT, 3:Not a BS, 4:Disk error */
	FATFS* fs,			/* Filesystem object */
	DWORD sect			/* Sector# (lba) to load and check if it is an FAT-VBR or not */
)
{
    2d74:	4604      	mov	r4, r0
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
    2d76:	f7ff ffdd 	bl	2d34 <move_window>
    2d7a:	bb10      	cbnz	r0, 2dc2 <check_fs+0x58>

	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always here regardless of the sector size) */
    2d7c:	f504 700c 	add.w	r0, r4, #560	; 0x230
    2d80:	3002      	adds	r0, #2
    2d82:	f7ff fdff 	bl	2984 <ld_word>
    2d86:	f64a 2355 	movw	r3, #43605	; 0xaa55
    2d8a:	4298      	cmp	r0, r3
    2d8c:	d11b      	bne.n	2dc6 <check_fs+0x5c>

#if FF_FS_EXFAT
	if (!mem_cmp(fs->win + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11)) return 1;	/* Check if exFAT VBR */
#endif
	if (fs->win[BS_JmpBoot] == 0xE9 || fs->win[BS_JmpBoot] == 0xEB || fs->win[BS_JmpBoot] == 0xE8) {	/* Valid JumpBoot code? */
    2d8e:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
    2d92:	2be9      	cmp	r3, #233	; 0xe9
    2d94:	d003      	beq.n	2d9e <check_fs+0x34>
    2d96:	2beb      	cmp	r3, #235	; 0xeb
    2d98:	d001      	beq.n	2d9e <check_fs+0x34>
    2d9a:	2be8      	cmp	r3, #232	; 0xe8
    2d9c:	d115      	bne.n	2dca <check_fs+0x60>
		if (!mem_cmp(fs->win + BS_FilSysType, "FAT", 3)) return 0;		/* Is it an FAT VBR? */
    2d9e:	f104 006a 	add.w	r0, r4, #106	; 0x6a
    2da2:	490b      	ldr	r1, [pc, #44]	; (2dd0 <check_fs+0x66>)
    2da4:	2203      	movs	r2, #3
    2da6:	f7ff fe18 	bl	29da <mem_cmp>
    2daa:	b178      	cbz	r0, 2dcc <check_fs+0x62>
		if (!mem_cmp(fs->win + BS_FilSysType32, "FAT32", 5)) return 0;	/* Is it an FAT32 VBR? */
    2dac:	f104 0086 	add.w	r0, r4, #134	; 0x86
    2db0:	4908      	ldr	r1, [pc, #32]	; (2dd4 <check_fs+0x6a>)
    2db2:	2205      	movs	r2, #5
    2db4:	f7ff fe11 	bl	29da <mem_cmp>
	}
	return 2;	/* Valid BS but not FAT */
    2db8:	2800      	cmp	r0, #0
    2dba:	bf14      	ite	ne
    2dbc:	2002      	movne	r0, #2
    2dbe:	2000      	moveq	r0, #0
    2dc0:	bd10      	pop	{r4, pc}
	FATFS* fs,			/* Filesystem object */
	DWORD sect			/* Sector# (lba) to load and check if it is an FAT-VBR or not */
)
{
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
    2dc2:	2004      	movs	r0, #4
    2dc4:	bd10      	pop	{r4, pc}

	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always here regardless of the sector size) */
    2dc6:	2003      	movs	r0, #3
    2dc8:	bd10      	pop	{r4, pc}
#endif
	if (fs->win[BS_JmpBoot] == 0xE9 || fs->win[BS_JmpBoot] == 0xEB || fs->win[BS_JmpBoot] == 0xE8) {	/* Valid JumpBoot code? */
		if (!mem_cmp(fs->win + BS_FilSysType, "FAT", 3)) return 0;		/* Is it an FAT VBR? */
		if (!mem_cmp(fs->win + BS_FilSysType32, "FAT32", 5)) return 0;	/* Is it an FAT32 VBR? */
	}
	return 2;	/* Valid BS but not FAT */
    2dca:	2002      	movs	r0, #2
}
    2dcc:	bd10      	pop	{r4, pc}
    2dce:	bf00      	nop
    2dd0:	00005c24 	.word	0x00005c24
    2dd4:	00005c1c 	.word	0x00005c1c

00002dd8 <find_volume>:
static FRESULT find_volume (	/* FR_OK(0): successful, !=0: an error occurred */
	const TCHAR** path,			/* Pointer to pointer to the path name (drive number) */
	FATFS** rfs,				/* Pointer to pointer to the found filesystem object */
	BYTE mode					/* !=0: Check write protection for write access */
)
{
    2dd8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	FATFS *fs;
	UINT i;


	/* Get logical drive number */
	*rfs = 0;
    2ddc:	2300      	movs	r3, #0
static FRESULT find_volume (	/* FR_OK(0): successful, !=0: an error occurred */
	const TCHAR** path,			/* Pointer to pointer to the path name (drive number) */
	FATFS** rfs,				/* Pointer to pointer to the found filesystem object */
	BYTE mode					/* !=0: Check write protection for write access */
)
{
    2dde:	b085      	sub	sp, #20
	FATFS *fs;
	UINT i;


	/* Get logical drive number */
	*rfs = 0;
    2de0:	600b      	str	r3, [r1, #0]
static FRESULT find_volume (	/* FR_OK(0): successful, !=0: an error occurred */
	const TCHAR** path,			/* Pointer to pointer to the path name (drive number) */
	FATFS** rfs,				/* Pointer to pointer to the found filesystem object */
	BYTE mode					/* !=0: Check write protection for write access */
)
{
    2de2:	460d      	mov	r5, r1
    2de4:	4690      	mov	r8, r2
	UINT i;


	/* Get logical drive number */
	*rfs = 0;
	vol = get_ldnumber(path);
    2de6:	f7ff fed8 	bl	2b9a <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
    2dea:	1e06      	subs	r6, r0, #0
    2dec:	f2c0 812f 	blt.w	304e <find_volume+0x276>

	/* Check if the filesystem object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the filesystem object */
    2df0:	4f9f      	ldr	r7, [pc, #636]	; (3070 <find_volume+0x298>)
    2df2:	eb07 0386 	add.w	r3, r7, r6, lsl #2
    2df6:	685c      	ldr	r4, [r3, #4]
	if (!fs) return FR_NOT_ENABLED;		/* Is the filesystem object available? */
    2df8:	2c00      	cmp	r4, #0
    2dfa:	f000 812a 	beq.w	3052 <find_volume+0x27a>
#if FF_FS_REENTRANT
	if (!lock_fs(fs)) return FR_TIMEOUT;	/* Lock the volume */
#endif
	*rfs = fs;							/* Return pointer to the filesystem object */
    2dfe:	602c      	str	r4, [r5, #0]

	mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
	if (fs->fs_type != 0) {				/* If the volume has been mounted */
    2e00:	7823      	ldrb	r3, [r4, #0]
#if FF_FS_REENTRANT
	if (!lock_fs(fs)) return FR_TIMEOUT;	/* Lock the volume */
#endif
	*rfs = fs;							/* Return pointer to the filesystem object */

	mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
    2e02:	f008 05fe 	and.w	r5, r8, #254	; 0xfe
	if (fs->fs_type != 0) {				/* If the volume has been mounted */
    2e06:	b16b      	cbz	r3, 2e24 <find_volume+0x4c>
		stat = disk_status(fs->pdrv);
    2e08:	7860      	ldrb	r0, [r4, #1]
    2e0a:	f7ff fbd9 	bl	25c0 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
    2e0e:	f010 0f01 	tst.w	r0, #1
    2e12:	d107      	bne.n	2e24 <find_volume+0x4c>
			if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
    2e14:	2d00      	cmp	r5, #0
    2e16:	f000 811e 	beq.w	3056 <find_volume+0x27e>
				return FR_WRITE_PROTECTED;
    2e1a:	f010 0004 	ands.w	r0, r0, #4
    2e1e:	bf18      	it	ne
    2e20:	200a      	movne	r0, #10
    2e22:	e121      	b.n	3068 <find_volume+0x290>
	}

	/* The filesystem object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the filesystem object) */

	fs->fs_type = 0;					/* Clear the filesystem object */
    2e24:	2300      	movs	r3, #0
	fs->pdrv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
    2e26:	b2f0      	uxtb	r0, r6
	}

	/* The filesystem object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the filesystem object) */

	fs->fs_type = 0;					/* Clear the filesystem object */
    2e28:	7023      	strb	r3, [r4, #0]
	fs->pdrv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
    2e2a:	7060      	strb	r0, [r4, #1]
	stat = disk_initialize(fs->pdrv);	/* Initialize the physical drive */
    2e2c:	f7ff faee 	bl	240c <disk_initialize>
	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
    2e30:	f010 0f01 	tst.w	r0, #1
    2e34:	f040 8111 	bne.w	305a <find_volume+0x282>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
	}
	if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
    2e38:	b11d      	cbz	r5, 2e42 <find_volume+0x6a>
    2e3a:	f010 0f04 	tst.w	r0, #4
    2e3e:	f040 810e 	bne.w	305e <find_volume+0x286>
	if (SS(fs) > FF_MAX_SS || SS(fs) < FF_MIN_SS || (SS(fs) & (SS(fs) - 1))) return FR_DISK_ERR;
#endif

	/* Find an FAT partition on the drive. Supports only generic partitioning rules, FDISK (MBR) and SFD (w/o partition). */
	bsect = 0;
	fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT-VBR as SFD */
    2e42:	2100      	movs	r1, #0
    2e44:	4620      	mov	r0, r4
    2e46:	f7ff ff90 	bl	2d6a <check_fs>
	if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
    2e4a:	2802      	cmp	r0, #2
    2e4c:	d122      	bne.n	2e94 <find_volume+0xbc>
    2e4e:	f1ad 0604 	sub.w	r6, sp, #4
    2e52:	f44f 75df 	mov.w	r5, #446	; 0x1be
		for (i = 0; i < 4; i++) {		/* Get partition offset */
			pt = fs->win + (MBR_Table + i * SZ_PTE);
    2e56:	f105 0330 	add.w	r3, r5, #48	; 0x30
    2e5a:	18e3      	adds	r3, r4, r3
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
    2e5c:	7a18      	ldrb	r0, [r3, #8]
    2e5e:	b118      	cbz	r0, 2e68 <find_volume+0x90>
    2e60:	f103 000c 	add.w	r0, r3, #12
    2e64:	f7ff fd93 	bl	298e <ld_dword>
    2e68:	3510      	adds	r5, #16

	/* Find an FAT partition on the drive. Supports only generic partitioning rules, FDISK (MBR) and SFD (w/o partition). */
	bsect = 0;
	fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT-VBR as SFD */
	if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
		for (i = 0; i < 4; i++) {		/* Get partition offset */
    2e6a:	f5b5 7fff 	cmp.w	r5, #510	; 0x1fe
			pt = fs->win + (MBR_Table + i * SZ_PTE);
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
    2e6e:	f846 0f04 	str.w	r0, [r6, #4]!

	/* Find an FAT partition on the drive. Supports only generic partitioning rules, FDISK (MBR) and SFD (w/o partition). */
	bsect = 0;
	fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT-VBR as SFD */
	if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
		for (i = 0; i < 4; i++) {		/* Get partition offset */
    2e72:	d1f0      	bne.n	2e56 <find_volume+0x7e>
    2e74:	2600      	movs	r6, #0
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
		}
		i = LD2PT(vol);					/* Partition number: 0:auto, 1-4:forced */
		if (i != 0) i--;
		do {							/* Find an FAT volume */
			bsect = br[i];
    2e76:	f85d 5006 	ldr.w	r5, [sp, r6]
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
    2e7a:	b135      	cbz	r5, 2e8a <find_volume+0xb2>
    2e7c:	4620      	mov	r0, r4
    2e7e:	4629      	mov	r1, r5
    2e80:	f7ff ff73 	bl	2d6a <check_fs>
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
    2e84:	2801      	cmp	r0, #1
    2e86:	d801      	bhi.n	2e8c <find_volume+0xb4>
    2e88:	e00b      	b.n	2ea2 <find_volume+0xca>
		}
		i = LD2PT(vol);					/* Partition number: 0:auto, 1-4:forced */
		if (i != 0) i--;
		do {							/* Find an FAT volume */
			bsect = br[i];
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
    2e8a:	2003      	movs	r0, #3
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
    2e8c:	3604      	adds	r6, #4
    2e8e:	2e10      	cmp	r6, #16
    2e90:	d1f1      	bne.n	2e76 <find_volume+0x9e>
    2e92:	e000      	b.n	2e96 <find_volume+0xbe>
	if (disk_ioctl(fs->pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK) return FR_DISK_ERR;
	if (SS(fs) > FF_MAX_SS || SS(fs) < FF_MIN_SS || (SS(fs) & (SS(fs) - 1))) return FR_DISK_ERR;
#endif

	/* Find an FAT partition on the drive. Supports only generic partitioning rules, FDISK (MBR) and SFD (w/o partition). */
	bsect = 0;
    2e94:	2500      	movs	r5, #0
		do {							/* Find an FAT volume */
			bsect = br[i];
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
	}
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
    2e96:	2804      	cmp	r0, #4
    2e98:	f000 80e3 	beq.w	3062 <find_volume+0x28a>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
    2e9c:	2801      	cmp	r0, #1
    2e9e:	f200 80e2 	bhi.w	3066 <find_volume+0x28e>
#endif
		fmt = FS_EXFAT;			/* FAT sub-type */
	} else
#endif	/* FF_FS_EXFAT */
	{
		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
    2ea2:	f104 003f 	add.w	r0, r4, #63	; 0x3f
    2ea6:	f7ff fd6d 	bl	2984 <ld_word>
    2eaa:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
    2eae:	f040 80da 	bne.w	3066 <find_volume+0x28e>

		fasize = ld_word(fs->win + BPB_FATSz16);		/* Number of sectors per FAT */
    2eb2:	f104 004a 	add.w	r0, r4, #74	; 0x4a
    2eb6:	f7ff fd65 	bl	2984 <ld_word>
		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
    2eba:	4680      	mov	r8, r0
    2ebc:	b920      	cbnz	r0, 2ec8 <find_volume+0xf0>
    2ebe:	f104 0058 	add.w	r0, r4, #88	; 0x58
    2ec2:	f7ff fd64 	bl	298e <ld_dword>
    2ec6:	4680      	mov	r8, r0
		fs->fsize = fasize;

		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
    2ec8:	f894 b044 	ldrb.w	fp, [r4, #68]	; 0x44
	{
		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */

		fasize = ld_word(fs->win + BPB_FATSz16);		/* Number of sectors per FAT */
		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
		fs->fsize = fasize;
    2ecc:	f8c4 801c 	str.w	r8, [r4, #28]

		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
    2ed0:	f10b 33ff 	add.w	r3, fp, #4294967295
    2ed4:	b2db      	uxtb	r3, r3
    2ed6:	2b01      	cmp	r3, #1

		fasize = ld_word(fs->win + BPB_FATSz16);		/* Number of sectors per FAT */
		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
		fs->fsize = fasize;

		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
    2ed8:	f884 b002 	strb.w	fp, [r4, #2]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
    2edc:	f200 80c3 	bhi.w	3066 <find_volume+0x28e>
		fasize *= fs->n_fats;							/* Number of sectors for FAT area */

		fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
    2ee0:	f894 6041 	ldrb.w	r6, [r4, #65]	; 0x41
    2ee4:	8166      	strh	r6, [r4, #10]
		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
    2ee6:	2e00      	cmp	r6, #0
    2ee8:	f000 80bd 	beq.w	3066 <find_volume+0x28e>
    2eec:	1e73      	subs	r3, r6, #1
    2eee:	4233      	tst	r3, r6
    2ef0:	f040 80b9 	bne.w	3066 <find_volume+0x28e>

		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
    2ef4:	f104 0045 	add.w	r0, r4, #69	; 0x45
    2ef8:	f7ff fd44 	bl	2984 <ld_word>
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
    2efc:	f010 0f0f 	tst.w	r0, #15
		fasize *= fs->n_fats;							/* Number of sectors for FAT area */

		fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */

		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
    2f00:	4682      	mov	sl, r0
    2f02:	8120      	strh	r0, [r4, #8]
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
    2f04:	f040 80af 	bne.w	3066 <find_volume+0x28e>

		tsect = ld_word(fs->win + BPB_TotSec16);		/* Number of sectors on the volume */
    2f08:	f104 0047 	add.w	r0, r4, #71	; 0x47
    2f0c:	f7ff fd3a 	bl	2984 <ld_word>
		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
    2f10:	4681      	mov	r9, r0
    2f12:	b920      	cbnz	r0, 2f1e <find_volume+0x146>
    2f14:	f104 0054 	add.w	r0, r4, #84	; 0x54
    2f18:	f7ff fd39 	bl	298e <ld_dword>
    2f1c:	4681      	mov	r9, r0

		nrsv = ld_word(fs->win + BPB_RsvdSecCnt);		/* Number of reserved sectors */
    2f1e:	f104 0042 	add.w	r0, r4, #66	; 0x42
    2f22:	f7ff fd2f 	bl	2984 <ld_word>
		if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */
    2f26:	2800      	cmp	r0, #0
    2f28:	f000 809d 	beq.w	3066 <find_volume+0x28e>
		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
		fs->fsize = fasize;

		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
		fasize *= fs->n_fats;							/* Number of sectors for FAT area */
    2f2c:	fb0b fb08 	mul.w	fp, fp, r8

		nrsv = ld_word(fs->win + BPB_RsvdSecCnt);		/* Number of reserved sectors */
		if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */

		/* Determine the FAT sub type */
		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
    2f30:	eb0b 131a 	add.w	r3, fp, sl, lsr #4
    2f34:	181b      	adds	r3, r3, r0
		if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
    2f36:	4599      	cmp	r9, r3
    2f38:	f0c0 8095 	bcc.w	3066 <find_volume+0x28e>
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
    2f3c:	ebc3 0909 	rsb	r9, r3, r9
    2f40:	fbb9 f2f6 	udiv	r2, r9, r6
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    2f44:	2a00      	cmp	r2, #0
    2f46:	f000 808e 	beq.w	3066 <find_volume+0x28e>
		fmt = 0;
		if (nclst <= MAX_FAT32) fmt = FS_FAT32;
    2f4a:	494a      	ldr	r1, [pc, #296]	; (3074 <find_volume+0x29c>)
    2f4c:	428a      	cmp	r2, r1
    2f4e:	f200 808a 	bhi.w	3066 <find_volume+0x28e>
		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
    2f52:	f64f 71f5 	movw	r1, #65525	; 0xfff5
    2f56:	428a      	cmp	r2, r1
    2f58:	d806      	bhi.n	2f68 <find_volume+0x190>
    2f5a:	f640 76f5 	movw	r6, #4085	; 0xff5
    2f5e:	42b2      	cmp	r2, r6
    2f60:	bf94      	ite	ls
    2f62:	2601      	movls	r6, #1
    2f64:	2602      	movhi	r6, #2
    2f66:	e000      	b.n	2f6a <find_volume+0x192>
		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
		if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
		fmt = 0;
		if (nclst <= MAX_FAT32) fmt = FS_FAT32;
    2f68:	2603      	movs	r6, #3
		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
		if (fmt == 0) return FR_NO_FILESYSTEM;

		/* Boundaries and Limits */
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
    2f6a:	f102 0902 	add.w	r9, r2, #2
		fs->volbase = bsect;							/* Volume start sector */
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
    2f6e:	1940      	adds	r0, r0, r5
		fs->database = bsect + sysect;					/* Data start sector */
    2f70:	195b      	adds	r3, r3, r5
		if (fmt == FS_FAT32) {
    2f72:	2e03      	cmp	r6, #3
		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
		if (fmt == 0) return FR_NO_FILESYSTEM;

		/* Boundaries and Limits */
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
    2f74:	f8c4 9018 	str.w	r9, [r4, #24]
		fs->volbase = bsect;							/* Volume start sector */
    2f78:	6225      	str	r5, [r4, #32]
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
    2f7a:	6260      	str	r0, [r4, #36]	; 0x24
		fs->database = bsect + sysect;					/* Data start sector */
    2f7c:	62e3      	str	r3, [r4, #44]	; 0x2c
		if (fmt == FS_FAT32) {
    2f7e:	d110      	bne.n	2fa2 <find_volume+0x1ca>
			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
    2f80:	f104 005e 	add.w	r0, r4, #94	; 0x5e
    2f84:	f7ff fcfe 	bl	2984 <ld_word>
    2f88:	2800      	cmp	r0, #0
    2f8a:	d16c      	bne.n	3066 <find_volume+0x28e>
			if (fs->n_rootdir != 0) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
    2f8c:	f1ba 0f00 	cmp.w	sl, #0
    2f90:	d169      	bne.n	3066 <find_volume+0x28e>
			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
    2f92:	f104 0060 	add.w	r0, r4, #96	; 0x60
    2f96:	f7ff fcfa 	bl	298e <ld_dword>
			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
    2f9a:	ea4f 0989 	mov.w	r9, r9, lsl #2
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
		fs->database = bsect + sysect;					/* Data start sector */
		if (fmt == FS_FAT32) {
			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
			if (fs->n_rootdir != 0) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
    2f9e:	62a0      	str	r0, [r4, #40]	; 0x28
    2fa0:	e010      	b.n	2fc4 <find_volume+0x1ec>
			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
		} else {
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    2fa2:	f1ba 0f00 	cmp.w	sl, #0
    2fa6:	d05e      	beq.n	3066 <find_volume+0x28e>
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
			szbfat = (fmt == FS_FAT16) ?				/* (Needed FAT size) */
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
    2fa8:	2e02      	cmp	r6, #2
    2faa:	ea4f 0349 	mov.w	r3, r9, lsl #1
    2fae:	bf18      	it	ne
    2fb0:	444b      	addne	r3, r9
			if (fs->n_rootdir != 0) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
		} else {
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
    2fb2:	4458      	add	r0, fp
			szbfat = (fmt == FS_FAT16) ?				/* (Needed FAT size) */
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
    2fb4:	bf18      	it	ne
    2fb6:	f009 0901 	andne.w	r9, r9, #1
			if (fs->n_rootdir != 0) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
		} else {
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
    2fba:	62a0      	str	r0, [r4, #40]	; 0x28
			szbfat = (fmt == FS_FAT16) ?				/* (Needed FAT size) */
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
    2fbc:	bf0c      	ite	eq
    2fbe:	4699      	moveq	r9, r3
    2fc0:	eb09 0953 	addne.w	r9, r9, r3, lsr #1
		}
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
    2fc4:	f509 79fe 	add.w	r9, r9, #508	; 0x1fc
    2fc8:	f109 0903 	add.w	r9, r9, #3
    2fcc:	ebb8 2f59 	cmp.w	r8, r9, lsr #9
    2fd0:	d349      	bcc.n	3066 <find_volume+0x28e>

#if !FF_FS_READONLY
		/* Get FSInfo if available */
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
    2fd2:	f04f 33ff 	mov.w	r3, #4294967295
    2fd6:	6123      	str	r3, [r4, #16]
    2fd8:	60e3      	str	r3, [r4, #12]
		fs->fsi_flag = 0x80;
    2fda:	3381      	adds	r3, #129	; 0x81
#if (FF_FS_NOFSINFO & 3) != 3
		if (fmt == FS_FAT32				/* Allow to update FSInfo only if BPB_FSInfo32 == 1 */
    2fdc:	2e03      	cmp	r6, #3
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */

#if !FF_FS_READONLY
		/* Get FSInfo if available */
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
		fs->fsi_flag = 0x80;
    2fde:	7123      	strb	r3, [r4, #4]
#if (FF_FS_NOFSINFO & 3) != 3
		if (fmt == FS_FAT32				/* Allow to update FSInfo only if BPB_FSInfo32 == 1 */
    2fe0:	d12c      	bne.n	303c <find_volume+0x264>
			&& ld_word(fs->win + BPB_FSInfo32) == 1
    2fe2:	f104 0064 	add.w	r0, r4, #100	; 0x64
    2fe6:	f7ff fccd 	bl	2984 <ld_word>
    2fea:	2801      	cmp	r0, #1
    2fec:	d126      	bne.n	303c <find_volume+0x264>
			&& move_window(fs, bsect + 1) == FR_OK)
    2fee:	4620      	mov	r0, r4
    2ff0:	1c69      	adds	r1, r5, #1
    2ff2:	f7ff fe9f 	bl	2d34 <move_window>
    2ff6:	bb08      	cbnz	r0, 303c <find_volume+0x264>
		{
			fs->fsi_flag = 0;
    2ff8:	7120      	strb	r0, [r4, #4]
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSInfo data if available */
    2ffa:	f504 700c 	add.w	r0, r4, #560	; 0x230
    2ffe:	3002      	adds	r0, #2
    3000:	f7ff fcc0 	bl	2984 <ld_word>
    3004:	f64a 2355 	movw	r3, #43605	; 0xaa55
    3008:	4298      	cmp	r0, r3
    300a:	d117      	bne.n	303c <find_volume+0x264>
				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
    300c:	f104 0034 	add.w	r0, r4, #52	; 0x34
    3010:	f7ff fcbd 	bl	298e <ld_dword>
    3014:	4b18      	ldr	r3, [pc, #96]	; (3078 <find_volume+0x2a0>)
    3016:	4298      	cmp	r0, r3
    3018:	d110      	bne.n	303c <find_volume+0x264>
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
    301a:	f504 7006 	add.w	r0, r4, #536	; 0x218
    301e:	f7ff fcb6 	bl	298e <ld_dword>
    3022:	4b16      	ldr	r3, [pc, #88]	; (307c <find_volume+0x2a4>)
    3024:	4298      	cmp	r0, r3
    3026:	d109      	bne.n	303c <find_volume+0x264>
			{
#if (FF_FS_NOFSINFO & 1) == 0
				fs->free_clst = ld_dword(fs->win + FSI_Free_Count);
    3028:	f504 7007 	add.w	r0, r4, #540	; 0x21c
    302c:	f7ff fcaf 	bl	298e <ld_dword>
    3030:	6120      	str	r0, [r4, #16]
#endif
#if (FF_FS_NOFSINFO & 2) == 0
				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
    3032:	f504 7008 	add.w	r0, r4, #544	; 0x220
    3036:	f7ff fcaa 	bl	298e <ld_dword>
    303a:	60e0      	str	r0, [r4, #12]
		}
#endif	/* (FF_FS_NOFSINFO & 3) != 3 */
#endif	/* !FF_FS_READONLY */
	}

	fs->fs_type = fmt;		/* FAT sub-type */
    303c:	7026      	strb	r6, [r4, #0]
	fs->id = ++Fsid;		/* Volume mount ID */
    303e:	893b      	ldrh	r3, [r7, #8]
#if FF_FS_EXFAT
	fs->dirbuf = DirBuf;	/* Static directory block scratchpad buuffer */
#endif
#endif
#if FF_FS_RPATH != 0
	fs->cdir = 0;			/* Initialize current directory */
    3040:	2000      	movs	r0, #0
#endif	/* (FF_FS_NOFSINFO & 3) != 3 */
#endif	/* !FF_FS_READONLY */
	}

	fs->fs_type = fmt;		/* FAT sub-type */
	fs->id = ++Fsid;		/* Volume mount ID */
    3042:	3301      	adds	r3, #1
    3044:	b29b      	uxth	r3, r3
    3046:	813b      	strh	r3, [r7, #8]
    3048:	80e3      	strh	r3, [r4, #6]
#if FF_FS_EXFAT
	fs->dirbuf = DirBuf;	/* Static directory block scratchpad buuffer */
#endif
#endif
#if FF_FS_RPATH != 0
	fs->cdir = 0;			/* Initialize current directory */
    304a:	6160      	str	r0, [r4, #20]
#endif
#if FF_FS_LOCK != 0			/* Clear file lock semaphores */
	clear_lock(fs);
#endif
	return FR_OK;
    304c:	e00c      	b.n	3068 <find_volume+0x290>


	/* Get logical drive number */
	*rfs = 0;
	vol = get_ldnumber(path);
	if (vol < 0) return FR_INVALID_DRIVE;
    304e:	200b      	movs	r0, #11
    3050:	e00a      	b.n	3068 <find_volume+0x290>

	/* Check if the filesystem object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the filesystem object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the filesystem object available? */
    3052:	200c      	movs	r0, #12
    3054:	e008      	b.n	3068 <find_volume+0x290>
		stat = disk_status(fs->pdrv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
			if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
			}
			return FR_OK;				/* The filesystem object is valid */
    3056:	4628      	mov	r0, r5
    3058:	e006      	b.n	3068 <find_volume+0x290>

	fs->fs_type = 0;					/* Clear the filesystem object */
	fs->pdrv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
	stat = disk_initialize(fs->pdrv);	/* Initialize the physical drive */
	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
    305a:	2003      	movs	r0, #3
    305c:	e004      	b.n	3068 <find_volume+0x290>
	}
	if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
		return FR_WRITE_PROTECTED;
    305e:	200a      	movs	r0, #10
    3060:	e002      	b.n	3068 <find_volume+0x290>
		do {							/* Find an FAT volume */
			bsect = br[i];
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
	}
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
    3062:	2001      	movs	r0, #1
    3064:	e000      	b.n	3068 <find_volume+0x290>
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
			szbfat = (fmt == FS_FAT16) ?				/* (Needed FAT size) */
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
		}
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
    3066:	200d      	movs	r0, #13
#endif
#if FF_FS_LOCK != 0			/* Clear file lock semaphores */
	clear_lock(fs);
#endif
	return FR_OK;
}
    3068:	b005      	add	sp, #20
    306a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    306e:	bf00      	nop
    3070:	1000012c 	.word	0x1000012c
    3074:	0ffffff5 	.word	0x0ffffff5
    3078:	41615252 	.word	0x41615252
    307c:	61417272 	.word	0x61417272

00003080 <put_fat>:
	UINT bc;
	BYTE *p;
	FRESULT res = FR_INT_ERR;


	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
    3080:	2901      	cmp	r1, #1
static FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,		/* Corresponding filesystem object */
	DWORD clst,		/* FAT index number (cluster number) to be changed */
	DWORD val		/* New value to be set to the entry */
)
{
    3082:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3086:	4604      	mov	r4, r0
    3088:	460d      	mov	r5, r1
    308a:	4617      	mov	r7, r2
	UINT bc;
	BYTE *p;
	FRESULT res = FR_INT_ERR;


	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
    308c:	d972      	bls.n	3174 <put_fat+0xf4>
    308e:	6983      	ldr	r3, [r0, #24]
    3090:	4299      	cmp	r1, r3
    3092:	d26f      	bcs.n	3174 <put_fat+0xf4>
		switch (fs->fs_type) {
    3094:	7803      	ldrb	r3, [r0, #0]
    3096:	2b02      	cmp	r3, #2
    3098:	d044      	beq.n	3124 <put_fat+0xa4>
    309a:	2b03      	cmp	r3, #3
    309c:	d051      	beq.n	3142 <put_fat+0xc2>
    309e:	2b01      	cmp	r3, #1
    30a0:	d168      	bne.n	3174 <put_fat+0xf4>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;	/* bc: byte offset of the entry */
    30a2:	eb01 0851 	add.w	r8, r1, r1, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    30a6:	6a41      	ldr	r1, [r0, #36]	; 0x24
    30a8:	eb01 2158 	add.w	r1, r1, r8, lsr #9
    30ac:	f7ff fe42 	bl	2d34 <move_window>
			if (res != FR_OK) break;
    30b0:	4606      	mov	r6, r0
    30b2:	2800      	cmp	r0, #0
    30b4:	d15f      	bne.n	3176 <put_fat+0xf6>
			p = fs->win + bc++ % SS(fs);
    30b6:	ea4f 53c8 	mov.w	r3, r8, lsl #23
    30ba:	0ddb      	lsrs	r3, r3, #23
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;		/* Put 1st byte */
    30bc:	f015 0501 	ands.w	r5, r5, #1
		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;	/* bc: byte offset of the entry */
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = fs->win + bc++ % SS(fs);
    30c0:	f108 0801 	add.w	r8, r8, #1
    30c4:	b2fa      	uxtb	r2, r7
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;		/* Put 1st byte */
    30c6:	d007      	beq.n	30d8 <put_fat+0x58>
    30c8:	18e1      	adds	r1, r4, r3
    30ca:	f891 1034 	ldrb.w	r1, [r1, #52]	; 0x34
    30ce:	f001 010f 	and.w	r1, r1, #15
    30d2:	ea41 1202 	orr.w	r2, r1, r2, lsl #4
    30d6:	b2d2      	uxtb	r2, r2
    30d8:	18e3      	adds	r3, r4, r3
			fs->wflag = 1;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    30da:	6a61      	ldr	r1, [r4, #36]	; 0x24
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;	/* bc: byte offset of the entry */
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = fs->win + bc++ % SS(fs);
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;		/* Put 1st byte */
    30dc:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
			fs->wflag = 1;
    30e0:	2301      	movs	r3, #1
    30e2:	70e3      	strb	r3, [r4, #3]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    30e4:	4620      	mov	r0, r4
    30e6:	eb01 2158 	add.w	r1, r1, r8, lsr #9
    30ea:	f7ff fe23 	bl	2d34 <move_window>
			if (res != FR_OK) break;
    30ee:	4606      	mov	r6, r0
    30f0:	2800      	cmp	r0, #0
    30f2:	d140      	bne.n	3176 <put_fat+0xf6>
			p = fs->win + bc % SS(fs);
    30f4:	ea4f 58c8 	mov.w	r8, r8, lsl #23
    30f8:	ea4f 58d8 	mov.w	r8, r8, lsr #23
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Put 2nd byte */
    30fc:	b115      	cbz	r5, 3104 <put_fat+0x84>
    30fe:	093f      	lsrs	r7, r7, #4
    3100:	b2ff      	uxtb	r7, r7
    3102:	e00a      	b.n	311a <put_fat+0x9a>
    3104:	eb04 0308 	add.w	r3, r4, r8
    3108:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
    310c:	0a3f      	lsrs	r7, r7, #8
    310e:	f023 030f 	bic.w	r3, r3, #15
    3112:	f007 070f 	and.w	r7, r7, #15
    3116:	ea43 0707 	orr.w	r7, r3, r7
    311a:	eb04 0308 	add.w	r3, r4, r8
    311e:	f883 7034 	strb.w	r7, [r3, #52]	; 0x34
    3122:	e024      	b.n	316e <put_fat+0xee>
			fs->wflag = 1;
			break;

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
    3124:	6a41      	ldr	r1, [r0, #36]	; 0x24
    3126:	eb01 2115 	add.w	r1, r1, r5, lsr #8
    312a:	f7ff fe03 	bl	2d34 <move_window>
			if (res != FR_OK) break;
    312e:	4606      	mov	r6, r0
    3130:	bb08      	cbnz	r0, 3176 <put_fat+0xf6>
			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);	/* Simple WORD array */
    3132:	062d      	lsls	r5, r5, #24
    3134:	eb04 50d5 	add.w	r0, r4, r5, lsr #23
    3138:	3034      	adds	r0, #52	; 0x34
    313a:	b2b9      	uxth	r1, r7
    313c:	f7ff fc32 	bl	29a4 <st_word>
    3140:	e015      	b.n	316e <put_fat+0xee>

		case FS_FAT32 :
#if FF_FS_EXFAT
		case FS_EXFAT :
#endif
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
    3142:	6a41      	ldr	r1, [r0, #36]	; 0x24
    3144:	eb01 11d5 	add.w	r1, r1, r5, lsr #7
    3148:	f7ff fdf4 	bl	2d34 <move_window>
			if (res != FR_OK) break;
    314c:	4606      	mov	r6, r0
    314e:	b990      	cbnz	r0, 3176 <put_fat+0xf6>
			if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
    3150:	066d      	lsls	r5, r5, #25
    3152:	eb04 55d5 	add.w	r5, r4, r5, lsr #23
    3156:	3534      	adds	r5, #52	; 0x34
    3158:	4628      	mov	r0, r5
    315a:	f7ff fc18 	bl	298e <ld_dword>
    315e:	f027 4770 	bic.w	r7, r7, #4026531840	; 0xf0000000
    3162:	f000 4170 	and.w	r1, r0, #4026531840	; 0xf0000000
			}
			st_dword(fs->win + clst * 4 % SS(fs), val);
    3166:	4339      	orrs	r1, r7
    3168:	4628      	mov	r0, r5
    316a:	f7ff fc1f 	bl	29ac <st_dword>
			fs->wflag = 1;
    316e:	2301      	movs	r3, #1
    3170:	70e3      	strb	r3, [r4, #3]
			break;
    3172:	e000      	b.n	3176 <put_fat+0xf6>
	DWORD val		/* New value to be set to the entry */
)
{
	UINT bc;
	BYTE *p;
	FRESULT res = FR_INT_ERR;
    3174:	2602      	movs	r6, #2
			fs->wflag = 1;
			break;
		}
	}
	return res;
}
    3176:	4630      	mov	r0, r6
    3178:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000317c <dir_remove>:
/*-----------------------------------------------------------------------*/

static FRESULT dir_remove (	/* FR_OK:Succeeded, FR_DISK_ERR:A disk error */
	DIR* dp					/* Directory object pointing the entry to be removed */
)
{
    317c:	b538      	push	{r3, r4, r5, lr}
	FRESULT res;
	FATFS *fs = dp->obj.fs;
    317e:	6805      	ldr	r5, [r0, #0]
/*-----------------------------------------------------------------------*/

static FRESULT dir_remove (	/* FR_OK:Succeeded, FR_DISK_ERR:A disk error */
	DIR* dp					/* Directory object pointing the entry to be removed */
)
{
    3180:	4604      	mov	r4, r0
		} while (res == FR_OK);
		if (res == FR_NO_FILE) res = FR_INT_ERR;
	}
#else			/* Non LFN configuration */

	res = move_window(fs, dp->sect);
    3182:	69a1      	ldr	r1, [r4, #24]
    3184:	4628      	mov	r0, r5
    3186:	f7ff fdd5 	bl	2d34 <move_window>
	if (res == FR_OK) {
    318a:	b920      	cbnz	r0, 3196 <dir_remove+0x1a>
		dp->dir[DIR_Name] = DDEM;	/* Mark the entry 'deleted'.*/
    318c:	69e3      	ldr	r3, [r4, #28]
    318e:	22e5      	movs	r2, #229	; 0xe5
    3190:	701a      	strb	r2, [r3, #0]
		fs->wflag = 1;
    3192:	2301      	movs	r3, #1
    3194:	70eb      	strb	r3, [r5, #3]
	}
#endif

	return res;
}
    3196:	bd38      	pop	{r3, r4, r5, pc}

00003198 <ld_clust.clone.0>:

/*-----------------------------------------------------------------------*/
/* FAT: Directory handling - Load/Store start cluster number             */
/*-----------------------------------------------------------------------*/

static DWORD ld_clust (	/* Returns the top cluster value of the SFN entry */
    3198:	b570      	push	{r4, r5, r6, lr}
    319a:	4604      	mov	r4, r0
	const BYTE* dir		/* Pointer to the key entry */
)
{
	DWORD cl;

	cl = ld_word(dir + DIR_FstClusLO);
    319c:	f101 001a 	add.w	r0, r1, #26

/*-----------------------------------------------------------------------*/
/* FAT: Directory handling - Load/Store start cluster number             */
/*-----------------------------------------------------------------------*/

static DWORD ld_clust (	/* Returns the top cluster value of the SFN entry */
    31a0:	460e      	mov	r6, r1
	const BYTE* dir		/* Pointer to the key entry */
)
{
	DWORD cl;

	cl = ld_word(dir + DIR_FstClusLO);
    31a2:	f7ff fbef 	bl	2984 <ld_word>
	if (fs->fs_type == FS_FAT32) {
    31a6:	2c03      	cmp	r4, #3
	const BYTE* dir		/* Pointer to the key entry */
)
{
	DWORD cl;

	cl = ld_word(dir + DIR_FstClusLO);
    31a8:	4605      	mov	r5, r0
	if (fs->fs_type == FS_FAT32) {
    31aa:	d105      	bne.n	31b8 <ld_clust.clone.0+0x20>
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
    31ac:	f106 0014 	add.w	r0, r6, #20
    31b0:	f7ff fbe8 	bl	2984 <ld_word>
    31b4:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
	}

	return cl;
}
    31b8:	4628      	mov	r0, r5
    31ba:	bd70      	pop	{r4, r5, r6, pc}

000031bc <st_clust.clone.1>:


#if !FF_FS_READONLY
static void st_clust (
    31bc:	b570      	push	{r4, r5, r6, lr}
    31be:	4605      	mov	r5, r0
    31c0:	460c      	mov	r4, r1
	FATFS* fs,	/* Pointer to the fs object */
	BYTE* dir,	/* Pointer to the key entry */
	DWORD cl	/* Value to be set */
)
{
	st_word(dir + DIR_FstClusLO, (WORD)cl);
    31c2:	f101 001a 	add.w	r0, r1, #26
    31c6:	b291      	uxth	r1, r2
	return cl;
}


#if !FF_FS_READONLY
static void st_clust (
    31c8:	4616      	mov	r6, r2
	FATFS* fs,	/* Pointer to the fs object */
	BYTE* dir,	/* Pointer to the key entry */
	DWORD cl	/* Value to be set */
)
{
	st_word(dir + DIR_FstClusLO, (WORD)cl);
    31ca:	f7ff fbeb 	bl	29a4 <st_word>
	if (fs->fs_type == FS_FAT32) {
    31ce:	782b      	ldrb	r3, [r5, #0]
    31d0:	2b03      	cmp	r3, #3
    31d2:	d106      	bne.n	31e2 <st_clust.clone.1+0x26>
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
    31d4:	f104 0014 	add.w	r0, r4, #20
    31d8:	0c31      	lsrs	r1, r6, #16
	}
}
    31da:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	DWORD cl	/* Value to be set */
)
{
	st_word(dir + DIR_FstClusLO, (WORD)cl);
	if (fs->fs_type == FS_FAT32) {
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
    31de:	f7ff bbe1 	b.w	29a4 <st_word>
    31e2:	bd70      	pop	{r4, r5, r6, pc}

000031e4 <get_fat.clone.2>:
	UINT wc, bc;
	DWORD val;
	FATFS *fs = obj->fs;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
    31e4:	2901      	cmp	r1, #1

/*-----------------------------------------------------------------------*/
/* FAT access - Read value of a FAT entry                                */
/*-----------------------------------------------------------------------*/

static DWORD get_fat (		/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
    31e6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    31e8:	4604      	mov	r4, r0
    31ea:	460d      	mov	r5, r1
	UINT wc, bc;
	DWORD val;
	FATFS *fs = obj->fs;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
    31ec:	d94d      	bls.n	328a <get_fat.clone.2+0xa6>
    31ee:	6983      	ldr	r3, [r0, #24]
    31f0:	4299      	cmp	r1, r3
    31f2:	d24a      	bcs.n	328a <get_fat.clone.2+0xa6>
		val = 1;	/* Internal error */

	} else {
		val = 0xFFFFFFFF;	/* Default value falls on disk error */

		switch (fs->fs_type) {
    31f4:	7803      	ldrb	r3, [r0, #0]
    31f6:	2b02      	cmp	r3, #2
    31f8:	d029      	beq.n	324e <get_fat.clone.2+0x6a>
    31fa:	2b03      	cmp	r3, #3
    31fc:	d035      	beq.n	326a <get_fat.clone.2+0x86>
    31fe:	2b01      	cmp	r3, #1
    3200:	d143      	bne.n	328a <get_fat.clone.2+0xa6>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
    3202:	eb01 0651 	add.w	r6, r1, r1, lsr #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
    3206:	6a41      	ldr	r1, [r0, #36]	; 0x24
    3208:	eb01 2156 	add.w	r1, r1, r6, lsr #9
    320c:	f7ff fd92 	bl	2d34 <move_window>
    3210:	2800      	cmp	r0, #0
    3212:	d13c      	bne.n	328e <get_fat.clone.2+0xaa>
			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
    3214:	05f3      	lsls	r3, r6, #23
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
    3216:	6a61      	ldr	r1, [r4, #36]	; 0x24

		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
    3218:	0ddb      	lsrs	r3, r3, #23
    321a:	3601      	adds	r6, #1
    321c:	18e3      	adds	r3, r4, r3
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
    321e:	4620      	mov	r0, r4
    3220:	eb01 2156 	add.w	r1, r1, r6, lsr #9

		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
    3224:	f893 7034 	ldrb.w	r7, [r3, #52]	; 0x34
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
    3228:	f7ff fd84 	bl	2d34 <move_window>
    322c:	2800      	cmp	r0, #0
    322e:	d12e      	bne.n	328e <get_fat.clone.2+0xaa>
			wc |= fs->win[bc % SS(fs)] << 8;	/* Merge 2nd byte of the entry */
    3230:	05f6      	lsls	r6, r6, #23
    3232:	0df6      	lsrs	r6, r6, #23
    3234:	19a6      	adds	r6, r4, r6
    3236:	f896 0034 	ldrb.w	r0, [r6, #52]	; 0x34
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);	/* Adjust bit position */
    323a:	f015 0f01 	tst.w	r5, #1
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
			wc |= fs->win[bc % SS(fs)] << 8;	/* Merge 2nd byte of the entry */
    323e:	ea47 2000 	orr.w	r0, r7, r0, lsl #8
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);	/* Adjust bit position */
    3242:	d001      	beq.n	3248 <get_fat.clone.2+0x64>
    3244:	0900      	lsrs	r0, r0, #4
    3246:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3248:	0500      	lsls	r0, r0, #20
    324a:	0d00      	lsrs	r0, r0, #20
    324c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			break;

		case FS_FAT16 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
    324e:	6a41      	ldr	r1, [r0, #36]	; 0x24
    3250:	eb01 2115 	add.w	r1, r1, r5, lsr #8
    3254:	f7ff fd6e 	bl	2d34 <move_window>
    3258:	b9c8      	cbnz	r0, 328e <get_fat.clone.2+0xaa>
			val = ld_word(fs->win + clst * 2 % SS(fs));		/* Simple WORD array */
    325a:	062d      	lsls	r5, r5, #24
    325c:	eb04 54d5 	add.w	r4, r4, r5, lsr #23
    3260:	f104 0034 	add.w	r0, r4, #52	; 0x34
    3264:	f7ff fb8e 	bl	2984 <ld_word>
    3268:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			break;

		case FS_FAT32 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
    326a:	6a41      	ldr	r1, [r0, #36]	; 0x24
    326c:	eb01 11d5 	add.w	r1, r1, r5, lsr #7
    3270:	f7ff fd60 	bl	2d34 <move_window>
    3274:	b970      	cbnz	r0, 3294 <get_fat.clone.2+0xb0>
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;	/* Simple DWORD array but mask out upper 4 bits */
    3276:	066d      	lsls	r5, r5, #25
    3278:	eb04 54d5 	add.w	r4, r4, r5, lsr #23
    327c:	f104 0034 	add.w	r0, r4, #52	; 0x34
    3280:	f7ff fb85 	bl	298e <ld_dword>
    3284:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
    3288:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				}
			}
			/* go to default */
#endif
		default:
			val = 1;	/* Internal error */
    328a:	2001      	movs	r0, #1
    328c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
		val = 1;	/* Internal error */

	} else {
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
    328e:	f04f 30ff 	mov.w	r0, #4294967295
    3292:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3294:	f04f 30ff 	mov.w	r0, #4294967295
			val = 1;	/* Internal error */
		}
	}

	return val;
}
    3298:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000329a <dir_sdi>:
{
	DWORD csz, clst;
	FATFS *fs = dp->obj.fs;


	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
    329a:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000

static FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to directory object */
	DWORD ofs		/* Offset of directory table */
)
{
    329e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    32a2:	4604      	mov	r4, r0
    32a4:	460d      	mov	r5, r1
	DWORD csz, clst;
	FATFS *fs = dp->obj.fs;
    32a6:	6807      	ldr	r7, [r0, #0]


	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
    32a8:	d23e      	bcs.n	3328 <dir_sdi+0x8e>
    32aa:	f011 0f1f 	tst.w	r1, #31
    32ae:	d13b      	bne.n	3328 <dir_sdi+0x8e>
		return FR_INT_ERR;
	}
	dp->dptr = ofs;				/* Set current offset */
	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
    32b0:	6886      	ldr	r6, [r0, #8]


	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
		return FR_INT_ERR;
	}
	dp->dptr = ofs;				/* Set current offset */
    32b2:	6121      	str	r1, [r4, #16]
	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
    32b4:	b966      	cbnz	r6, 32d0 <dir_sdi+0x36>
    32b6:	783b      	ldrb	r3, [r7, #0]
    32b8:	2b02      	cmp	r3, #2
    32ba:	d901      	bls.n	32c0 <dir_sdi+0x26>
		clst = fs->dirbase;
    32bc:	6abb      	ldr	r3, [r7, #40]	; 0x28
		if (FF_FS_EXFAT) dp->obj.stat = 0;	/* exFAT: Root dir has an FAT chain */
	}

	if (clst == 0) {	/* Static table (root-directory on the FAT volume) */
    32be:	b933      	cbnz	r3, 32ce <dir_sdi+0x34>
		if (ofs / SZDIRE >= fs->n_rootdir) return FR_INT_ERR;	/* Is index out of range? */
    32c0:	893b      	ldrh	r3, [r7, #8]
    32c2:	ebb3 1f55 	cmp.w	r3, r5, lsr #5
    32c6:	d92f      	bls.n	3328 <dir_sdi+0x8e>
		dp->sect = fs->dirbase;
    32c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
    32ca:	61a3      	str	r3, [r4, #24]
    32cc:	e01b      	b.n	3306 <dir_sdi+0x6c>
	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
		clst = fs->dirbase;
		if (FF_FS_EXFAT) dp->obj.stat = 0;	/* exFAT: Root dir has an FAT chain */
	}

	if (clst == 0) {	/* Static table (root-directory on the FAT volume) */
    32ce:	461e      	mov	r6, r3
		if (ofs / SZDIRE >= fs->n_rootdir) return FR_INT_ERR;	/* Is index out of range? */
		dp->sect = fs->dirbase;

	} else {			/* Dynamic table (sub-directory or root-directory on the FAT32/exFAT volume) */
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
    32d0:	f8b7 800a 	ldrh.w	r8, [r7, #10]
    32d4:	ea4f 2848 	mov.w	r8, r8, lsl #9
		while (ofs >= csz) {				/* Follow cluster chain */
    32d8:	e00e      	b.n	32f8 <dir_sdi+0x5e>
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
    32da:	4631      	mov	r1, r6
    32dc:	6820      	ldr	r0, [r4, #0]
    32de:	f7ff ff81 	bl	31e4 <get_fat.clone.2>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    32e2:	f1b0 3fff 	cmp.w	r0, #4294967295
		dp->sect = fs->dirbase;

	} else {			/* Dynamic table (sub-directory or root-directory on the FAT32/exFAT volume) */
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
		while (ofs >= csz) {				/* Follow cluster chain */
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
    32e6:	4606      	mov	r6, r0
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    32e8:	d01b      	beq.n	3322 <dir_sdi+0x88>
			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
    32ea:	2801      	cmp	r0, #1
    32ec:	d91c      	bls.n	3328 <dir_sdi+0x8e>
    32ee:	69bb      	ldr	r3, [r7, #24]
    32f0:	4298      	cmp	r0, r3
    32f2:	d219      	bcs.n	3328 <dir_sdi+0x8e>
			ofs -= csz;
    32f4:	ebc8 0505 	rsb	r5, r8, r5
		if (ofs / SZDIRE >= fs->n_rootdir) return FR_INT_ERR;	/* Is index out of range? */
		dp->sect = fs->dirbase;

	} else {			/* Dynamic table (sub-directory or root-directory on the FAT32/exFAT volume) */
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
		while (ofs >= csz) {				/* Follow cluster chain */
    32f8:	4545      	cmp	r5, r8
    32fa:	d2ee      	bcs.n	32da <dir_sdi+0x40>
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
			ofs -= csz;
		}
		dp->sect = clst2sect(fs, clst);
    32fc:	4638      	mov	r0, r7
    32fe:	4631      	mov	r1, r6
    3300:	f7ff fba1 	bl	2a46 <clst2sect>
    3304:	61a0      	str	r0, [r4, #24]
	}
	dp->clust = clst;					/* Current cluster# */
	if (dp->sect == 0) return FR_INT_ERR;
    3306:	69a3      	ldr	r3, [r4, #24]
			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
			ofs -= csz;
		}
		dp->sect = clst2sect(fs, clst);
	}
	dp->clust = clst;					/* Current cluster# */
    3308:	6166      	str	r6, [r4, #20]
	if (dp->sect == 0) return FR_INT_ERR;
    330a:	b183      	cbz	r3, 332e <dir_sdi+0x94>
	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
    330c:	eb03 2355 	add.w	r3, r3, r5, lsr #9
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
    3310:	05ed      	lsls	r5, r5, #23
    3312:	0ded      	lsrs	r5, r5, #23
    3314:	197d      	adds	r5, r7, r5
    3316:	3534      	adds	r5, #52	; 0x34
		}
		dp->sect = clst2sect(fs, clst);
	}
	dp->clust = clst;					/* Current cluster# */
	if (dp->sect == 0) return FR_INT_ERR;
	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
    3318:	61a3      	str	r3, [r4, #24]
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
    331a:	61e5      	str	r5, [r4, #28]

	return FR_OK;
    331c:	2000      	movs	r0, #0
    331e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

	} else {			/* Dynamic table (sub-directory or root-directory on the FAT32/exFAT volume) */
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
		while (ofs >= csz) {				/* Follow cluster chain */
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    3322:	2001      	movs	r0, #1
    3324:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
    3328:	2002      	movs	r0, #2
    332a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			ofs -= csz;
		}
		dp->sect = clst2sect(fs, clst);
	}
	dp->clust = clst;					/* Current cluster# */
	if (dp->sect == 0) return FR_INT_ERR;
    332e:	2002      	movs	r0, #2
	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */

	return FR_OK;
}
    3330:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00003334 <create_chain.clone.3>:

/*-----------------------------------------------------------------------*/
/* FAT handling - Stretch a chain or Create a new chain                  */
/*-----------------------------------------------------------------------*/

static DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
    3334:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3338:	4680      	mov	r8, r0
	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
)
{
	DWORD cs, ncl, scl;
	FRESULT res;
	FATFS *fs = obj->fs;
    333a:	6804      	ldr	r4, [r0, #0]


	if (clst == 0) {	/* Create a new chain */
    333c:	460e      	mov	r6, r1
    333e:	b931      	cbnz	r1, 334e <create_chain.clone.3+0x1a>
		scl = fs->last_clst;				/* Suggested cluster to start to find */
    3340:	68e7      	ldr	r7, [r4, #12]
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
    3342:	b18f      	cbz	r7, 3368 <create_chain.clone.3+0x34>
    3344:	69a3      	ldr	r3, [r4, #24]
    3346:	429f      	cmp	r7, r3
    3348:	bf28      	it	cs
    334a:	2701      	movcs	r7, #1
    334c:	e00d      	b.n	336a <create_chain.clone.3+0x36>
	}
	else {				/* Stretch a chain */
		cs = get_fat(obj, clst);			/* Check the cluster status */
    334e:	4620      	mov	r0, r4
    3350:	f7ff ff48 	bl	31e4 <get_fat.clone.2>
		if (cs < 2) return 1;				/* Test for insanity */
    3354:	2801      	cmp	r0, #1
    3356:	d960      	bls.n	341a <create_chain.clone.3+0xe6>
		if (cs == 0xFFFFFFFF) return cs;	/* Test for disk error */
    3358:	f1b0 3fff 	cmp.w	r0, #4294967295
    335c:	d064      	beq.n	3428 <create_chain.clone.3+0xf4>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
    335e:	69a3      	ldr	r3, [r4, #24]
    3360:	4298      	cmp	r0, r3
    3362:	d361      	bcc.n	3428 <create_chain.clone.3+0xf4>
    3364:	4637      	mov	r7, r6
    3366:	e000      	b.n	336a <create_chain.clone.3+0x36>
	FATFS *fs = obj->fs;


	if (clst == 0) {	/* Create a new chain */
		scl = fs->last_clst;				/* Suggested cluster to start to find */
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
    3368:	2701      	movs	r7, #1
		if (cs < 2) return 1;				/* Test for insanity */
		if (cs == 0xFFFFFFFF) return cs;	/* Test for disk error */
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
		scl = clst;							/* Cluster to start to find */
	}
	if (fs->free_clst == 0) return 0;		/* No free cluster */
    336a:	6920      	ldr	r0, [r4, #16]
    336c:	2800      	cmp	r0, #0
    336e:	d05b      	beq.n	3428 <create_chain.clone.3+0xf4>
		}
	} else
#endif
	{	/* On the FAT/FAT32 volume */
		ncl = 0;
		if (scl == clst) {						/* Stretching an existing chain? */
    3370:	42b7      	cmp	r7, r6
    3372:	d118      	bne.n	33a6 <create_chain.clone.3+0x72>
			ncl = scl + 1;						/* Test if next cluster is free */
			if (ncl >= fs->n_fatent) ncl = 2;
    3374:	69a3      	ldr	r3, [r4, #24]
	} else
#endif
	{	/* On the FAT/FAT32 volume */
		ncl = 0;
		if (scl == clst) {						/* Stretching an existing chain? */
			ncl = scl + 1;						/* Test if next cluster is free */
    3376:	1c7d      	adds	r5, r7, #1
			if (ncl >= fs->n_fatent) ncl = 2;
    3378:	429d      	cmp	r5, r3
    337a:	bf28      	it	cs
    337c:	2502      	movcs	r5, #2
			cs = get_fat(obj, ncl);				/* Get next cluster status */
    337e:	f8d8 0000 	ldr.w	r0, [r8]
    3382:	4629      	mov	r1, r5
    3384:	f7ff ff2e 	bl	31e4 <get_fat.clone.2>
			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
    3388:	2801      	cmp	r0, #1
    338a:	d04d      	beq.n	3428 <create_chain.clone.3+0xf4>
    338c:	f1b0 3fff 	cmp.w	r0, #4294967295
    3390:	d04a      	beq.n	3428 <create_chain.clone.3+0xf4>
			if (cs != 0) {						/* Not free? */
    3392:	b138      	cbz	r0, 33a4 <create_chain.clone.3+0x70>
				cs = fs->last_clst;				/* Start at suggested cluster if it is valid */
    3394:	68e3      	ldr	r3, [r4, #12]
				if (cs >= 2 && cs < fs->n_fatent) scl = cs;
    3396:	2b01      	cmp	r3, #1
    3398:	d905      	bls.n	33a6 <create_chain.clone.3+0x72>
    339a:	69a2      	ldr	r2, [r4, #24]
    339c:	4293      	cmp	r3, r2
    339e:	bf38      	it	cc
    33a0:	461f      	movcc	r7, r3
    33a2:	e000      	b.n	33a6 <create_chain.clone.3+0x72>
				ncl = 0;
			}
		}
		if (ncl == 0) {	/* The new cluster cannot be contiguous and find another fragment */
    33a4:	b9ad      	cbnz	r5, 33d2 <create_chain.clone.3+0x9e>
#endif
	{	/* On the FAT/FAT32 volume */
		ncl = 0;
		if (scl == clst) {						/* Stretching an existing chain? */
			ncl = scl + 1;						/* Test if next cluster is free */
			if (ncl >= fs->n_fatent) ncl = 2;
    33a6:	463d      	mov	r5, r7
		}
		if (ncl == 0) {	/* The new cluster cannot be contiguous and find another fragment */
			ncl = scl;	/* Start cluster */
			for (;;) {
				ncl++;							/* Next cluster */
				if (ncl >= fs->n_fatent) {		/* Check wrap-around */
    33a8:	69a3      	ldr	r3, [r4, #24]
			}
		}
		if (ncl == 0) {	/* The new cluster cannot be contiguous and find another fragment */
			ncl = scl;	/* Start cluster */
			for (;;) {
				ncl++;							/* Next cluster */
    33aa:	3501      	adds	r5, #1
				if (ncl >= fs->n_fatent) {		/* Check wrap-around */
    33ac:	429d      	cmp	r5, r3
    33ae:	d302      	bcc.n	33b6 <create_chain.clone.3+0x82>
					ncl = 2;
					if (ncl > scl) return 0;	/* No free cluster found? */
    33b0:	2f01      	cmp	r7, #1
    33b2:	d935      	bls.n	3420 <create_chain.clone.3+0xec>
		if (ncl == 0) {	/* The new cluster cannot be contiguous and find another fragment */
			ncl = scl;	/* Start cluster */
			for (;;) {
				ncl++;							/* Next cluster */
				if (ncl >= fs->n_fatent) {		/* Check wrap-around */
					ncl = 2;
    33b4:	2502      	movs	r5, #2
					if (ncl > scl) return 0;	/* No free cluster found? */
				}
				cs = get_fat(obj, ncl);			/* Get the cluster status */
    33b6:	f8d8 0000 	ldr.w	r0, [r8]
    33ba:	4629      	mov	r1, r5
    33bc:	f7ff ff12 	bl	31e4 <get_fat.clone.2>
				if (cs == 0) break;				/* Found a free cluster? */
    33c0:	b138      	cbz	r0, 33d2 <create_chain.clone.3+0x9e>
				if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
    33c2:	2801      	cmp	r0, #1
    33c4:	d030      	beq.n	3428 <create_chain.clone.3+0xf4>
    33c6:	f1b0 3fff 	cmp.w	r0, #4294967295
    33ca:	d02d      	beq.n	3428 <create_chain.clone.3+0xf4>
				if (ncl == scl) return 0;		/* No free cluster found? */
    33cc:	42bd      	cmp	r5, r7
    33ce:	d1eb      	bne.n	33a8 <create_chain.clone.3+0x74>
    33d0:	e029      	b.n	3426 <create_chain.clone.3+0xf2>
			}
		}
		res = put_fat(fs, ncl, 0xFFFFFFFF);		/* Mark the new cluster 'EOC' */
    33d2:	4620      	mov	r0, r4
    33d4:	4629      	mov	r1, r5
    33d6:	f04f 32ff 	mov.w	r2, #4294967295
    33da:	f7ff fe51 	bl	3080 <put_fat>
		if (res == FR_OK && clst != 0) {
    33de:	b9a8      	cbnz	r0, 340c <create_chain.clone.3+0xd8>
    33e0:	b12e      	cbz	r6, 33ee <create_chain.clone.3+0xba>
			res = put_fat(fs, clst, ncl);		/* Link it from the previous one if needed */
    33e2:	4620      	mov	r0, r4
    33e4:	4631      	mov	r1, r6
    33e6:	462a      	mov	r2, r5
    33e8:	f7ff fe4a 	bl	3080 <put_fat>
		}
	}

	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
    33ec:	b970      	cbnz	r0, 340c <create_chain.clone.3+0xd8>
		fs->last_clst = ncl;
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
    33ee:	69a2      	ldr	r2, [r4, #24]
    33f0:	6923      	ldr	r3, [r4, #16]
    33f2:	3a02      	subs	r2, #2
    33f4:	4293      	cmp	r3, r2
			res = put_fat(fs, clst, ncl);		/* Link it from the previous one if needed */
		}
	}

	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
		fs->last_clst = ncl;
    33f6:	60e5      	str	r5, [r4, #12]
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
    33f8:	d801      	bhi.n	33fe <create_chain.clone.3+0xca>
    33fa:	3b01      	subs	r3, #1
    33fc:	6123      	str	r3, [r4, #16]
		fs->fsi_flag |= 1;
    33fe:	7923      	ldrb	r3, [r4, #4]
    3400:	4628      	mov	r0, r5
    3402:	f043 0301 	orr.w	r3, r3, #1
    3406:	7123      	strb	r3, [r4, #4]
    3408:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
    340c:	2801      	cmp	r0, #1
    340e:	bf14      	ite	ne
    3410:	2001      	movne	r0, #1
    3412:	f04f 30ff 	moveq.w	r0, #4294967295
    3416:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		scl = fs->last_clst;				/* Suggested cluster to start to find */
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
	}
	else {				/* Stretch a chain */
		cs = get_fat(obj, clst);			/* Check the cluster status */
		if (cs < 2) return 1;				/* Test for insanity */
    341a:	2001      	movs	r0, #1
    341c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			ncl = scl;	/* Start cluster */
			for (;;) {
				ncl++;							/* Next cluster */
				if (ncl >= fs->n_fatent) {		/* Check wrap-around */
					ncl = 2;
					if (ncl > scl) return 0;	/* No free cluster found? */
    3420:	2000      	movs	r0, #0
    3422:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				}
				cs = get_fat(obj, ncl);			/* Get the cluster status */
				if (cs == 0) break;				/* Found a free cluster? */
				if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
				if (ncl == scl) return 0;		/* No free cluster found? */
    3426:	2000      	movs	r0, #0
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
	}

	return ncl;		/* Return new cluster number or error status */
}
    3428:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000342c <dir_next>:

static FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
	DIR* dp,				/* Pointer to the directory object */
	int stretch				/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
    342c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	DWORD ofs, clst;
	FATFS *fs = dp->obj.fs;


	ofs = dp->dptr + SZDIRE;	/* Next entry */
    3430:	6907      	ldr	r7, [r0, #16]

static FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
	DIR* dp,				/* Pointer to the directory object */
	int stretch				/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
    3432:	4604      	mov	r4, r0
	DWORD ofs, clst;
	FATFS *fs = dp->obj.fs;


	ofs = dp->dptr + SZDIRE;	/* Next entry */
    3434:	3720      	adds	r7, #32
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) dp->sect = 0;	/* Disable it if the offset reached the max value */
    3436:	f5b7 1f00 	cmp.w	r7, #2097152	; 0x200000

static FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
	DIR* dp,				/* Pointer to the directory object */
	int stretch				/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
    343a:	4689      	mov	r9, r1
	DWORD ofs, clst;
	FATFS *fs = dp->obj.fs;
    343c:	6806      	ldr	r6, [r0, #0]


	ofs = dp->dptr + SZDIRE;	/* Next entry */
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) dp->sect = 0;	/* Disable it if the offset reached the max value */
    343e:	d301      	bcc.n	3444 <dir_next+0x18>
    3440:	2300      	movs	r3, #0
    3442:	6183      	str	r3, [r0, #24]
	if (dp->sect == 0) return FR_NO_FILE;	/* Report EOT if it has been disabled */
    3444:	69a3      	ldr	r3, [r4, #24]
    3446:	2b00      	cmp	r3, #0
    3448:	d044      	beq.n	34d4 <dir_next+0xa8>

	if (ofs % SS(fs) == 0) {	/* Sector changed? */
    344a:	ea4f 58c7 	mov.w	r8, r7, lsl #23
    344e:	ea4f 58d8 	mov.w	r8, r8, lsr #23
    3452:	f1b8 0f00 	cmp.w	r8, #0
    3456:	d136      	bne.n	34c6 <dir_next+0x9a>
		dp->sect++;				/* Next sector */

		if (dp->clust == 0) {	/* Static table */
    3458:	6961      	ldr	r1, [r4, #20]
	ofs = dp->dptr + SZDIRE;	/* Next entry */
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) dp->sect = 0;	/* Disable it if the offset reached the max value */
	if (dp->sect == 0) return FR_NO_FILE;	/* Report EOT if it has been disabled */

	if (ofs % SS(fs) == 0) {	/* Sector changed? */
		dp->sect++;				/* Next sector */
    345a:	3301      	adds	r3, #1
    345c:	61a3      	str	r3, [r4, #24]

		if (dp->clust == 0) {	/* Static table */
    345e:	b929      	cbnz	r1, 346c <dir_next+0x40>
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
    3460:	8933      	ldrh	r3, [r6, #8]
    3462:	ebb3 1f57 	cmp.w	r3, r7, lsr #5
    3466:	d82e      	bhi.n	34c6 <dir_next+0x9a>
				dp->sect = 0; return FR_NO_FILE;
    3468:	61a1      	str	r1, [r4, #24]
    346a:	e033      	b.n	34d4 <dir_next+0xa8>
			}
		}
		else {					/* Dynamic table */
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {	/* Cluster changed? */
    346c:	8973      	ldrh	r3, [r6, #10]
    346e:	3b01      	subs	r3, #1
    3470:	ea13 2357 	ands.w	r3, r3, r7, lsr #9
    3474:	d127      	bne.n	34c6 <dir_next+0x9a>
				clst = get_fat(&dp->obj, dp->clust);		/* Get next cluster */
    3476:	4630      	mov	r0, r6
    3478:	f7ff feb4 	bl	31e4 <get_fat.clone.2>
				if (clst <= 1) return FR_INT_ERR;			/* Internal error */
    347c:	2801      	cmp	r0, #1
				dp->sect = 0; return FR_NO_FILE;
			}
		}
		else {					/* Dynamic table */
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(&dp->obj, dp->clust);		/* Get next cluster */
    347e:	4605      	mov	r5, r0
				if (clst <= 1) return FR_INT_ERR;			/* Internal error */
    3480:	d92e      	bls.n	34e0 <dir_next+0xb4>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    3482:	f1b0 3fff 	cmp.w	r0, #4294967295
    3486:	d02e      	beq.n	34e6 <dir_next+0xba>
				if (clst >= fs->n_fatent) {					/* It reached end of dynamic table */
    3488:	69b3      	ldr	r3, [r6, #24]
    348a:	4298      	cmp	r0, r3
    348c:	d315      	bcc.n	34ba <dir_next+0x8e>
#if !FF_FS_READONLY
					if (!stretch) {								/* If no stretch, report EOT */
    348e:	f1b9 0f00 	cmp.w	r9, #0
    3492:	d102      	bne.n	349a <dir_next+0x6e>
						dp->sect = 0; return FR_NO_FILE;
    3494:	f8c4 9018 	str.w	r9, [r4, #24]
    3498:	e01c      	b.n	34d4 <dir_next+0xa8>
					}
					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
    349a:	4620      	mov	r0, r4
    349c:	6961      	ldr	r1, [r4, #20]
    349e:	f7ff ff49 	bl	3334 <create_chain.clone.3>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
    34a2:	4605      	mov	r5, r0
    34a4:	b1c8      	cbz	r0, 34da <dir_next+0xae>
					if (clst == 1) return FR_INT_ERR;			/* Internal error */
    34a6:	2801      	cmp	r0, #1
    34a8:	d01a      	beq.n	34e0 <dir_next+0xb4>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    34aa:	f1b0 3fff 	cmp.w	r0, #4294967295
    34ae:	d01a      	beq.n	34e6 <dir_next+0xba>
					if (dir_clear(fs, clst) != FR_OK) return FR_DISK_ERR;	/* Clean up the stretched table */
    34b0:	4630      	mov	r0, r6
    34b2:	4629      	mov	r1, r5
    34b4:	f7ff fbb8 	bl	2c28 <dir_clear>
    34b8:	b9c0      	cbnz	r0, 34ec <dir_next+0xc0>
#else
					if (!stretch) dp->sect = 0;					/* (this line is to suppress compiler warning) */
					dp->sect = 0; return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dp->clust = clst;		/* Initialize data for new cluster */
    34ba:	6165      	str	r5, [r4, #20]
				dp->sect = clst2sect(fs, clst);
    34bc:	4630      	mov	r0, r6
    34be:	4629      	mov	r1, r5
    34c0:	f7ff fac1 	bl	2a46 <clst2sect>
    34c4:	61a0      	str	r0, [r4, #24]
			}
		}
	}
	dp->dptr = ofs;						/* Current entry */
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
    34c6:	4446      	add	r6, r8
    34c8:	3634      	adds	r6, #52	; 0x34
				dp->clust = clst;		/* Initialize data for new cluster */
				dp->sect = clst2sect(fs, clst);
			}
		}
	}
	dp->dptr = ofs;						/* Current entry */
    34ca:	6127      	str	r7, [r4, #16]
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
    34cc:	61e6      	str	r6, [r4, #28]

	return FR_OK;
    34ce:	2000      	movs	r0, #0
    34d0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	FATFS *fs = dp->obj.fs;


	ofs = dp->dptr + SZDIRE;	/* Next entry */
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) dp->sect = 0;	/* Disable it if the offset reached the max value */
	if (dp->sect == 0) return FR_NO_FILE;	/* Report EOT if it has been disabled */
    34d4:	2004      	movs	r0, #4
    34d6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
#if !FF_FS_READONLY
					if (!stretch) {								/* If no stretch, report EOT */
						dp->sect = 0; return FR_NO_FILE;
					}
					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
					if (clst == 0) return FR_DENIED;			/* No free cluster */
    34da:	2007      	movs	r0, #7
    34dc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					if (clst == 1) return FR_INT_ERR;			/* Internal error */
    34e0:	2002      	movs	r0, #2
    34e2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    34e6:	2001      	movs	r0, #1
    34e8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					if (dir_clear(fs, clst) != FR_OK) return FR_DISK_ERR;	/* Clean up the stretched table */
    34ec:	2001      	movs	r0, #1
	}
	dp->dptr = ofs;						/* Current entry */
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */

	return FR_OK;
}
    34ee:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

000034f2 <dir_read>:

static FRESULT dir_read (
	DIR* dp,		/* Pointer to the directory object */
	int vol			/* Filtered by 0:file/directory or 1:volume label */
)
{
    34f2:	b570      	push	{r4, r5, r6, lr}
	FRESULT res = FR_NO_FILE;
    34f4:	2304      	movs	r3, #4

static FRESULT dir_read (
	DIR* dp,		/* Pointer to the directory object */
	int vol			/* Filtered by 0:file/directory or 1:volume label */
)
{
    34f6:	4604      	mov	r4, r0
    34f8:	460e      	mov	r6, r1
	FRESULT res = FR_NO_FILE;
	FATFS *fs = dp->obj.fs;
    34fa:	6805      	ldr	r5, [r0, #0]
	BYTE attr, b;
#if FF_USE_LFN
	BYTE ord = 0xFF, sum = 0xFF;
#endif

	while (dp->sect) {
    34fc:	e01f      	b.n	353e <dir_read+0x4c>
		res = move_window(fs, dp->sect);
    34fe:	4628      	mov	r0, r5
    3500:	f7ff fc18 	bl	2d34 <move_window>
		if (res != FR_OK) break;
    3504:	bb28      	cbnz	r0, 3552 <dir_read+0x60>
		b = dp->dir[DIR_Name];	/* Test for the entry type */
    3506:	69e3      	ldr	r3, [r4, #28]
    3508:	781a      	ldrb	r2, [r3, #0]
		if (b == 0) {
    350a:	b30a      	cbz	r2, 3550 <dir_read+0x5e>
				}
			}
		} else
#endif
		{	/* On the FAT/FAT32 volume */
			dp->obj.attr = attr = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
    350c:	7adb      	ldrb	r3, [r3, #11]
					}
					break;
				}
			}
#else		/* Non LFN configuration */
			if (b != DDEM && b != '.' && attr != AM_LFN && (int)((attr & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
    350e:	2ae5      	cmp	r2, #229	; 0xe5
				}
			}
		} else
#endif
		{	/* On the FAT/FAT32 volume */
			dp->obj.attr = attr = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
    3510:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    3514:	71a3      	strb	r3, [r4, #6]
					}
					break;
				}
			}
#else		/* Non LFN configuration */
			if (b != DDEM && b != '.' && attr != AM_LFN && (int)((attr & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
    3516:	d00c      	beq.n	3532 <dir_read+0x40>
    3518:	2a2e      	cmp	r2, #46	; 0x2e
    351a:	d00a      	beq.n	3532 <dir_read+0x40>
    351c:	2b0f      	cmp	r3, #15
    351e:	d008      	beq.n	3532 <dir_read+0x40>
    3520:	f023 0320 	bic.w	r3, r3, #32
    3524:	f1a3 0208 	sub.w	r2, r3, #8
    3528:	4253      	negs	r3, r2
    352a:	eb43 0302 	adc.w	r3, r3, r2
    352e:	42b3      	cmp	r3, r6
    3530:	d00d      	beq.n	354e <dir_read+0x5c>
				break;
			}
#endif
		}
		res = dir_next(dp, 0);		/* Next entry */
    3532:	4620      	mov	r0, r4
    3534:	2100      	movs	r1, #0
    3536:	f7ff ff79 	bl	342c <dir_next>
    353a:	4603      	mov	r3, r0
		if (res != FR_OK) break;
    353c:	b948      	cbnz	r0, 3552 <dir_read+0x60>
	BYTE attr, b;
#if FF_USE_LFN
	BYTE ord = 0xFF, sum = 0xFF;
#endif

	while (dp->sect) {
    353e:	69a1      	ldr	r1, [r4, #24]
    3540:	2900      	cmp	r1, #0
    3542:	d1dc      	bne.n	34fe <dir_read+0xc>
    3544:	4618      	mov	r0, r3
		}
		res = dir_next(dp, 0);		/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
    3546:	b113      	cbz	r3, 354e <dir_read+0x5c>
    3548:	2200      	movs	r2, #0
    354a:	61a2      	str	r2, [r4, #24]
    354c:	4618      	mov	r0, r3
	return res;
}
    354e:	bd70      	pop	{r4, r5, r6, pc}
	while (dp->sect) {
		res = move_window(fs, dp->sect);
		if (res != FR_OK) break;
		b = dp->dir[DIR_Name];	/* Test for the entry type */
		if (b == 0) {
			res = FR_NO_FILE; break; /* Reached to end of the directory */
    3550:	2004      	movs	r0, #4
	BYTE attr, b;
#if FF_USE_LFN
	BYTE ord = 0xFF, sum = 0xFF;
#endif

	while (dp->sect) {
    3552:	4603      	mov	r3, r0
    3554:	e7f8      	b.n	3548 <dir_read+0x56>

00003556 <follow_path>:

static FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR* dp,					/* Directory object to return last directory and found object */
	const TCHAR* path			/* Full-path string to find a file or directory */
)
{
    3556:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	BYTE ns;
	FATFS *fs = dp->obj.fs;


#if FF_FS_RPATH != 0
	if (*path != '/' && *path != '\\') {	/* Without heading separator */
    355a:	780b      	ldrb	r3, [r1, #0]

static FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR* dp,					/* Directory object to return last directory and found object */
	const TCHAR* path			/* Full-path string to find a file or directory */
)
{
    355c:	4604      	mov	r4, r0
	BYTE ns;
	FATFS *fs = dp->obj.fs;


#if FF_FS_RPATH != 0
	if (*path != '/' && *path != '\\') {	/* Without heading separator */
    355e:	2b2f      	cmp	r3, #47	; 0x2f

static FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR* dp,					/* Directory object to return last directory and found object */
	const TCHAR* path			/* Full-path string to find a file or directory */
)
{
    3560:	460e      	mov	r6, r1
	FRESULT res;
	BYTE ns;
	FATFS *fs = dp->obj.fs;
    3562:	6807      	ldr	r7, [r0, #0]


#if FF_FS_RPATH != 0
	if (*path != '/' && *path != '\\') {	/* Without heading separator */
    3564:	d001      	beq.n	356a <follow_path+0x14>
    3566:	2b5c      	cmp	r3, #92	; 0x5c
    3568:	d101      	bne.n	356e <follow_path+0x18>
    356a:	4633      	mov	r3, r6
    356c:	e001      	b.n	3572 <follow_path+0x1c>
		dp->obj.sclust = fs->cdir;				/* Start from current directory */
    356e:	697b      	ldr	r3, [r7, #20]
    3570:	e007      	b.n	3582 <follow_path+0x2c>
	} else
#endif
	{										/* With heading separator */
		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
    3572:	781a      	ldrb	r2, [r3, #0]
	FATFS *fs = dp->obj.fs;


#if FF_FS_RPATH != 0
	if (*path != '/' && *path != '\\') {	/* Without heading separator */
		dp->obj.sclust = fs->cdir;				/* Start from current directory */
    3574:	461e      	mov	r6, r3
	} else
#endif
	{										/* With heading separator */
		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
    3576:	3301      	adds	r3, #1
    3578:	2a2f      	cmp	r2, #47	; 0x2f
    357a:	d0fa      	beq.n	3572 <follow_path+0x1c>
    357c:	2a5c      	cmp	r2, #92	; 0x5c
    357e:	d0f8      	beq.n	3572 <follow_path+0x1c>
		dp->obj.sclust = 0;					/* Start from root directory */
    3580:	2300      	movs	r3, #0
    3582:	60a3      	str	r3, [r4, #8]
		dp->obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
	}
#endif
#endif

	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
    3584:	7833      	ldrb	r3, [r6, #0]
    3586:	2b1f      	cmp	r3, #31
    3588:	d808      	bhi.n	359c <follow_path+0x46>
		dp->fn[NSFLAG] = NS_NONAME;
    358a:	2380      	movs	r3, #128	; 0x80
		res = dir_sdi(dp, 0);
    358c:	4620      	mov	r0, r4
    358e:	2100      	movs	r1, #0
	}
#endif
#endif

	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
		dp->fn[NSFLAG] = NS_NONAME;
    3590:	f884 302b 	strb.w	r3, [r4, #43]	; 0x2b
			}
		}
	}

	return res;
}
    3594:	b001      	add	sp, #4
    3596:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#endif
#endif

	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
		dp->fn[NSFLAG] = NS_NONAME;
		res = dir_sdi(dp, 0);
    359a:	e67e      	b.n	329a <dir_sdi>
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	p = *path; sfn = dp->fn;
	mem_set(sfn, ' ', 11);
    359c:	2120      	movs	r1, #32
    359e:	220b      	movs	r2, #11
    35a0:	f104 0020 	add.w	r0, r4, #32
    35a4:	f7ff fa14 	bl	29d0 <mem_set>
	si = i = 0; ni = 8;
#if FF_FS_RPATH != 0
	if (p[si] == '.') { /* Is this a dot entry? */
    35a8:	7833      	ldrb	r3, [r6, #0]
    35aa:	2b2e      	cmp	r3, #46	; 0x2e
    35ac:	d005      	beq.n	35ba <follow_path+0x64>
    35ae:	f04f 0800 	mov.w	r8, #0
    35b2:	46c1      	mov	r9, r8
    35b4:	f04f 0a08 	mov.w	sl, #8
    35b8:	e019      	b.n	35ee <follow_path+0x98>
		for (;;) {
			c = (BYTE)p[si++];
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
    35ba:	f884 3020 	strb.w	r3, [r4, #32]
	mem_set(sfn, ' ', 11);
	si = i = 0; ni = 8;
#if FF_FS_RPATH != 0
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
    35be:	7873      	ldrb	r3, [r6, #1]
			if (c != '.' || si >= 3) break;
    35c0:	2b2e      	cmp	r3, #46	; 0x2e
    35c2:	d104      	bne.n	35ce <follow_path+0x78>
			sfn[i++] = c;
    35c4:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
	mem_set(sfn, ' ', 11);
	si = i = 0; ni = 8;
#if FF_FS_RPATH != 0
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
    35c8:	78b3      	ldrb	r3, [r6, #2]
    35ca:	2203      	movs	r2, #3
    35cc:	e000      	b.n	35d0 <follow_path+0x7a>
    35ce:	2202      	movs	r2, #2
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
    35d0:	2b2f      	cmp	r3, #47	; 0x2f
    35d2:	d004      	beq.n	35de <follow_path+0x88>
    35d4:	2b5c      	cmp	r3, #92	; 0x5c
    35d6:	d002      	beq.n	35de <follow_path+0x88>
    35d8:	2b20      	cmp	r3, #32
    35da:	f200 80b3 	bhi.w	3744 <follow_path+0x1ee>
		*path = p + si;								/* Return pointer to the next segment */
		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of the path */
    35de:	2b20      	cmp	r3, #32
    35e0:	bf8c      	ite	hi
    35e2:	2320      	movhi	r3, #32
    35e4:	2324      	movls	r3, #36	; 0x24
			c = (BYTE)p[si++];
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
		*path = p + si;								/* Return pointer to the next segment */
    35e6:	18b6      	adds	r6, r6, r2
		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of the path */
    35e8:	f884 302b 	strb.w	r3, [r4, #43]	; 0x2b
    35ec:	e0b1      	b.n	3752 <follow_path+0x1fc>
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];				/* Get a byte */
    35ee:	f816 5009 	ldrb.w	r5, [r6, r9]
    35f2:	f109 0901 	add.w	r9, r9, #1
		if (c <= ' ') break; 			/* Break if end of the path name */
    35f6:	2d20      	cmp	r5, #32
    35f8:	d94d      	bls.n	3696 <follow_path+0x140>
		if (c == '/' || c == '\\') {	/* Break if a separator is found */
    35fa:	2d2f      	cmp	r5, #47	; 0x2f
    35fc:	d004      	beq.n	3608 <follow_path+0xb2>
    35fe:	2d5c      	cmp	r5, #92	; 0x5c
    3600:	d109      	bne.n	3616 <follow_path+0xc0>
    3602:	e001      	b.n	3608 <follow_path+0xb2>
			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
    3604:	f109 0901 	add.w	r9, r9, #1
    3608:	f816 3009 	ldrb.w	r3, [r6, r9]
    360c:	2b2f      	cmp	r3, #47	; 0x2f
    360e:	d0f9      	beq.n	3604 <follow_path+0xae>
    3610:	2b5c      	cmp	r3, #92	; 0x5c
    3612:	d0f7      	beq.n	3604 <follow_path+0xae>
    3614:	e03f      	b.n	3696 <follow_path+0x140>
			break;
		}
		if (c == '.' || i >= ni) {		/* End of body or field overflow? */
    3616:	2d2e      	cmp	r5, #46	; 0x2e
    3618:	d001      	beq.n	361e <follow_path+0xc8>
    361a:	45d0      	cmp	r8, sl
    361c:	d30b      	bcc.n	3636 <follow_path+0xe0>
			if (ni == 11 || c != '.') return FR_INVALID_NAME;	/* Field overflow or invalid dot? */
    361e:	f1ba 0f0b 	cmp.w	sl, #11
    3622:	f000 808f 	beq.w	3744 <follow_path+0x1ee>
    3626:	2d2e      	cmp	r5, #46	; 0x2e
    3628:	f040 808c 	bne.w	3744 <follow_path+0x1ee>
			i = 8; ni = 11;				/* Enter file extension field */
    362c:	f04f 0808 	mov.w	r8, #8
    3630:	f04f 0a0b 	mov.w	sl, #11
    3634:	e7db      	b.n	35ee <follow_path+0x98>
#elif FF_CODE_PAGE < 900
		if (c >= 0x80) {				/* Is SBC extended character? */
			c = ExCvt[c & 0x7F];		/* To upper SBC extended character */
		}
#endif
		if (dbc_1st(c)) {				/* Check if it is a DBC 1st byte */
    3636:	4628      	mov	r0, r5
    3638:	f7ff f9e3 	bl	2a02 <dbc_1st>
    363c:	b1b8      	cbz	r0, 366e <follow_path+0x118>
			d = (BYTE)p[si++];			/* Get 2nd byte */
    363e:	f816 b009 	ldrb.w	fp, [r6, r9]
			if (!dbc_2nd(d) || i >= ni - 1) return FR_INVALID_NAME;	/* Reject invalid DBC */
    3642:	4658      	mov	r0, fp
    3644:	f7ff f9ee 	bl	2a24 <dbc_2nd>
    3648:	2800      	cmp	r0, #0
    364a:	d07b      	beq.n	3744 <follow_path+0x1ee>
    364c:	f10a 33ff 	add.w	r3, sl, #4294967295
    3650:	4598      	cmp	r8, r3
    3652:	d277      	bcs.n	3744 <follow_path+0x1ee>
			sfn[i++] = c;
    3654:	eb04 0308 	add.w	r3, r4, r8
    3658:	f108 0801 	add.w	r8, r8, #1
    365c:	f883 5020 	strb.w	r5, [r3, #32]
			sfn[i++] = d;
    3660:	eb04 0308 	add.w	r3, r4, r8
		if (c >= 0x80) {				/* Is SBC extended character? */
			c = ExCvt[c & 0x7F];		/* To upper SBC extended character */
		}
#endif
		if (dbc_1st(c)) {				/* Check if it is a DBC 1st byte */
			d = (BYTE)p[si++];			/* Get 2nd byte */
    3664:	f109 0901 	add.w	r9, r9, #1
			if (!dbc_2nd(d) || i >= ni - 1) return FR_INVALID_NAME;	/* Reject invalid DBC */
			sfn[i++] = c;
			sfn[i++] = d;
    3668:	f883 b020 	strb.w	fp, [r3, #32]
    366c:	e010      	b.n	3690 <follow_path+0x13a>
		} else {						/* SBC */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c)) return FR_INVALID_NAME;	/* Reject illegal chrs for SFN */
    366e:	483e      	ldr	r0, [pc, #248]	; (3768 <follow_path+0x212>)
    3670:	4629      	mov	r1, r5
    3672:	f7ff f9bf 	bl	29f4 <chk_chr>
    3676:	2800      	cmp	r0, #0
    3678:	d164      	bne.n	3744 <follow_path+0x1ee>
			if (IsLower(c)) c -= 0x20;	/* To upper */
    367a:	f1a5 0361 	sub.w	r3, r5, #97	; 0x61
    367e:	b2db      	uxtb	r3, r3
    3680:	2b19      	cmp	r3, #25
    3682:	d801      	bhi.n	3688 <follow_path+0x132>
    3684:	3d20      	subs	r5, #32
    3686:	b2ed      	uxtb	r5, r5
			sfn[i++] = c;
    3688:	eb04 0308 	add.w	r3, r4, r8
    368c:	f883 5020 	strb.w	r5, [r3, #32]
    3690:	f108 0801 	add.w	r8, r8, #1
    3694:	e7ab      	b.n	35ee <follow_path+0x98>
		}
	}
	*path = p + si;						/* Return pointer to the next segment */
	if (i == 0) return FR_INVALID_NAME;	/* Reject nul string */
    3696:	f1b8 0f00 	cmp.w	r8, #0
    369a:	d053      	beq.n	3744 <follow_path+0x1ee>

	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
    369c:	f894 3020 	ldrb.w	r3, [r4, #32]
    36a0:	2be5      	cmp	r3, #229	; 0xe5
    36a2:	d102      	bne.n	36aa <follow_path+0x154>
    36a4:	3be0      	subs	r3, #224	; 0xe0
    36a6:	f884 3020 	strb.w	r3, [r4, #32]
	sfn[NSFLAG] = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
    36aa:	2d20      	cmp	r5, #32
    36ac:	bf94      	ite	ls
    36ae:	2504      	movls	r5, #4
    36b0:	2500      	movhi	r5, #0
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c)) return FR_INVALID_NAME;	/* Reject illegal chrs for SFN */
			if (IsLower(c)) c -= 0x20;	/* To upper */
			sfn[i++] = c;
		}
	}
	*path = p + si;						/* Return pointer to the next segment */
    36b2:	444e      	add	r6, r9
	if (i == 0) return FR_INVALID_NAME;	/* Reject nul string */

	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
	sfn[NSFLAG] = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
    36b4:	f884 502b 	strb.w	r5, [r4, #43]	; 0x2b
    36b8:	e04b      	b.n	3752 <follow_path+0x1fc>
	/* On the FAT/FAT32 volume */
#if FF_USE_LFN
	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
#endif
	do {
		res = move_window(fs, dp->sect);
    36ba:	4640      	mov	r0, r8
    36bc:	69a1      	ldr	r1, [r4, #24]
    36be:	f7ff fb39 	bl	2d34 <move_window>
		if (res != FR_OK) break;
    36c2:	4605      	mov	r5, r0
    36c4:	b9b0      	cbnz	r0, 36f4 <follow_path+0x19e>
		c = dp->dir[DIR_Name];
    36c6:	69e0      	ldr	r0, [r4, #28]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    36c8:	7803      	ldrb	r3, [r0, #0]
    36ca:	b193      	cbz	r3, 36f2 <follow_path+0x19c>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
				ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
			}
		}
#else		/* Non LFN configuration */
		dp->obj.attr = dp->dir[DIR_Attr] & AM_MASK;
    36cc:	7ac3      	ldrb	r3, [r0, #11]
    36ce:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    36d2:	71a3      	strb	r3, [r4, #6]
		if (!(dp->dir[DIR_Attr] & AM_VOL) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry? */
    36d4:	7ac3      	ldrb	r3, [r0, #11]
    36d6:	f013 0f08 	tst.w	r3, #8
    36da:	d105      	bne.n	36e8 <follow_path+0x192>
    36dc:	f104 0120 	add.w	r1, r4, #32
    36e0:	220b      	movs	r2, #11
    36e2:	f7ff f97a 	bl	29da <mem_cmp>
    36e6:	b128      	cbz	r0, 36f4 <follow_path+0x19e>
#endif
		res = dir_next(dp, 0);	/* Next entry */
    36e8:	4620      	mov	r0, r4
    36ea:	2100      	movs	r1, #0
    36ec:	f7ff fe9e 	bl	342c <dir_next>
    36f0:	e035      	b.n	375e <follow_path+0x208>
#endif
	do {
		res = move_window(fs, dp->sect);
		if (res != FR_OK) break;
		c = dp->dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    36f2:	2504      	movs	r5, #4
	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
			if (res != FR_OK) break;
			res = dir_find(dp);				/* Find an object with the segment name */
			ns = dp->fn[NSFLAG];
    36f4:	f894 302b 	ldrb.w	r3, [r4, #43]	; 0x2b
			if (res != FR_OK) {				/* Failed to find the object */
    36f8:	b19d      	cbz	r5, 3722 <follow_path+0x1cc>
				if (res == FR_NO_FILE) {	/* Object is not found */
    36fa:	2d04      	cmp	r5, #4
    36fc:	d125      	bne.n	374a <follow_path+0x1f4>
					if (FF_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, stay there */
    36fe:	f013 0f20 	tst.w	r3, #32
    3702:	f003 0504 	and.w	r5, r3, #4
    3706:	d007      	beq.n	3718 <follow_path+0x1c2>
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
    3708:	2d00      	cmp	r5, #0
    370a:	f43f af47 	beq.w	359c <follow_path+0x46>
						dp->fn[NSFLAG] = NS_NONAME;
    370e:	2380      	movs	r3, #128	; 0x80
    3710:	f884 302b 	strb.w	r3, [r4, #43]	; 0x2b
						res = FR_OK;
    3714:	2500      	movs	r5, #0
    3716:	e018      	b.n	374a <follow_path+0x1f4>
					} else {							/* Could not find the object */
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
    3718:	2d00      	cmp	r5, #0
    371a:	bf14      	ite	ne
    371c:	2504      	movne	r5, #4
    371e:	2505      	moveq	r5, #5
    3720:	e013      	b.n	374a <follow_path+0x1f4>
					}
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
    3722:	f013 0f04 	tst.w	r3, #4
    3726:	d110      	bne.n	374a <follow_path+0x1f4>
			/* Get into the sub-directory */
			if (!(dp->obj.attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
    3728:	79a3      	ldrb	r3, [r4, #6]
    372a:	f013 0f10 	tst.w	r3, #16
    372e:	d00b      	beq.n	3748 <follow_path+0x1f2>
				dp->obj.c_ofs = dp->blk_ofs;
				init_alloc_info(fs, &dp->obj);	/* Open next directory */
			} else
#endif
			{
				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
    3730:	6921      	ldr	r1, [r4, #16]
    3732:	7838      	ldrb	r0, [r7, #0]
    3734:	05c9      	lsls	r1, r1, #23
    3736:	0dc9      	lsrs	r1, r1, #23
    3738:	1879      	adds	r1, r7, r1
    373a:	3134      	adds	r1, #52	; 0x34
    373c:	f7ff fd2c 	bl	3198 <ld_clust.clone.0>
    3740:	60a0      	str	r0, [r4, #8]
    3742:	e72b      	b.n	359c <follow_path+0x46>
			if (IsLower(c)) c -= 0x20;	/* To upper */
			sfn[i++] = c;
		}
	}
	*path = p + si;						/* Return pointer to the next segment */
	if (i == 0) return FR_INVALID_NAME;	/* Reject nul string */
    3744:	2506      	movs	r5, #6
    3746:	e000      	b.n	374a <follow_path+0x1f4>
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
			/* Get into the sub-directory */
			if (!(dp->obj.attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
				res = FR_NO_PATH; break;
    3748:	2505      	movs	r5, #5
			}
		}
	}

	return res;
}
    374a:	4628      	mov	r0, r5
    374c:	b001      	add	sp, #4
    374e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	BYTE c;
#if FF_USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dp, 0);			/* Rewind directory object */
    3752:	4620      	mov	r0, r4
    3754:	2100      	movs	r1, #0
static FRESULT dir_find (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp					/* Pointer to the directory object with the file name */
)
{
	FRESULT res;
	FATFS *fs = dp->obj.fs;
    3756:	f8d4 8000 	ldr.w	r8, [r4]
	BYTE c;
#if FF_USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dp, 0);			/* Rewind directory object */
    375a:	f7ff fd9e 	bl	329a <dir_sdi>
	if (res != FR_OK) return res;
    375e:	4605      	mov	r5, r0
    3760:	2800      	cmp	r0, #0
    3762:	d0aa      	beq.n	36ba <follow_path+0x164>
    3764:	e7c6      	b.n	36f4 <follow_path+0x19e>
    3766:	bf00      	nop
    3768:	00005cdc 	.word	0x00005cdc

0000376c <remove_chain.clone.4>:
#endif
#if FF_USE_TRIM
	DWORD rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
    376c:	2901      	cmp	r1, #1
#if !FF_FS_READONLY
/*-----------------------------------------------------------------------*/
/* FAT handling - Remove a cluster chain                                 */
/*-----------------------------------------------------------------------*/

static FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
    376e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3770:	4607      	mov	r7, r0
    3772:	460e      	mov	r6, r1
	DWORD pclst			/* Previous cluster of clst (0 if entire chain) */
)
{
	FRESULT res = FR_OK;
	DWORD nxt;
	FATFS *fs = obj->fs;
    3774:	6804      	ldr	r4, [r0, #0]
#endif
#if FF_USE_TRIM
	DWORD rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
    3776:	d92c      	bls.n	37d2 <remove_chain.clone.4+0x66>
    3778:	69a3      	ldr	r3, [r4, #24]
    377a:	4299      	cmp	r1, r3
    377c:	d229      	bcs.n	37d2 <remove_chain.clone.4+0x66>

	/* Mark the previous cluster 'EOC' on the FAT if it exists */
	if (pclst != 0 && (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
    377e:	b142      	cbz	r2, 3792 <remove_chain.clone.4+0x26>
		res = put_fat(fs, pclst, 0xFFFFFFFF);
    3780:	4611      	mov	r1, r2
    3782:	4620      	mov	r0, r4
    3784:	f04f 32ff 	mov.w	r2, #4294967295
    3788:	f7ff fc7a 	bl	3080 <put_fat>
		if (res != FR_OK) return res;
    378c:	b108      	cbz	r0, 3792 <remove_chain.clone.4+0x26>
    378e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
#endif
			scl = ecl = nxt;
		}
#endif
		clst = nxt;					/* Next cluster */
	} while (clst < fs->n_fatent);	/* Repeat while not the last link */
    3790:	462e      	mov	r6, r5
		if (res != FR_OK) return res;
	}

	/* Remove the chain */
	do {
		nxt = get_fat(obj, clst);			/* Get cluster status */
    3792:	6838      	ldr	r0, [r7, #0]
    3794:	4631      	mov	r1, r6
    3796:	f7ff fd25 	bl	31e4 <get_fat.clone.2>
		if (nxt == 0) break;				/* Empty cluster? */
    379a:	4605      	mov	r5, r0
    379c:	b1c0      	cbz	r0, 37d0 <remove_chain.clone.4+0x64>
		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
    379e:	2801      	cmp	r0, #1
    37a0:	d017      	beq.n	37d2 <remove_chain.clone.4+0x66>
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
    37a2:	f1b0 3fff 	cmp.w	r0, #4294967295
    37a6:	d016      	beq.n	37d6 <remove_chain.clone.4+0x6a>
		if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {
			res = put_fat(fs, clst, 0);		/* Mark the cluster 'free' on the FAT */
    37a8:	4620      	mov	r0, r4
    37aa:	4631      	mov	r1, r6
    37ac:	2200      	movs	r2, #0
    37ae:	f7ff fc67 	bl	3080 <put_fat>
			if (res != FR_OK) return res;
    37b2:	b988      	cbnz	r0, 37d8 <remove_chain.clone.4+0x6c>
		}
		if (fs->free_clst < fs->n_fatent - 2) {	/* Update FSINFO */
    37b4:	69a3      	ldr	r3, [r4, #24]
    37b6:	6922      	ldr	r2, [r4, #16]
    37b8:	1e99      	subs	r1, r3, #2
    37ba:	428a      	cmp	r2, r1
    37bc:	d205      	bcs.n	37ca <remove_chain.clone.4+0x5e>
			fs->free_clst++;
    37be:	3201      	adds	r2, #1
    37c0:	6122      	str	r2, [r4, #16]
			fs->fsi_flag |= 1;
    37c2:	7922      	ldrb	r2, [r4, #4]
    37c4:	f042 0201 	orr.w	r2, r2, #1
    37c8:	7122      	strb	r2, [r4, #4]
#endif
			scl = ecl = nxt;
		}
#endif
		clst = nxt;					/* Next cluster */
	} while (clst < fs->n_fatent);	/* Repeat while not the last link */
    37ca:	429d      	cmp	r5, r3
    37cc:	d3e0      	bcc.n	3790 <remove_chain.clone.4+0x24>
    37ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    37d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	/* Remove the chain */
	do {
		nxt = get_fat(obj, clst);			/* Get cluster status */
		if (nxt == 0) break;				/* Empty cluster? */
		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
    37d2:	2002      	movs	r0, #2
    37d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
    37d6:	2001      	movs	r0, #1
			}
		}
	}
#endif
	return FR_OK;
}
    37d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000037da <dir_alloc.clone.5>:
#if !FF_FS_READONLY
/*-----------------------------------------------------------------------*/
/* Directory handling - Reserve a block of directory entries             */
/*-----------------------------------------------------------------------*/

static FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
    37da:	b538      	push	{r3, r4, r5, lr}
	FRESULT res;
	UINT n;
	FATFS *fs = dp->obj.fs;


	res = dir_sdi(dp, 0);
    37dc:	2100      	movs	r1, #0
#if !FF_FS_READONLY
/*-----------------------------------------------------------------------*/
/* Directory handling - Reserve a block of directory entries             */
/*-----------------------------------------------------------------------*/

static FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
    37de:	4604      	mov	r4, r0
	UINT nent				/* Number of contiguous entries to allocate */
)
{
	FRESULT res;
	UINT n;
	FATFS *fs = dp->obj.fs;
    37e0:	6805      	ldr	r5, [r0, #0]


	res = dir_sdi(dp, 0);
    37e2:	f7ff fd5a 	bl	329a <dir_sdi>
	if (res == FR_OK) {
    37e6:	b970      	cbnz	r0, 3806 <dir_alloc.clone.5+0x2c>
		n = 0;
		do {
			res = move_window(fs, dp->sect);
    37e8:	4628      	mov	r0, r5
    37ea:	69a1      	ldr	r1, [r4, #24]
    37ec:	f7ff faa2 	bl	2d34 <move_window>
			if (res != FR_OK) break;
    37f0:	b948      	cbnz	r0, 3806 <dir_alloc.clone.5+0x2c>
#if FF_FS_EXFAT
			if ((fs->fs_type == FS_EXFAT) ? (int)((dp->dir[XDIR_Type] & 0x80) == 0) : (int)(dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0)) {
#else
			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
    37f2:	69e3      	ldr	r3, [r4, #28]
    37f4:	781b      	ldrb	r3, [r3, #0]
    37f6:	2be5      	cmp	r3, #229	; 0xe5
    37f8:	d008      	beq.n	380c <dir_alloc.clone.5+0x32>
    37fa:	b13b      	cbz	r3, 380c <dir_alloc.clone.5+0x32>
#endif
				if (++n == nent) break;	/* A block of contiguous free entries is found */
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
			}
			res = dir_next(dp, 1);
    37fc:	4620      	mov	r0, r4
    37fe:	2101      	movs	r1, #1
    3800:	f7ff fe14 	bl	342c <dir_next>
    3804:	e7ef      	b.n	37e6 <dir_alloc.clone.5+0xc>
		} while (res == FR_OK);	/* Next entry with table stretch enabled */
	}

	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
    3806:	2804      	cmp	r0, #4
    3808:	bf08      	it	eq
    380a:	2007      	moveq	r0, #7
	return res;
}
    380c:	bd38      	pop	{r3, r4, r5, pc}

0000380e <dir_register>:
/*-----------------------------------------------------------------------*/

static FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
	DIR* dp						/* Target directory with object name to be created */
)
{
    380e:	b570      	push	{r4, r5, r6, lr}
    3810:	4605      	mov	r5, r0
	FRESULT res;
	FATFS *fs = dp->obj.fs;
    3812:	6806      	ldr	r6, [r0, #0]
			} while (res == FR_OK && --nent);
		}
	}

#else	/* Non LFN configuration */
	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
    3814:	f7ff ffe1 	bl	37da <dir_alloc.clone.5>

#endif

	/* Set SFN entry */
	if (res == FR_OK) {
    3818:	4604      	mov	r4, r0
    381a:	b990      	cbnz	r0, 3842 <dir_register+0x34>
		res = move_window(fs, dp->sect);
    381c:	4630      	mov	r0, r6
    381e:	69a9      	ldr	r1, [r5, #24]
    3820:	f7ff fa88 	bl	2d34 <move_window>
		if (res == FR_OK) {
    3824:	4604      	mov	r4, r0
    3826:	b960      	cbnz	r0, 3842 <dir_register+0x34>
			mem_set(dp->dir, 0, SZDIRE);	/* Clean the entry */
    3828:	69e8      	ldr	r0, [r5, #28]
    382a:	4621      	mov	r1, r4
    382c:	2220      	movs	r2, #32
    382e:	f7ff f8cf 	bl	29d0 <mem_set>
			mem_cpy(dp->dir + DIR_Name, dp->fn, 11);	/* Put SFN */
    3832:	69e8      	ldr	r0, [r5, #28]
    3834:	f105 0120 	add.w	r1, r5, #32
    3838:	220b      	movs	r2, #11
    383a:	f7ff f8c1 	bl	29c0 <mem_cpy>
#if FF_USE_LFN
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
#endif
			fs->wflag = 1;
    383e:	2301      	movs	r3, #1
    3840:	70f3      	strb	r3, [r6, #3]
		}
	}

	return res;
}
    3842:	4620      	mov	r0, r4
    3844:	bd70      	pop	{r4, r5, r6, pc}

00003846 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the filesystem object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
    3846:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    3848:	9001      	str	r0, [sp, #4]
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
    384a:	a804      	add	r0, sp, #16
    384c:	f840 1d04 	str.w	r1, [r0, #-4]!
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the filesystem object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
    3850:	9100      	str	r1, [sp, #0]
    3852:	4614      	mov	r4, r2
	FRESULT res;
	const TCHAR *rp = path;


	/* Get logical drive number */
	vol = get_ldnumber(&rp);
    3854:	f7ff f9a1 	bl	2b9a <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
    3858:	2800      	cmp	r0, #0
    385a:	db14      	blt.n	3886 <f_mount+0x40>
	cfs = FatFs[vol];					/* Pointer to fs object */
    385c:	4a0c      	ldr	r2, [pc, #48]	; (3890 <f_mount+0x4a>)
    385e:	eb02 0380 	add.w	r3, r2, r0, lsl #2
    3862:	685b      	ldr	r3, [r3, #4]

	if (cfs) {
    3864:	b10b      	cbz	r3, 386a <f_mount+0x24>
		clear_lock(cfs);
#endif
#if FF_FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
    3866:	2100      	movs	r1, #0
    3868:	7019      	strb	r1, [r3, #0]
	}

	if (fs) {
    386a:	9b01      	ldr	r3, [sp, #4]
    386c:	b10b      	cbz	r3, 3872 <f_mount+0x2c>
		fs->fs_type = 0;				/* Clear new fs object */
    386e:	2100      	movs	r1, #0
    3870:	7019      	strb	r1, [r3, #0]
#if FF_FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
    3872:	eb02 0080 	add.w	r0, r2, r0, lsl #2
    3876:	6043      	str	r3, [r0, #4]

	if (opt == 0) return FR_OK;			/* Do not mount now, it will be mounted later */
    3878:	b13c      	cbz	r4, 388a <f_mount+0x44>

	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
    387a:	4668      	mov	r0, sp
    387c:	a901      	add	r1, sp, #4
    387e:	2200      	movs	r2, #0
    3880:	f7ff faaa 	bl	2dd8 <find_volume>
	LEAVE_FF(fs, res);
    3884:	e002      	b.n	388c <f_mount+0x46>
	const TCHAR *rp = path;


	/* Get logical drive number */
	vol = get_ldnumber(&rp);
	if (vol < 0) return FR_INVALID_DRIVE;
    3886:	200b      	movs	r0, #11
    3888:	e000      	b.n	388c <f_mount+0x46>
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */

	if (opt == 0) return FR_OK;			/* Do not mount now, it will be mounted later */
    388a:	4620      	mov	r0, r4

	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
	LEAVE_FF(fs, res);
}
    388c:	b004      	add	sp, #16
    388e:	bd10      	pop	{r4, pc}
    3890:	1000012c 	.word	0x1000012c

00003894 <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
    3894:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3898:	b090      	sub	sp, #64	; 0x40
    389a:	9101      	str	r1, [sp, #4]
	FSIZE_t ofs;
#endif
	DEF_NAMBUF


	if (!fp) return FR_INVALID_OBJECT;
    389c:	4604      	mov	r4, r0
    389e:	2800      	cmp	r0, #0
    38a0:	f000 80d3 	beq.w	3a4a <f_open+0x1b6>

	/* Get logical drive number */
	mode &= FF_FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND;
    38a4:	f002 063f 	and.w	r6, r2, #63	; 0x3f
	res = find_volume(&path, &fs, mode);
    38a8:	a801      	add	r0, sp, #4
    38aa:	a90f      	add	r1, sp, #60	; 0x3c
    38ac:	4632      	mov	r2, r6
    38ae:	f7ff fa93 	bl	2dd8 <find_volume>
	if (res == FR_OK) {
    38b2:	4605      	mov	r5, r0
    38b4:	2800      	cmp	r0, #0
    38b6:	f040 80c5 	bne.w	3a44 <f_open+0x1b0>
		dj.obj.fs = fs;
    38ba:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    38bc:	a810      	add	r0, sp, #64	; 0x40
    38be:	f840 3d34 	str.w	r3, [r0, #-52]!
		INIT_NAMBUF(fs);
		res = follow_path(&dj, path);	/* Follow the file path */
    38c2:	9901      	ldr	r1, [sp, #4]
    38c4:	f7ff fe47 	bl	3556 <follow_path>
#if !FF_FS_READONLY	/* Read/Write configuration */
		if (res == FR_OK) {
    38c8:	b928      	cbnz	r0, 38d6 <f_open+0x42>
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
    38ca:	f99d 3037 	ldrsb.w	r3, [sp, #55]	; 0x37
				res = FR_INVALID_NAME;
    38ce:	ea30 0023 	bics.w	r0, r0, r3, asr #32
    38d2:	bf28      	it	cs
    38d4:	2006      	movcs	r0, #6
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);		/* Check if the file can be used */
			}
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    38d6:	f016 0f1c 	tst.w	r6, #28
    38da:	d049      	beq.n	3970 <f_open+0xdc>
			if (res != FR_OK) {					/* No file, create new */
    38dc:	b148      	cbz	r0, 38f2 <f_open+0x5e>
				if (res == FR_NO_FILE) {		/* There is no file to open, create a new entry */
    38de:	2804      	cmp	r0, #4
    38e0:	d17b      	bne.n	39da <f_open+0x146>
#if FF_FS_LOCK != 0
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
    38e2:	a803      	add	r0, sp, #12
    38e4:	f7ff ff93 	bl	380e <dir_register>
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate the file if overwrite mode */
    38e8:	2800      	cmp	r0, #0
    38ea:	d176      	bne.n	39da <f_open+0x146>
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
#endif
				}
				mode |= FA_CREATE_ALWAYS;		/* File is created */
    38ec:	f046 0608 	orr.w	r6, r6, #8
    38f0:	e009      	b.n	3906 <f_open+0x72>
			}
			else {								/* Any object with the same name is already existing */
				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
    38f2:	f89d 3012 	ldrb.w	r3, [sp, #18]
    38f6:	f013 0f11 	tst.w	r3, #17
    38fa:	f040 80af 	bne.w	3a5c <f_open+0x1c8>
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
    38fe:	f016 0f04 	tst.w	r6, #4
    3902:	f040 80a7 	bne.w	3a54 <f_open+0x1c0>
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate the file if overwrite mode */
    3906:	f016 0f08 	tst.w	r6, #8
    390a:	d03e      	beq.n	398a <f_open+0xf6>
					}
				} else
#endif
				{
					/* Set directory entry initial state */
					cl = ld_clust(fs, dj.dir);			/* Get current cluster chain */
    390c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    390e:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
    3912:	7818      	ldrb	r0, [r3, #0]
    3914:	4641      	mov	r1, r8
    3916:	f7ff fc3f 	bl	3198 <ld_clust.clone.0>
    391a:	4607      	mov	r7, r0
					st_dword(dj.dir + DIR_CrtTime, GET_FATTIME());	/* Set created time */
    391c:	f7fc fd60 	bl	3e0 <get_fattime>
    3920:	4601      	mov	r1, r0
    3922:	f108 000e 	add.w	r0, r8, #14
    3926:	f7ff f841 	bl	29ac <st_dword>
					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
    392a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    392c:	2220      	movs	r2, #32
    392e:	72da      	strb	r2, [r3, #11]
					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
    3930:	980f      	ldr	r0, [sp, #60]	; 0x3c
    3932:	3a20      	subs	r2, #32
    3934:	990a      	ldr	r1, [sp, #40]	; 0x28
    3936:	f7ff fc41 	bl	31bc <st_clust.clone.1>
					st_dword(dj.dir + DIR_FileSize, 0);
    393a:	980a      	ldr	r0, [sp, #40]	; 0x28
    393c:	2100      	movs	r1, #0
    393e:	301c      	adds	r0, #28
    3940:	f7ff f834 	bl	29ac <st_dword>
					fs->wflag = 1;
    3944:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    3946:	2201      	movs	r2, #1
    3948:	70da      	strb	r2, [r3, #3]
					if (cl != 0) {						/* Remove the cluster chain if exist */
    394a:	b1f7      	cbz	r7, 398a <f_open+0xf6>
						dw = fs->winsect;
						res = remove_chain(&dj.obj, cl, 0);
    394c:	a803      	add	r0, sp, #12
    394e:	4639      	mov	r1, r7
    3950:	3a01      	subs	r2, #1
					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
					st_dword(dj.dir + DIR_FileSize, 0);
					fs->wflag = 1;
					if (cl != 0) {						/* Remove the cluster chain if exist */
						dw = fs->winsect;
    3952:	f8d3 8030 	ldr.w	r8, [r3, #48]	; 0x30
						res = remove_chain(&dj.obj, cl, 0);
    3956:	f7ff ff09 	bl	376c <remove_chain.clone.4>
						if (res == FR_OK) {
    395a:	2800      	cmp	r0, #0
    395c:	d13d      	bne.n	39da <f_open+0x146>
							res = move_window(fs, dw);
    395e:	980f      	ldr	r0, [sp, #60]	; 0x3c
    3960:	4641      	mov	r1, r8
    3962:	f7ff f9e7 	bl	2d34 <move_window>
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
    3966:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    3968:	3f01      	subs	r7, #1
    396a:	60df      	str	r7, [r3, #12]
						res = FR_DENIED;
					}
				}
			}
		}
		if (res == FR_OK) {
    396c:	b168      	cbz	r0, 398a <f_open+0xf6>
    396e:	e034      	b.n	39da <f_open+0x146>
					}
				}
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {					/* Is the object exsiting? */
    3970:	2800      	cmp	r0, #0
    3972:	d132      	bne.n	39da <f_open+0x146>
				if (dj.obj.attr & AM_DIR) {		/* File open against a directory */
    3974:	f89d 3012 	ldrb.w	r3, [sp, #18]
    3978:	f013 0f10 	tst.w	r3, #16
    397c:	d16c      	bne.n	3a58 <f_open+0x1c4>
					res = FR_NO_FILE;
				} else {
					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* Write mode open against R/O file */
    397e:	f016 0f02 	tst.w	r6, #2
    3982:	d002      	beq.n	398a <f_open+0xf6>
    3984:	f013 0f01 	tst.w	r3, #1
    3988:	d168      	bne.n	3a5c <f_open+0x1c8>
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS) mode |= FA_MODIFIED;	/* Set file change flag if created or overwritten */
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
    398a:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
			fp->dir_ptr = dj.dir;
    398c:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS) mode |= FA_MODIFIED;	/* Set file change flag if created or overwritten */
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
    3990:	6b3b      	ldr	r3, [r7, #48]	; 0x30
			fp->dir_ptr = dj.dir;
    3992:	f8c4 8024 	str.w	r8, [r4, #36]	; 0x24
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS) mode |= FA_MODIFIED;	/* Set file change flag if created or overwritten */
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
    3996:	6223      	str	r3, [r4, #32]
				fp->obj.c_ofs = dj.blk_ofs;
				init_alloc_info(fs, &fp->obj);
			} else
#endif
			{
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
    3998:	7838      	ldrb	r0, [r7, #0]
					}
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS) mode |= FA_MODIFIED;	/* Set file change flag if created or overwritten */
    399a:	f016 0f08 	tst.w	r6, #8
				fp->obj.c_ofs = dj.blk_ofs;
				init_alloc_info(fs, &fp->obj);
			} else
#endif
			{
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
    399e:	4641      	mov	r1, r8
					}
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS) mode |= FA_MODIFIED;	/* Set file change flag if created or overwritten */
    39a0:	bf18      	it	ne
    39a2:	f046 0640 	orrne.w	r6, r6, #64	; 0x40
				fp->obj.c_ofs = dj.blk_ofs;
				init_alloc_info(fs, &fp->obj);
			} else
#endif
			{
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
    39a6:	f7ff fbf7 	bl	3198 <ld_clust.clone.0>
    39aa:	60a0      	str	r0, [r4, #8]
				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
    39ac:	f108 001c 	add.w	r0, r8, #28
    39b0:	f7fe ffed 	bl	298e <ld_dword>
			}
#if FF_USE_FASTSEEK
			fp->cltbl = 0;			/* Disable fast seek mode */
#endif
			fp->obj.fs = fs;	 	/* Validate the file object */
    39b4:	6027      	str	r7, [r4, #0]
			fp->obj.id = fs->id;
    39b6:	88ff      	ldrh	r7, [r7, #6]
			fp->flag = mode;		/* Set file access mode */
			fp->err = 0;			/* Clear error flag */
    39b8:	2100      	movs	r1, #0
				init_alloc_info(fs, &fp->obj);
			} else
#endif
			{
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
    39ba:	60e0      	str	r0, [r4, #12]
			}
#if FF_USE_FASTSEEK
			fp->cltbl = 0;			/* Disable fast seek mode */
#endif
			fp->obj.fs = fs;	 	/* Validate the file object */
			fp->obj.id = fs->id;
    39bc:	80a7      	strh	r7, [r4, #4]
			fp->flag = mode;		/* Set file access mode */
    39be:	7426      	strb	r6, [r4, #16]
			fp->err = 0;			/* Clear error flag */
    39c0:	7461      	strb	r1, [r4, #17]
			fp->sect = 0;			/* Invalidate current data sector */
    39c2:	61e1      	str	r1, [r4, #28]
			fp->fptr = 0;			/* Set file pointer top of the file */
    39c4:	6161      	str	r1, [r4, #20]
#if !FF_FS_READONLY
#if !FF_FS_TINY
			mem_set(fp->buf, 0, sizeof fp->buf);	/* Clear sector buffer */
    39c6:	f104 0028 	add.w	r0, r4, #40	; 0x28
    39ca:	f44f 7200 	mov.w	r2, #512	; 0x200
    39ce:	f7fe ffff 	bl	29d0 <mem_set>
#endif
			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
    39d2:	f016 0f20 	tst.w	r6, #32
    39d6:	d102      	bne.n	39de <f_open+0x14a>
    39d8:	e038      	b.n	3a4c <f_open+0x1b8>
				fp->fptr = fp->obj.objsize;			/* Offset to seek */
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
				clst = fp->obj.sclust;				/* Follow the cluster chain */
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
    39da:	4605      	mov	r5, r0
    39dc:	e032      	b.n	3a44 <f_open+0x1b0>
			fp->fptr = 0;			/* Set file pointer top of the file */
#if !FF_FS_READONLY
#if !FF_FS_TINY
			mem_set(fp->buf, 0, sizeof fp->buf);	/* Clear sector buffer */
#endif
			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
    39de:	68e6      	ldr	r6, [r4, #12]
    39e0:	2e00      	cmp	r6, #0
    39e2:	d033      	beq.n	3a4c <f_open+0x1b8>
				fp->fptr = fp->obj.objsize;			/* Offset to seek */
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
    39e4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
#if !FF_FS_READONLY
#if !FF_FS_TINY
			mem_set(fp->buf, 0, sizeof fp->buf);	/* Clear sector buffer */
#endif
			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
				fp->fptr = fp->obj.objsize;			/* Offset to seek */
    39e6:	6166      	str	r6, [r4, #20]
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
    39e8:	895f      	ldrh	r7, [r3, #10]
				clst = fp->obj.sclust;				/* Follow the cluster chain */
    39ea:	68a1      	ldr	r1, [r4, #8]
#if !FF_FS_TINY
			mem_set(fp->buf, 0, sizeof fp->buf);	/* Clear sector buffer */
#endif
			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
				fp->fptr = fp->obj.objsize;			/* Offset to seek */
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
    39ec:	027f      	lsls	r7, r7, #9
    39ee:	e00e      	b.n	3a0e <f_open+0x17a>
				clst = fp->obj.sclust;				/* Follow the cluster chain */
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
					clst = get_fat(&fp->obj, clst);
    39f0:	6820      	ldr	r0, [r4, #0]
    39f2:	f7ff fbf7 	bl	31e4 <get_fat.clone.2>
					if (clst <= 1) res = FR_INT_ERR;
    39f6:	2801      	cmp	r0, #1
			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
				fp->fptr = fp->obj.objsize;			/* Offset to seek */
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
				clst = fp->obj.sclust;				/* Follow the cluster chain */
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
					clst = get_fat(&fp->obj, clst);
    39f8:	4601      	mov	r1, r0
					if (clst <= 1) res = FR_INT_ERR;
    39fa:	d905      	bls.n	3a08 <f_open+0x174>
					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
    39fc:	f1a0 30ff 	sub.w	r0, r0, #4294967295
    3a00:	4243      	negs	r3, r0
    3a02:	eb43 0300 	adc.w	r3, r3, r0
    3a06:	e000      	b.n	3a0a <f_open+0x176>
				fp->fptr = fp->obj.objsize;			/* Offset to seek */
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
				clst = fp->obj.sclust;				/* Follow the cluster chain */
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
					clst = get_fat(&fp->obj, clst);
					if (clst <= 1) res = FR_INT_ERR;
    3a08:	2302      	movs	r3, #2
					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
    3a0a:	1bf6      	subs	r6, r6, r7
#endif
			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
				fp->fptr = fp->obj.objsize;			/* Offset to seek */
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
				clst = fp->obj.sclust;				/* Follow the cluster chain */
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
    3a0c:	b913      	cbnz	r3, 3a14 <f_open+0x180>
    3a0e:	42be      	cmp	r6, r7
    3a10:	d8ee      	bhi.n	39f0 <f_open+0x15c>
    3a12:	e000      	b.n	3a16 <f_open+0x182>
    3a14:	461d      	mov	r5, r3
					clst = get_fat(&fp->obj, clst);
					if (clst <= 1) res = FR_INT_ERR;
					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
				}
				fp->clust = clst;
    3a16:	61a1      	str	r1, [r4, #24]
				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
    3a18:	b9a5      	cbnz	r5, 3a44 <f_open+0x1b0>
    3a1a:	05f3      	lsls	r3, r6, #23
    3a1c:	0ddb      	lsrs	r3, r3, #23
    3a1e:	b1ab      	cbz	r3, 3a4c <f_open+0x1b8>
					if ((sc = clst2sect(fs, clst)) == 0) {
    3a20:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
    3a22:	4638      	mov	r0, r7
    3a24:	f7ff f80f 	bl	2a46 <clst2sect>
    3a28:	b158      	cbz	r0, 3a42 <f_open+0x1ae>
						res = FR_INT_ERR;
					} else {
						fp->sect = sc + (DWORD)(ofs / SS(fs));
    3a2a:	eb00 2256 	add.w	r2, r0, r6, lsr #9
    3a2e:	61e2      	str	r2, [r4, #28]
#if !FF_FS_TINY
						if (disk_read(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
    3a30:	7878      	ldrb	r0, [r7, #1]
    3a32:	f104 0128 	add.w	r1, r4, #40	; 0x28
    3a36:	2301      	movs	r3, #1
    3a38:	f7fe fdca 	bl	25d0 <disk_read>
    3a3c:	b130      	cbz	r0, 3a4c <f_open+0x1b8>
    3a3e:	3501      	adds	r5, #1
    3a40:	e000      	b.n	3a44 <f_open+0x1b0>
					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
				}
				fp->clust = clst;
				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
					if ((sc = clst2sect(fs, clst)) == 0) {
						res = FR_INT_ERR;
    3a42:	2502      	movs	r5, #2
		}

		FREE_NAMBUF();
	}

	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
    3a44:	2300      	movs	r3, #0
    3a46:	6023      	str	r3, [r4, #0]
    3a48:	e000      	b.n	3a4c <f_open+0x1b8>
	FSIZE_t ofs;
#endif
	DEF_NAMBUF


	if (!fp) return FR_INVALID_OBJECT;
    3a4a:	2509      	movs	r5, #9
	}

	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */

	LEAVE_FF(fs, res);
}
    3a4c:	4628      	mov	r0, r5
    3a4e:	b010      	add	sp, #64	; 0x40
    3a50:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			}
			else {								/* Any object with the same name is already existing */
				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
    3a54:	2008      	movs	r0, #8
    3a56:	e7c0      	b.n	39da <f_open+0x146>
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {					/* Is the object exsiting? */
				if (dj.obj.attr & AM_DIR) {		/* File open against a directory */
					res = FR_NO_FILE;
    3a58:	2004      	movs	r0, #4
    3a5a:	e7be      	b.n	39da <f_open+0x146>
				} else {
					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* Write mode open against R/O file */
						res = FR_DENIED;
    3a5c:	2007      	movs	r0, #7
    3a5e:	e7bc      	b.n	39da <f_open+0x146>

00003a60 <f_read>:
	FIL* fp, 	/* Pointer to the file object */
	void* buff,	/* Pointer to data buffer */
	UINT btr,	/* Number of bytes to read */
	UINT* br	/* Pointer to number of bytes read */
)
{
    3a60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3a64:	469a      	mov	sl, r3
    3a66:	b085      	sub	sp, #20
	FSIZE_t remain;
	UINT rcnt, cc, csect;
	BYTE *rbuff = (BYTE*)buff;


	*br = 0;	/* Clear read byte counter */
    3a68:	2300      	movs	r3, #0
	FIL* fp, 	/* Pointer to the file object */
	void* buff,	/* Pointer to data buffer */
	UINT btr,	/* Number of bytes to read */
	UINT* br	/* Pointer to number of bytes read */
)
{
    3a6a:	4688      	mov	r8, r1
	FSIZE_t remain;
	UINT rcnt, cc, csect;
	BYTE *rbuff = (BYTE*)buff;


	*br = 0;	/* Clear read byte counter */
    3a6c:	f8ca 3000 	str.w	r3, [sl]
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
    3a70:	a903      	add	r1, sp, #12
	FIL* fp, 	/* Pointer to the file object */
	void* buff,	/* Pointer to data buffer */
	UINT btr,	/* Number of bytes to read */
	UINT* br	/* Pointer to number of bytes read */
)
{
    3a72:	4604      	mov	r4, r0
    3a74:	4616      	mov	r6, r2
	UINT rcnt, cc, csect;
	BYTE *rbuff = (BYTE*)buff;


	*br = 0;	/* Clear read byte counter */
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
    3a76:	f7ff f945 	bl	2d04 <validate>
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
    3a7a:	4605      	mov	r5, r0
    3a7c:	2800      	cmp	r0, #0
    3a7e:	f040 809d 	bne.w	3bbc <f_read+0x15c>
    3a82:	7c65      	ldrb	r5, [r4, #17]
    3a84:	2d00      	cmp	r5, #0
    3a86:	f040 8099 	bne.w	3bbc <f_read+0x15c>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
    3a8a:	7c23      	ldrb	r3, [r4, #16]
    3a8c:	f013 0f01 	tst.w	r3, #1
    3a90:	f000 8093 	beq.w	3bba <f_read+0x15a>
	remain = fp->obj.objsize - fp->fptr;
    3a94:	68e2      	ldr	r2, [r4, #12]
    3a96:	6963      	ldr	r3, [r4, #20]
    3a98:	ebc3 0902 	rsb	r9, r3, r2
	FRESULT res;
	FATFS *fs;
	DWORD clst, sect;
	FSIZE_t remain;
	UINT rcnt, cc, csect;
	BYTE *rbuff = (BYTE*)buff;
    3a9c:	454e      	cmp	r6, r9
    3a9e:	bf38      	it	cc
    3aa0:	46b1      	movcc	r9, r6
    3aa2:	e085      	b.n	3bb0 <f_read+0x150>
	remain = fp->obj.objsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until btr bytes read */
		btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {
		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
    3aa4:	6962      	ldr	r2, [r4, #20]
    3aa6:	05d3      	lsls	r3, r2, #23
    3aa8:	0ddb      	lsrs	r3, r3, #23
    3aaa:	2b00      	cmp	r3, #0
    3aac:	d166      	bne.n	3b7c <f_read+0x11c>
			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
    3aae:	9b03      	ldr	r3, [sp, #12]
    3ab0:	895b      	ldrh	r3, [r3, #10]
    3ab2:	3b01      	subs	r3, #1
			if (csect == 0) {					/* On the cluster boundary? */
    3ab4:	ea13 2352 	ands.w	r3, r3, r2, lsr #9
    3ab8:	d10e      	bne.n	3ad8 <f_read+0x78>
				if (fp->fptr == 0) {			/* On the top of the file? */
    3aba:	b90a      	cbnz	r2, 3ac0 <f_read+0x60>
					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
    3abc:	68a0      	ldr	r0, [r4, #8]
    3abe:	e005      	b.n	3acc <f_read+0x6c>
					if (fp->cltbl) {
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					} else
#endif
					{
						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
    3ac0:	6820      	ldr	r0, [r4, #0]
    3ac2:	69a1      	ldr	r1, [r4, #24]
    3ac4:	9301      	str	r3, [sp, #4]
    3ac6:	f7ff fb8d 	bl	31e4 <get_fat.clone.2>
    3aca:	9b01      	ldr	r3, [sp, #4]
					}
				}
				if (clst < 2) ABORT(fs, FR_INT_ERR);
    3acc:	2801      	cmp	r0, #1
    3ace:	d90c      	bls.n	3aea <f_read+0x8a>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
    3ad0:	f1b0 3fff 	cmp.w	r0, #4294967295
    3ad4:	d04e      	beq.n	3b74 <f_read+0x114>
				fp->clust = clst;				/* Update current cluster */
    3ad6:	61a0      	str	r0, [r4, #24]
			}
			sect = clst2sect(fs, fp->clust);	/* Get current sector */
    3ad8:	f8dd b00c 	ldr.w	fp, [sp, #12]
    3adc:	69a1      	ldr	r1, [r4, #24]
    3ade:	4658      	mov	r0, fp
    3ae0:	9301      	str	r3, [sp, #4]
    3ae2:	f7fe ffb0 	bl	2a46 <clst2sect>
			if (sect == 0) ABORT(fs, FR_INT_ERR);
    3ae6:	9b01      	ldr	r3, [sp, #4]
    3ae8:	b908      	cbnz	r0, 3aee <f_read+0x8e>
    3aea:	2502      	movs	r5, #2
    3aec:	e043      	b.n	3b76 <f_read+0x116>
			sect += csect;
			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
			if (cc > 0) {						/* Read maximum contiguous sectors directly */
    3aee:	ea5f 2759 	movs.w	r7, r9, lsr #9
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
				fp->clust = clst;				/* Update current cluster */
			}
			sect = clst2sect(fs, fp->clust);	/* Get current sector */
			if (sect == 0) ABORT(fs, FR_INT_ERR);
			sect += csect;
    3af2:	eb00 0603 	add.w	r6, r0, r3
			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
			if (cc > 0) {						/* Read maximum contiguous sectors directly */
    3af6:	d021      	beq.n	3b3c <f_read+0xdc>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
    3af8:	f8bb 200a 	ldrh.w	r2, [fp, #10]
    3afc:	18f9      	adds	r1, r7, r3
    3afe:	4291      	cmp	r1, r2
					cc = fs->csize - csect;
    3b00:	bf88      	it	hi
    3b02:	ebc3 0702 	rsbhi	r7, r3, r2
				}
				if (disk_read(fs->pdrv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
    3b06:	f89b 0001 	ldrb.w	r0, [fp, #1]
    3b0a:	4641      	mov	r1, r8
    3b0c:	4632      	mov	r2, r6
    3b0e:	463b      	mov	r3, r7
    3b10:	f7fe fd5e 	bl	25d0 <disk_read>
    3b14:	bb70      	cbnz	r0, 3b74 <f_read+0x114>
#if FF_FS_TINY
				if (fs->wflag && fs->winsect - sect < cc) {
					mem_cpy(rbuff + ((fs->winsect - sect) * SS(fs)), fs->win, SS(fs));
				}
#else
				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
    3b16:	f994 3010 	ldrsb.w	r3, [r4, #16]
    3b1a:	2b00      	cmp	r3, #0
    3b1c:	da0c      	bge.n	3b38 <f_read+0xd8>
    3b1e:	69e3      	ldr	r3, [r4, #28]
    3b20:	1b9e      	subs	r6, r3, r6
    3b22:	42be      	cmp	r6, r7
    3b24:	d208      	bcs.n	3b38 <f_read+0xd8>
					mem_cpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
    3b26:	0276      	lsls	r6, r6, #9
    3b28:	eb08 0006 	add.w	r0, r8, r6
    3b2c:	f104 0128 	add.w	r1, r4, #40	; 0x28
    3b30:	f44f 7200 	mov.w	r2, #512	; 0x200
    3b34:	f7fe ff44 	bl	29c0 <mem_cpy>
				}
#endif
#endif
				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
    3b38:	027f      	lsls	r7, r7, #9
				continue;
    3b3a:	e02e      	b.n	3b9a <f_read+0x13a>
			}
#if !FF_FS_TINY
			if (fp->sect != sect) {			/* Load data sector if not in cache */
    3b3c:	69e2      	ldr	r2, [r4, #28]
    3b3e:	42b2      	cmp	r2, r6
    3b40:	d01b      	beq.n	3b7a <f_read+0x11a>
#if !FF_FS_READONLY
				if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
    3b42:	f994 3010 	ldrsb.w	r3, [r4, #16]
    3b46:	2b00      	cmp	r3, #0
    3b48:	da0b      	bge.n	3b62 <f_read+0x102>
					if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
    3b4a:	f89b 0001 	ldrb.w	r0, [fp, #1]
    3b4e:	f104 0128 	add.w	r1, r4, #40	; 0x28
    3b52:	2301      	movs	r3, #1
    3b54:	f7fe fd76 	bl	2644 <disk_write>
    3b58:	b960      	cbnz	r0, 3b74 <f_read+0x114>
					fp->flag &= (BYTE)~FA_DIRTY;
    3b5a:	7c23      	ldrb	r3, [r4, #16]
    3b5c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    3b60:	7423      	strb	r3, [r4, #16]
				}
#endif
				if (disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
    3b62:	9b03      	ldr	r3, [sp, #12]
    3b64:	f104 0128 	add.w	r1, r4, #40	; 0x28
    3b68:	7858      	ldrb	r0, [r3, #1]
    3b6a:	4632      	mov	r2, r6
    3b6c:	2301      	movs	r3, #1
    3b6e:	f7fe fd2f 	bl	25d0 <disk_read>
    3b72:	b110      	cbz	r0, 3b7a <f_read+0x11a>
    3b74:	2501      	movs	r5, #1
    3b76:	7465      	strb	r5, [r4, #17]
    3b78:	e020      	b.n	3bbc <f_read+0x15c>
			}
#endif
			fp->sect = sect;
    3b7a:	61e6      	str	r6, [r4, #28]
		}
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
    3b7c:	6963      	ldr	r3, [r4, #20]
		if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
#if FF_FS_TINY
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
		mem_cpy(rbuff, fs->win + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
#else
		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
    3b7e:	f104 0128 	add.w	r1, r4, #40	; 0x28
				if (disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
			}
#endif
			fp->sect = sect;
		}
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
    3b82:	05db      	lsls	r3, r3, #23
    3b84:	0ddb      	lsrs	r3, r3, #23
    3b86:	f5c3 7700 	rsb	r7, r3, #512	; 0x200
    3b8a:	45b9      	cmp	r9, r7
    3b8c:	bf38      	it	cc
    3b8e:	464f      	movcc	r7, r9
		if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
#if FF_FS_TINY
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
		mem_cpy(rbuff, fs->win + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
#else
		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
    3b90:	4640      	mov	r0, r8
    3b92:	18c9      	adds	r1, r1, r3
    3b94:	463a      	mov	r2, r7
    3b96:	f7fe ff13 	bl	29c0 <mem_cpy>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
	remain = fp->obj.objsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until btr bytes read */
		btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {
    3b9a:	f8da 3000 	ldr.w	r3, [sl]
    3b9e:	ebc7 0909 	rsb	r9, r7, r9
    3ba2:	19db      	adds	r3, r3, r7
    3ba4:	f8ca 3000 	str.w	r3, [sl]
    3ba8:	6963      	ldr	r3, [r4, #20]
    3baa:	44b8      	add	r8, r7
    3bac:	19df      	adds	r7, r3, r7
    3bae:	6167      	str	r7, [r4, #20]
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
	remain = fp->obj.objsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until btr bytes read */
    3bb0:	f1b9 0f00 	cmp.w	r9, #0
    3bb4:	f47f af76 	bne.w	3aa4 <f_read+0x44>
    3bb8:	e000      	b.n	3bbc <f_read+0x15c>


	*br = 0;	/* Clear read byte counter */
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
    3bba:	2507      	movs	r5, #7
		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
#endif
	}

	LEAVE_FF(fs, FR_OK);
}
    3bbc:	4628      	mov	r0, r5
    3bbe:	b005      	add	sp, #20
    3bc0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00003bc4 <f_write>:
	FIL* fp,			/* Pointer to the file object */
	const void* buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
    3bc4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3bc8:	469a      	mov	sl, r3
    3bca:	b085      	sub	sp, #20
	DWORD clst, sect;
	UINT wcnt, cc, csect;
	const BYTE *wbuff = (const BYTE*)buff;


	*bw = 0;	/* Clear write byte counter */
    3bcc:	2300      	movs	r3, #0
	FIL* fp,			/* Pointer to the file object */
	const void* buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
    3bce:	4689      	mov	r9, r1
	DWORD clst, sect;
	UINT wcnt, cc, csect;
	const BYTE *wbuff = (const BYTE*)buff;


	*bw = 0;	/* Clear write byte counter */
    3bd0:	f8ca 3000 	str.w	r3, [sl]
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
    3bd4:	a903      	add	r1, sp, #12
	FIL* fp,			/* Pointer to the file object */
	const void* buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
    3bd6:	4604      	mov	r4, r0
    3bd8:	4616      	mov	r6, r2
	UINT wcnt, cc, csect;
	const BYTE *wbuff = (const BYTE*)buff;


	*bw = 0;	/* Clear write byte counter */
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
    3bda:	f7ff f893 	bl	2d04 <validate>
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
    3bde:	4605      	mov	r5, r0
    3be0:	2800      	cmp	r0, #0
    3be2:	f040 80b5 	bne.w	3d50 <f_write+0x18c>
    3be6:	7c65      	ldrb	r5, [r4, #17]
    3be8:	2d00      	cmp	r5, #0
    3bea:	f040 80b1 	bne.w	3d50 <f_write+0x18c>
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
    3bee:	7c23      	ldrb	r3, [r4, #16]
    3bf0:	f013 0f02 	tst.w	r3, #2
    3bf4:	f000 80ab 	beq.w	3d4e <f_write+0x18a>

	/* Check fptr wrap-around (file size cannot reach 4 GiB at FAT volume) */
	if ((!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
    3bf8:	6963      	ldr	r3, [r4, #20]
    3bfa:	42de      	cmn	r6, r3
    3bfc:	f0c0 809f 	bcc.w	3d3e <f_write+0x17a>
		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
    3c00:	43de      	mvns	r6, r3
    3c02:	e09c      	b.n	3d3e <f_write+0x17a>
	}

	for ( ;  btw;							/* Repeat until all data written */
		btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {
		if (fp->fptr % SS(fs) == 0) {		/* On the sector boundary? */
    3c04:	6963      	ldr	r3, [r4, #20]
    3c06:	05da      	lsls	r2, r3, #23
    3c08:	0dd2      	lsrs	r2, r2, #23
    3c0a:	2a00      	cmp	r2, #0
    3c0c:	d175      	bne.n	3cfa <f_write+0x136>
			csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
    3c0e:	9a03      	ldr	r2, [sp, #12]
    3c10:	8952      	ldrh	r2, [r2, #10]
    3c12:	3a01      	subs	r2, #1
			if (csect == 0) {				/* On the cluster boundary? */
    3c14:	ea12 2253 	ands.w	r2, r2, r3, lsr #9
    3c18:	9201      	str	r2, [sp, #4]
    3c1a:	d115      	bne.n	3c48 <f_write+0x84>
				if (fp->fptr == 0) {		/* On the top of the file? */
    3c1c:	b91b      	cbnz	r3, 3c26 <f_write+0x62>
					clst = fp->obj.sclust;	/* Follow from the origin */
    3c1e:	68a1      	ldr	r1, [r4, #8]
					if (clst == 0) {		/* If no cluster is allocated, */
    3c20:	b949      	cbnz	r1, 3c36 <f_write+0x72>
						clst = create_chain(&fp->obj, 0);	/* create a new cluster chain */
    3c22:	4620      	mov	r0, r4
    3c24:	e001      	b.n	3c2a <f_write+0x66>
					if (fp->cltbl) {
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					} else
#endif
					{
						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
    3c26:	69a1      	ldr	r1, [r4, #24]
    3c28:	4620      	mov	r0, r4
    3c2a:	f7ff fb83 	bl	3334 <create_chain.clone.3>
    3c2e:	4601      	mov	r1, r0
					}
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
    3c30:	2800      	cmp	r0, #0
    3c32:	f000 8087 	beq.w	3d44 <f_write+0x180>
				if (clst == 1) ABORT(fs, FR_INT_ERR);
    3c36:	2901      	cmp	r1, #1
    3c38:	d01f      	beq.n	3c7a <f_write+0xb6>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
    3c3a:	f1b1 3fff 	cmp.w	r1, #4294967295
    3c3e:	d057      	beq.n	3cf0 <f_write+0x12c>
				fp->clust = clst;			/* Update current cluster */
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
    3c40:	68a3      	ldr	r3, [r4, #8]
					}
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
				if (clst == 1) ABORT(fs, FR_INT_ERR);
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
				fp->clust = clst;			/* Update current cluster */
    3c42:	61a1      	str	r1, [r4, #24]
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
    3c44:	b903      	cbnz	r3, 3c48 <f_write+0x84>
    3c46:	60a1      	str	r1, [r4, #8]
			}
#if FF_FS_TINY
			if (fs->winsect == fp->sect && sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Write-back sector cache */
#else
			if (fp->flag & FA_DIRTY) {		/* Write-back sector cache */
    3c48:	f994 3010 	ldrsb.w	r3, [r4, #16]
    3c4c:	2b00      	cmp	r3, #0
    3c4e:	da0d      	bge.n	3c6c <f_write+0xa8>
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
    3c50:	9b03      	ldr	r3, [sp, #12]
    3c52:	f104 0128 	add.w	r1, r4, #40	; 0x28
    3c56:	7858      	ldrb	r0, [r3, #1]
    3c58:	69e2      	ldr	r2, [r4, #28]
    3c5a:	2301      	movs	r3, #1
    3c5c:	f7fe fcf2 	bl	2644 <disk_write>
    3c60:	2800      	cmp	r0, #0
    3c62:	d145      	bne.n	3cf0 <f_write+0x12c>
				fp->flag &= (BYTE)~FA_DIRTY;
    3c64:	7c23      	ldrb	r3, [r4, #16]
    3c66:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    3c6a:	7423      	strb	r3, [r4, #16]
			}
#endif
			sect = clst2sect(fs, fp->clust);	/* Get current sector */
    3c6c:	f8dd b00c 	ldr.w	fp, [sp, #12]
    3c70:	69a1      	ldr	r1, [r4, #24]
    3c72:	4658      	mov	r0, fp
    3c74:	f7fe fee7 	bl	2a46 <clst2sect>
			if (sect == 0) ABORT(fs, FR_INT_ERR);
    3c78:	b908      	cbnz	r0, 3c7e <f_write+0xba>
    3c7a:	2502      	movs	r5, #2
    3c7c:	e039      	b.n	3cf2 <f_write+0x12e>
			sect += csect;
    3c7e:	9901      	ldr	r1, [sp, #4]
			cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
			if (cc > 0) {					/* Write maximum contiguous sectors directly */
    3c80:	0a77      	lsrs	r7, r6, #9
				fp->flag &= (BYTE)~FA_DIRTY;
			}
#endif
			sect = clst2sect(fs, fp->clust);	/* Get current sector */
			if (sect == 0) ABORT(fs, FR_INT_ERR);
			sect += csect;
    3c82:	eb00 0801 	add.w	r8, r0, r1
			cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
			if (cc > 0) {					/* Write maximum contiguous sectors directly */
    3c86:	d023      	beq.n	3cd0 <f_write+0x10c>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
    3c88:	f8bb 300a 	ldrh.w	r3, [fp, #10]
    3c8c:	187a      	adds	r2, r7, r1
    3c8e:	429a      	cmp	r2, r3
					cc = fs->csize - csect;
    3c90:	bf88      	it	hi
    3c92:	ebc1 0703 	rsbhi	r7, r1, r3
				}
				if (disk_write(fs->pdrv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
    3c96:	f89b 0001 	ldrb.w	r0, [fp, #1]
    3c9a:	4649      	mov	r1, r9
    3c9c:	4642      	mov	r2, r8
    3c9e:	463b      	mov	r3, r7
    3ca0:	f7fe fcd0 	bl	2644 <disk_write>
    3ca4:	bb20      	cbnz	r0, 3cf0 <f_write+0x12c>
				if (fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fs->win, wbuff + ((fs->winsect - sect) * SS(fs)), SS(fs));
					fs->wflag = 0;
				}
#else
				if (fp->sect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
    3ca6:	69e3      	ldr	r3, [r4, #28]
    3ca8:	ebc8 0803 	rsb	r8, r8, r3
    3cac:	45b8      	cmp	r8, r7
    3cae:	d20d      	bcs.n	3ccc <f_write+0x108>
					mem_cpy(fp->buf, wbuff + ((fp->sect - sect) * SS(fs)), SS(fs));
    3cb0:	ea4f 2848 	mov.w	r8, r8, lsl #9
    3cb4:	f104 0028 	add.w	r0, r4, #40	; 0x28
    3cb8:	eb09 0108 	add.w	r1, r9, r8
    3cbc:	f44f 7200 	mov.w	r2, #512	; 0x200
    3cc0:	f7fe fe7e 	bl	29c0 <mem_cpy>
					fp->flag &= (BYTE)~FA_DIRTY;
    3cc4:	7c23      	ldrb	r3, [r4, #16]
    3cc6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    3cca:	7423      	strb	r3, [r4, #16]
				}
#endif
#endif
				wcnt = SS(fs) * cc;		/* Number of bytes transferred */
    3ccc:	027f      	lsls	r7, r7, #9
				continue;
    3cce:	e027      	b.n	3d20 <f_write+0x15c>
			if (fp->fptr >= fp->obj.objsize) {	/* Avoid silly cache filling on the growing edge */
				if (sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);
				fs->winsect = sect;
			}
#else
			if (fp->sect != sect && 		/* Fill sector cache with file data */
    3cd0:	69e3      	ldr	r3, [r4, #28]
    3cd2:	4543      	cmp	r3, r8
    3cd4:	d00f      	beq.n	3cf6 <f_write+0x132>
    3cd6:	6962      	ldr	r2, [r4, #20]
    3cd8:	68e3      	ldr	r3, [r4, #12]
    3cda:	429a      	cmp	r2, r3
    3cdc:	d20b      	bcs.n	3cf6 <f_write+0x132>
				fp->fptr < fp->obj.objsize &&
				disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK) {
    3cde:	f89b 0001 	ldrb.w	r0, [fp, #1]
    3ce2:	f104 0128 	add.w	r1, r4, #40	; 0x28
    3ce6:	4642      	mov	r2, r8
    3ce8:	2301      	movs	r3, #1
    3cea:	f7fe fc71 	bl	25d0 <disk_read>
				if (sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);
				fs->winsect = sect;
			}
#else
			if (fp->sect != sect && 		/* Fill sector cache with file data */
				fp->fptr < fp->obj.objsize &&
    3cee:	b110      	cbz	r0, 3cf6 <f_write+0x132>
				disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK) {
					ABORT(fs, FR_DISK_ERR);
    3cf0:	2501      	movs	r5, #1
    3cf2:	7465      	strb	r5, [r4, #17]
    3cf4:	e02c      	b.n	3d50 <f_write+0x18c>
			}
#endif
			fp->sect = sect;
    3cf6:	f8c4 801c 	str.w	r8, [r4, #28]
		}
		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
    3cfa:	6963      	ldr	r3, [r4, #20]
#if FF_FS_TINY
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
		mem_cpy(fs->win + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
		fs->wflag = 1;
#else
		mem_cpy(fp->buf + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
    3cfc:	f104 0028 	add.w	r0, r4, #40	; 0x28
					ABORT(fs, FR_DISK_ERR);
			}
#endif
			fp->sect = sect;
		}
		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
    3d00:	05db      	lsls	r3, r3, #23
    3d02:	0ddb      	lsrs	r3, r3, #23
    3d04:	f5c3 7700 	rsb	r7, r3, #512	; 0x200
    3d08:	42be      	cmp	r6, r7
    3d0a:	bf38      	it	cc
    3d0c:	4637      	movcc	r7, r6
#if FF_FS_TINY
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
		mem_cpy(fs->win + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
		fs->wflag = 1;
#else
		mem_cpy(fp->buf + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
    3d0e:	18c0      	adds	r0, r0, r3
    3d10:	4649      	mov	r1, r9
    3d12:	463a      	mov	r2, r7
    3d14:	f7fe fe54 	bl	29c0 <mem_cpy>
		fp->flag |= FA_DIRTY;
    3d18:	7c23      	ldrb	r3, [r4, #16]
    3d1a:	f063 037f 	orn	r3, r3, #127	; 0x7f
    3d1e:	7423      	strb	r3, [r4, #16]
	if ((!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
	}

	for ( ;  btw;							/* Repeat until all data written */
		btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {
    3d20:	f8da 3000 	ldr.w	r3, [sl]
    3d24:	1bf6      	subs	r6, r6, r7
    3d26:	19db      	adds	r3, r3, r7
    3d28:	f8ca 3000 	str.w	r3, [sl]
    3d2c:	6963      	ldr	r3, [r4, #20]
    3d2e:	44b9      	add	r9, r7
    3d30:	18ff      	adds	r7, r7, r3
    3d32:	68e3      	ldr	r3, [r4, #12]
    3d34:	6167      	str	r7, [r4, #20]
    3d36:	42bb      	cmp	r3, r7
    3d38:	bf2c      	ite	cs
    3d3a:	60e3      	strcs	r3, [r4, #12]
    3d3c:	60e7      	strcc	r7, [r4, #12]
	/* Check fptr wrap-around (file size cannot reach 4 GiB at FAT volume) */
	if ((!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
	}

	for ( ;  btw;							/* Repeat until all data written */
    3d3e:	2e00      	cmp	r6, #0
    3d40:	f47f af60 	bne.w	3c04 <f_write+0x40>
		mem_cpy(fp->buf + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
		fp->flag |= FA_DIRTY;
#endif
	}

	fp->flag |= FA_MODIFIED;				/* Set file change flag */
    3d44:	7c23      	ldrb	r3, [r4, #16]
    3d46:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    3d4a:	7423      	strb	r3, [r4, #16]

	LEAVE_FF(fs, FR_OK);
    3d4c:	e000      	b.n	3d50 <f_write+0x18c>


	*bw = 0;	/* Clear write byte counter */
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
    3d4e:	2507      	movs	r5, #7
	}

	fp->flag |= FA_MODIFIED;				/* Set file change flag */

	LEAVE_FF(fs, FR_OK);
}
    3d50:	4628      	mov	r0, r5
    3d52:	b005      	add	sp, #20
    3d54:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00003d58 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
    3d58:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	FATFS *fs;
	DWORD tm;
	BYTE *dir;


	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
    3d5a:	a901      	add	r1, sp, #4
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
    3d5c:	4604      	mov	r4, r0
	FATFS *fs;
	DWORD tm;
	BYTE *dir;


	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
    3d5e:	f7fe ffd1 	bl	2d04 <validate>
	if (res == FR_OK) {
    3d62:	4605      	mov	r5, r0
    3d64:	2800      	cmp	r0, #0
    3d66:	d142      	bne.n	3dee <f_sync+0x96>
		if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
    3d68:	7c23      	ldrb	r3, [r4, #16]
    3d6a:	f013 0f40 	tst.w	r3, #64	; 0x40
    3d6e:	d03e      	beq.n	3dee <f_sync+0x96>
#if !FF_FS_TINY
			if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
    3d70:	f013 0f80 	tst.w	r3, #128	; 0x80
    3d74:	d00d      	beq.n	3d92 <f_sync+0x3a>
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
    3d76:	9b01      	ldr	r3, [sp, #4]
    3d78:	f104 0128 	add.w	r1, r4, #40	; 0x28
    3d7c:	7858      	ldrb	r0, [r3, #1]
    3d7e:	69e2      	ldr	r2, [r4, #28]
    3d80:	2301      	movs	r3, #1
    3d82:	f7fe fc5f 	bl	2644 <disk_write>
    3d86:	2800      	cmp	r0, #0
    3d88:	d130      	bne.n	3dec <f_sync+0x94>
				fp->flag &= (BYTE)~FA_DIRTY;
    3d8a:	7c23      	ldrb	r3, [r4, #16]
    3d8c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    3d90:	7423      	strb	r3, [r4, #16]
			}
#endif
			/* Update the directory entry */
			tm = GET_FATTIME();				/* Modified time */
    3d92:	f7fc fb25 	bl	3e0 <get_fattime>
					FREE_NAMBUF();
				}
			} else
#endif
			{
				res = move_window(fs, fp->dir_sect);
    3d96:	6a21      	ldr	r1, [r4, #32]
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
				fp->flag &= (BYTE)~FA_DIRTY;
			}
#endif
			/* Update the directory entry */
			tm = GET_FATTIME();				/* Modified time */
    3d98:	4607      	mov	r7, r0
					FREE_NAMBUF();
				}
			} else
#endif
			{
				res = move_window(fs, fp->dir_sect);
    3d9a:	9801      	ldr	r0, [sp, #4]
    3d9c:	f7fe ffca 	bl	2d34 <move_window>
				if (res == FR_OK) {
    3da0:	4605      	mov	r5, r0
    3da2:	bb20      	cbnz	r0, 3dee <f_sync+0x96>
					dir = fp->dir_ptr;
    3da4:	6a66      	ldr	r6, [r4, #36]	; 0x24
					dir[DIR_Attr] |= AM_ARC;						/* Set archive attribute to indicate that the file has been changed */
    3da6:	7af3      	ldrb	r3, [r6, #11]
					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation information  */
    3da8:	4631      	mov	r1, r6
#endif
			{
				res = move_window(fs, fp->dir_sect);
				if (res == FR_OK) {
					dir = fp->dir_ptr;
					dir[DIR_Attr] |= AM_ARC;						/* Set archive attribute to indicate that the file has been changed */
    3daa:	f043 0320 	orr.w	r3, r3, #32
    3dae:	72f3      	strb	r3, [r6, #11]
					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation information  */
    3db0:	68a2      	ldr	r2, [r4, #8]
    3db2:	6820      	ldr	r0, [r4, #0]
    3db4:	f7ff fa02 	bl	31bc <st_clust.clone.1>
					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
    3db8:	f106 001c 	add.w	r0, r6, #28
    3dbc:	68e1      	ldr	r1, [r4, #12]
    3dbe:	f7fe fdf5 	bl	29ac <st_dword>
					st_dword(dir + DIR_ModTime, tm);				/* Update modified time */
    3dc2:	f106 0016 	add.w	r0, r6, #22
    3dc6:	4639      	mov	r1, r7
    3dc8:	f7fe fdf0 	bl	29ac <st_dword>
					st_word(dir + DIR_LstAccDate, 0);
    3dcc:	4629      	mov	r1, r5
    3dce:	f106 0012 	add.w	r0, r6, #18
    3dd2:	f7fe fde7 	bl	29a4 <st_word>
					fs->wflag = 1;
    3dd6:	9801      	ldr	r0, [sp, #4]
    3dd8:	2301      	movs	r3, #1
    3dda:	70c3      	strb	r3, [r0, #3]
					res = sync_fs(fs);					/* Restore it to the directory */
    3ddc:	f7fe ff4d 	bl	2c7a <sync_fs>
					fp->flag &= (BYTE)~FA_MODIFIED;
    3de0:	7c23      	ldrb	r3, [r4, #16]
					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation information  */
					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
					st_dword(dir + DIR_ModTime, tm);				/* Update modified time */
					st_word(dir + DIR_LstAccDate, 0);
					fs->wflag = 1;
					res = sync_fs(fs);					/* Restore it to the directory */
    3de2:	4605      	mov	r5, r0
					fp->flag &= (BYTE)~FA_MODIFIED;
    3de4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    3de8:	7423      	strb	r3, [r4, #16]
    3dea:	e000      	b.n	3dee <f_sync+0x96>
	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
	if (res == FR_OK) {
		if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
#if !FF_FS_TINY
			if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
    3dec:	2501      	movs	r5, #1
			}
		}
	}

	LEAVE_FF(fs, res);
}
    3dee:	4628      	mov	r0, r5
    3df0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

00003df2 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL* fp		/* Pointer to the file object to be closed */
)
{
    3df2:	b513      	push	{r0, r1, r4, lr}
    3df4:	4604      	mov	r4, r0
	FRESULT res;
	FATFS *fs;

#if !FF_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
    3df6:	f7ff ffaf 	bl	3d58 <f_sync>
	if (res == FR_OK)
    3dfa:	b928      	cbnz	r0, 3e08 <f_close+0x16>
#endif
	{
		res = validate(&fp->obj, &fs);	/* Lock volume */
    3dfc:	4620      	mov	r0, r4
    3dfe:	a901      	add	r1, sp, #4
    3e00:	f7fe ff80 	bl	2d04 <validate>
		if (res == FR_OK) {
    3e04:	b900      	cbnz	r0, 3e08 <f_close+0x16>
#if FF_FS_LOCK != 0
			res = dec_lock(fp->obj.lockid);		/* Decrement file open counter */
			if (res == FR_OK) fp->obj.fs = 0;	/* Invalidate file object */
#else
			fp->obj.fs = 0;	/* Invalidate file object */
    3e06:	6020      	str	r0, [r4, #0]
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
    3e08:	bd1c      	pop	{r2, r3, r4, pc}

00003e0a <f_chdrive>:
/*-----------------------------------------------------------------------*/

FRESULT f_chdrive (
	const TCHAR* path		/* Drive number to set */
)
{
    3e0a:	b507      	push	{r0, r1, r2, lr}
    3e0c:	ab02      	add	r3, sp, #8
    3e0e:	f843 0d04 	str.w	r0, [r3, #-4]!
	int vol;


	/* Get logical drive number */
	vol = get_ldnumber(&path);
    3e12:	4618      	mov	r0, r3
    3e14:	f7fe fec1 	bl	2b9a <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
    3e18:	2800      	cmp	r0, #0
    3e1a:	db03      	blt.n	3e24 <f_chdrive+0x1a>
	CurrVol = (BYTE)vol;	/* Set it as current volume */
    3e1c:	4b02      	ldr	r3, [pc, #8]	; (3e28 <f_chdrive+0x1e>)
    3e1e:	7018      	strb	r0, [r3, #0]

	return FR_OK;
    3e20:	2000      	movs	r0, #0
    3e22:	e000      	b.n	3e26 <f_chdrive+0x1c>
	int vol;


	/* Get logical drive number */
	vol = get_ldnumber(&path);
	if (vol < 0) return FR_INVALID_DRIVE;
    3e24:	200b      	movs	r0, #11
	CurrVol = (BYTE)vol;	/* Set it as current volume */

	return FR_OK;
}
    3e26:	bd0e      	pop	{r1, r2, r3, pc}
    3e28:	1000012c 	.word	0x1000012c

00003e2c <f_chdir>:


FRESULT f_chdir (
	const TCHAR* path	/* Pointer to the directory path */
)
{
    3e2c:	b530      	push	{r4, r5, lr}
    3e2e:	b091      	sub	sp, #68	; 0x44
    3e30:	ab10      	add	r3, sp, #64	; 0x40
    3e32:	f843 0d3c 	str.w	r0, [r3, #-60]!
	FATFS *fs;
	DEF_NAMBUF


	/* Get logical drive */
	res = find_volume(&path, &fs, 0);
    3e36:	4618      	mov	r0, r3
    3e38:	a90f      	add	r1, sp, #60	; 0x3c
    3e3a:	2200      	movs	r2, #0
    3e3c:	f7fe ffcc 	bl	2dd8 <find_volume>
	if (res == FR_OK) {
    3e40:	4604      	mov	r4, r0
    3e42:	b9f8      	cbnz	r0, 3e84 <f_chdir+0x58>
		dj.obj.fs = fs;
    3e44:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    3e46:	a810      	add	r0, sp, #64	; 0x40
    3e48:	f840 3d34 	str.w	r3, [r0, #-52]!
		INIT_NAMBUF(fs);
		res = follow_path(&dj, path);		/* Follow the path */
    3e4c:	9901      	ldr	r1, [sp, #4]
    3e4e:	f7ff fb82 	bl	3556 <follow_path>
		if (res == FR_OK) {					/* Follow completed */
    3e52:	4604      	mov	r4, r0
    3e54:	b998      	cbnz	r0, 3e7e <f_chdir+0x52>
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Is it the start directory itself? */
    3e56:	f99d 3037 	ldrsb.w	r3, [sp, #55]	; 0x37
    3e5a:	2b00      	cmp	r3, #0
    3e5c:	da03      	bge.n	3e66 <f_chdir+0x3a>
				fs->cdir = dj.obj.sclust;
    3e5e:	9a05      	ldr	r2, [sp, #20]
    3e60:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    3e62:	615a      	str	r2, [r3, #20]
    3e64:	e00e      	b.n	3e84 <f_chdir+0x58>
					fs->cdc_size = dj.obj.c_size;
					fs->cdc_ofs = dj.obj.c_ofs;
				}
#endif
			} else {
				if (dj.obj.attr & AM_DIR) {	/* It is a sub-directory */
    3e66:	f89d 3012 	ldrb.w	r3, [sp, #18]
    3e6a:	f013 0f10 	tst.w	r3, #16
    3e6e:	d00c      	beq.n	3e8a <f_chdir+0x5e>
						fs->cdc_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
						fs->cdc_ofs = dj.blk_ofs;
					} else
#endif
					{
						fs->cdir = ld_clust(fs, dj.dir);					/* Sub-directory cluster */
    3e70:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
    3e72:	990a      	ldr	r1, [sp, #40]	; 0x28
    3e74:	7828      	ldrb	r0, [r5, #0]
    3e76:	f7ff f98f 	bl	3198 <ld_clust.clone.0>
    3e7a:	6168      	str	r0, [r5, #20]
    3e7c:	e002      	b.n	3e84 <f_chdir+0x58>
					res = FR_NO_PATH;		/* Reached but a file */
				}
			}
		}
		FREE_NAMBUF();
		if (res == FR_NO_FILE) res = FR_NO_PATH;
    3e7e:	2804      	cmp	r0, #4
    3e80:	bf08      	it	eq
    3e82:	2405      	moveq	r4, #5
		}
#endif
	}

	LEAVE_FF(fs, res);
}
    3e84:	4620      	mov	r0, r4
    3e86:	b011      	add	sp, #68	; 0x44
    3e88:	bd30      	pop	{r4, r5, pc}
#endif
					{
						fs->cdir = ld_clust(fs, dj.dir);					/* Sub-directory cluster */
					}
				} else {
					res = FR_NO_PATH;		/* Reached but a file */
    3e8a:	2405      	movs	r4, #5
    3e8c:	e7fa      	b.n	3e84 <f_chdir+0x58>

00003e8e <f_getcwd>:
#if FF_FS_RPATH >= 2
FRESULT f_getcwd (
	TCHAR* buff,	/* Pointer to the directory path */
	UINT len		/* Size of buff in unit of TCHAR */
)
{
    3e8e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    3e92:	b097      	sub	sp, #92	; 0x5c
    3e94:	ab16      	add	r3, sp, #88	; 0x58
    3e96:	f843 0d54 	str.w	r0, [r3, #-84]!
	FILINFO fno;
	DEF_NAMBUF


	/* Get logical drive */
	buff[0] = 0;	/* Set null string to get current volume */
    3e9a:	2200      	movs	r2, #0
    3e9c:	7002      	strb	r2, [r0, #0]
#if FF_FS_RPATH >= 2
FRESULT f_getcwd (
	TCHAR* buff,	/* Pointer to the directory path */
	UINT len		/* Size of buff in unit of TCHAR */
)
{
    3e9e:	460d      	mov	r5, r1
	FRESULT res;
	DIR dj;
	FATFS *fs;
	UINT i, n;
	DWORD ccl;
	TCHAR *tp = buff;
    3ea0:	4604      	mov	r4, r0
	DEF_NAMBUF


	/* Get logical drive */
	buff[0] = 0;	/* Set null string to get current volume */
	res = find_volume((const TCHAR**)&buff, &fs, 0);	/* Get current volume */
    3ea2:	a915      	add	r1, sp, #84	; 0x54
    3ea4:	4618      	mov	r0, r3
    3ea6:	f7fe ff97 	bl	2dd8 <find_volume>
	if (res == FR_OK) {
    3eaa:	4680      	mov	r8, r0
    3eac:	2800      	cmp	r0, #0
    3eae:	d16d      	bne.n	3f8c <f_getcwd+0xfe>
		dj.obj.fs = fs;
    3eb0:	9b15      	ldr	r3, [sp, #84]	; 0x54

		/* Follow parent directories and create the path */
		i = len;			/* Bottom of buffer (directory stack base) */
		if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {	/* (Cannot do getcwd on exFAT and returns root path) */
			dj.obj.sclust = fs->cdir;				/* Start to follow upper directory from current directory */
			while ((ccl = dj.obj.sclust) != 0) {	/* Repeat while current directory is a sub-directory */
    3eb2:	462f      	mov	r7, r5

	/* Get logical drive */
	buff[0] = 0;	/* Set null string to get current volume */
	res = find_volume((const TCHAR**)&buff, &fs, 0);	/* Get current volume */
	if (res == FR_OK) {
		dj.obj.fs = fs;
    3eb4:	9303      	str	r3, [sp, #12]
		INIT_NAMBUF(fs);

		/* Follow parent directories and create the path */
		i = len;			/* Bottom of buffer (directory stack base) */
		if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {	/* (Cannot do getcwd on exFAT and returns root path) */
			dj.obj.sclust = fs->cdir;				/* Start to follow upper directory from current directory */
    3eb6:	695b      	ldr	r3, [r3, #20]
    3eb8:	9305      	str	r3, [sp, #20]
			while ((ccl = dj.obj.sclust) != 0) {	/* Repeat while current directory is a sub-directory */
    3eba:	e053      	b.n	3f64 <f_getcwd+0xd6>
				res = dir_sdi(&dj, 1 * SZDIRE);	/* Get parent directory */
    3ebc:	a803      	add	r0, sp, #12
    3ebe:	2120      	movs	r1, #32
    3ec0:	f7ff f9eb 	bl	329a <dir_sdi>
				if (res != FR_OK) break;
    3ec4:	4606      	mov	r6, r0
    3ec6:	2800      	cmp	r0, #0
    3ec8:	d167      	bne.n	3f9a <f_getcwd+0x10c>
				res = move_window(fs, dj.sect);
    3eca:	9815      	ldr	r0, [sp, #84]	; 0x54
    3ecc:	9909      	ldr	r1, [sp, #36]	; 0x24
    3ece:	f7fe ff31 	bl	2d34 <move_window>
				if (res != FR_OK) break;
    3ed2:	4606      	mov	r6, r0
    3ed4:	2800      	cmp	r0, #0
    3ed6:	d160      	bne.n	3f9a <f_getcwd+0x10c>
				dj.obj.sclust = ld_clust(fs, dj.dir);	/* Goto parent directory */
    3ed8:	9b15      	ldr	r3, [sp, #84]	; 0x54
    3eda:	990a      	ldr	r1, [sp, #40]	; 0x28
    3edc:	7818      	ldrb	r0, [r3, #0]
    3ede:	f7ff f95b 	bl	3198 <ld_clust.clone.0>
				res = dir_sdi(&dj, 0);
    3ee2:	4631      	mov	r1, r6
			while ((ccl = dj.obj.sclust) != 0) {	/* Repeat while current directory is a sub-directory */
				res = dir_sdi(&dj, 1 * SZDIRE);	/* Get parent directory */
				if (res != FR_OK) break;
				res = move_window(fs, dj.sect);
				if (res != FR_OK) break;
				dj.obj.sclust = ld_clust(fs, dj.dir);	/* Goto parent directory */
    3ee4:	9005      	str	r0, [sp, #20]
				res = dir_sdi(&dj, 0);
    3ee6:	a803      	add	r0, sp, #12
    3ee8:	f7ff f9d7 	bl	329a <dir_sdi>
				if (res != FR_OK) break;
    3eec:	4606      	mov	r6, r0
    3eee:	2800      	cmp	r0, #0
    3ef0:	d153      	bne.n	3f9a <f_getcwd+0x10c>
				do {							/* Find the entry links to the child directory */
					res = DIR_READ_FILE(&dj);
    3ef2:	a803      	add	r0, sp, #12
    3ef4:	2100      	movs	r1, #0
    3ef6:	f7ff fafc 	bl	34f2 <dir_read>
					if (res != FR_OK) break;
    3efa:	4606      	mov	r6, r0
    3efc:	b968      	cbnz	r0, 3f1a <f_getcwd+0x8c>
					if (ccl == ld_clust(fs, dj.dir)) break;	/* Found the entry */
    3efe:	9b15      	ldr	r3, [sp, #84]	; 0x54
    3f00:	990a      	ldr	r1, [sp, #40]	; 0x28
    3f02:	7818      	ldrb	r0, [r3, #0]
    3f04:	f7ff f948 	bl	3198 <ld_clust.clone.0>
    3f08:	4581      	cmp	r9, r0
    3f0a:	d00a      	beq.n	3f22 <f_getcwd+0x94>
					res = dir_next(&dj, 0);
    3f0c:	4631      	mov	r1, r6
    3f0e:	a803      	add	r0, sp, #12
    3f10:	f7ff fa8c 	bl	342c <dir_next>
				} while (res == FR_OK);
    3f14:	4606      	mov	r6, r0
    3f16:	2800      	cmp	r0, #0
    3f18:	d0eb      	beq.n	3ef2 <f_getcwd+0x64>
				if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
    3f1a:	2e04      	cmp	r6, #4
    3f1c:	bf08      	it	eq
    3f1e:	2602      	moveq	r6, #2
    3f20:	e03b      	b.n	3f9a <f_getcwd+0x10c>
				if (res != FR_OK) break;
				get_fileinfo(&dj, &fno);		/* Get the directory name and push it to the buffer */
    3f22:	a803      	add	r0, sp, #12
    3f24:	a90f      	add	r1, sp, #60	; 0x3c
    3f26:	f7fe fd9a 	bl	2a5e <get_fileinfo>
    3f2a:	aa11      	add	r2, sp, #68	; 0x44
				for (n = 0; fno.fname[n]; n++) ;	/* Name length */
    3f2c:	e000      	b.n	3f30 <f_getcwd+0xa2>
    3f2e:	461e      	mov	r6, r3
    3f30:	f812 1f01 	ldrb.w	r1, [r2, #1]!
    3f34:	1c73      	adds	r3, r6, #1
    3f36:	2900      	cmp	r1, #0
    3f38:	d1f9      	bne.n	3f2e <f_getcwd+0xa0>
				if (i < n + 1) {	/* Insufficient space to store the path name? */
    3f3a:	429f      	cmp	r7, r3
					res = dir_next(&dj, 0);
				} while (res == FR_OK);
				if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
				if (res != FR_OK) break;
				get_fileinfo(&dj, &fno);		/* Get the directory name and push it to the buffer */
				for (n = 0; fno.fname[n]; n++) ;	/* Name length */
    3f3c:	4631      	mov	r1, r6
				if (i < n + 1) {	/* Insufficient space to store the path name? */
    3f3e:	d32b      	bcc.n	3f98 <f_getcwd+0x10a>
    3f40:	463b      	mov	r3, r7
    3f42:	e008      	b.n	3f56 <f_getcwd+0xc8>
					res = FR_NOT_ENOUGH_CORE; break;
				}
				while (n) buff[--i] = fno.fname[--n];	/* Stack the name */
    3f44:	3e01      	subs	r6, #1
	LEAVE_FF(fs, res);
}


#if FF_FS_RPATH >= 2
FRESULT f_getcwd (
    3f46:	f10d 0c58 	add.w	ip, sp, #88	; 0x58
    3f4a:	eb0c 0006 	add.w	r0, ip, r6
				get_fileinfo(&dj, &fno);		/* Get the directory name and push it to the buffer */
				for (n = 0; fno.fname[n]; n++) ;	/* Name length */
				if (i < n + 1) {	/* Insufficient space to store the path name? */
					res = FR_NOT_ENOUGH_CORE; break;
				}
				while (n) buff[--i] = fno.fname[--n];	/* Stack the name */
    3f4e:	f810 0c13 	ldrb.w	r0, [r0, #-19]
    3f52:	3b01      	subs	r3, #1
    3f54:	54d0      	strb	r0, [r2, r3]
    3f56:	9a01      	ldr	r2, [sp, #4]
    3f58:	2e00      	cmp	r6, #0
    3f5a:	d1f3      	bne.n	3f44 <f_getcwd+0xb6>
    3f5c:	43cb      	mvns	r3, r1
				buff[--i] = '/';
    3f5e:	18ff      	adds	r7, r7, r3
    3f60:	232f      	movs	r3, #47	; 0x2f
    3f62:	55d3      	strb	r3, [r2, r7]

		/* Follow parent directories and create the path */
		i = len;			/* Bottom of buffer (directory stack base) */
		if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {	/* (Cannot do getcwd on exFAT and returns root path) */
			dj.obj.sclust = fs->cdir;				/* Start to follow upper directory from current directory */
			while ((ccl = dj.obj.sclust) != 0) {	/* Repeat while current directory is a sub-directory */
    3f64:	f8dd 9014 	ldr.w	r9, [sp, #20]
    3f68:	f1b9 0f00 	cmp.w	r9, #0
    3f6c:	d1a6      	bne.n	3ebc <f_getcwd+0x2e>
				while (n) buff[--i] = fno.fname[--n];	/* Stack the name */
				buff[--i] = '/';
			}
		}
		if (res == FR_OK) {
			if (i == len) buff[--i] = '/';	/* Is it the root-directory? */
    3f6e:	42af      	cmp	r7, r5
    3f70:	d103      	bne.n	3f7a <f_getcwd+0xec>
    3f72:	9b01      	ldr	r3, [sp, #4]
    3f74:	3f01      	subs	r7, #1
    3f76:	222f      	movs	r2, #47	; 0x2f
    3f78:	55da      	strb	r2, [r3, r7]
    3f7a:	4623      	mov	r3, r4
#endif
			if (vl == 0) res = FR_NOT_ENOUGH_CORE;
#endif
			/* Add current directory path */
			if (res == FR_OK) {
				do *tp++ = buff[i++]; while (i < len);	/* Copy stacked path string */
    3f7c:	9a01      	ldr	r2, [sp, #4]
    3f7e:	5dd2      	ldrb	r2, [r2, r7]
    3f80:	3701      	adds	r7, #1
    3f82:	f803 2b01 	strb.w	r2, [r3], #1
    3f86:	42af      	cmp	r7, r5
    3f88:	461c      	mov	r4, r3
    3f8a:	d3f7      	bcc.n	3f7c <f_getcwd+0xee>
			}
		}
		FREE_NAMBUF();
	}

	*tp = 0;
    3f8c:	2300      	movs	r3, #0
    3f8e:	7023      	strb	r3, [r4, #0]
	LEAVE_FF(fs, res);
}
    3f90:	4640      	mov	r0, r8
    3f92:	b017      	add	sp, #92	; 0x5c
    3f94:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
				if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
				if (res != FR_OK) break;
				get_fileinfo(&dj, &fno);		/* Get the directory name and push it to the buffer */
				for (n = 0; fno.fname[n]; n++) ;	/* Name length */
				if (i < n + 1) {	/* Insufficient space to store the path name? */
					res = FR_NOT_ENOUGH_CORE; break;
    3f98:	2611      	movs	r6, #17

		/* Follow parent directories and create the path */
		i = len;			/* Bottom of buffer (directory stack base) */
		if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {	/* (Cannot do getcwd on exFAT and returns root path) */
			dj.obj.sclust = fs->cdir;				/* Start to follow upper directory from current directory */
			while ((ccl = dj.obj.sclust) != 0) {	/* Repeat while current directory is a sub-directory */
    3f9a:	46b0      	mov	r8, r6
    3f9c:	e7f6      	b.n	3f8c <f_getcwd+0xfe>

00003f9e <f_lseek>:

FRESULT f_lseek (
	FIL* fp,		/* Pointer to the file object */
	FSIZE_t ofs		/* File pointer from top of file */
)
{
    3f9e:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    3fa2:	460f      	mov	r7, r1
	FSIZE_t ifptr;
#if FF_USE_FASTSEEK
	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
#endif

	res = validate(&fp->obj, &fs);		/* Check validity of the file object */
    3fa4:	a901      	add	r1, sp, #4

FRESULT f_lseek (
	FIL* fp,		/* Pointer to the file object */
	FSIZE_t ofs		/* File pointer from top of file */
)
{
    3fa6:	4604      	mov	r4, r0
	FSIZE_t ifptr;
#if FF_USE_FASTSEEK
	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
#endif

	res = validate(&fp->obj, &fs);		/* Check validity of the file object */
    3fa8:	f7fe feac 	bl	2d04 <validate>
	if (res == FR_OK) res = (FRESULT)fp->err;
    3fac:	4605      	mov	r5, r0
    3fae:	2800      	cmp	r0, #0
    3fb0:	f040 8099 	bne.w	40e6 <f_lseek+0x148>
    3fb4:	7c65      	ldrb	r5, [r4, #17]
#if FF_FS_EXFAT && !FF_FS_READONLY
	if (res == FR_OK && fs->fs_type == FS_EXFAT) {
		res = fill_last_frag(&fp->obj, fp->clust, 0xFFFFFFFF);	/* Fill last fragment on the FAT if needed */
	}
#endif
	if (res != FR_OK) LEAVE_FF(fs, res);
    3fb6:	2d00      	cmp	r5, #0
    3fb8:	f040 8095 	bne.w	40e6 <f_lseek+0x148>
	/* Normal Seek */
	{
#if FF_FS_EXFAT
		if (fs->fs_type != FS_EXFAT && ofs >= 0x100000000) ofs = 0xFFFFFFFF;	/* Clip at 4 GiB - 1 if at FATxx */
#endif
		if (ofs > fp->obj.objsize && (FF_FS_READONLY || !(fp->flag & FA_WRITE))) {	/* In read-only mode, clip offset with the file size */
    3fbc:	68e3      	ldr	r3, [r4, #12]
    3fbe:	429f      	cmp	r7, r3
    3fc0:	d905      	bls.n	3fce <f_lseek+0x30>
    3fc2:	7c22      	ldrb	r2, [r4, #16]
    3fc4:	f002 0202 	and.w	r2, r2, #2
    3fc8:	2a00      	cmp	r2, #0
    3fca:	bf08      	it	eq
    3fcc:	461f      	moveq	r7, r3
			ofs = fp->obj.objsize;
		}
		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
    3fce:	2200      	movs	r2, #0
		if (fs->fs_type != FS_EXFAT && ofs >= 0x100000000) ofs = 0xFFFFFFFF;	/* Clip at 4 GiB - 1 if at FATxx */
#endif
		if (ofs > fp->obj.objsize && (FF_FS_READONLY || !(fp->flag & FA_WRITE))) {	/* In read-only mode, clip offset with the file size */
			ofs = fp->obj.objsize;
		}
		ifptr = fp->fptr;
    3fd0:	6963      	ldr	r3, [r4, #20]
		fp->fptr = nsect = 0;
    3fd2:	6162      	str	r2, [r4, #20]
		if (ofs > 0) {
    3fd4:	2f00      	cmp	r7, #0
    3fd6:	d058      	beq.n	408a <f_lseek+0xec>
			bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size (byte) */
    3fd8:	9a01      	ldr	r2, [sp, #4]
    3fda:	f8b2 800a 	ldrh.w	r8, [r2, #10]
    3fde:	ea4f 2848 	mov.w	r8, r8, lsl #9
			if (ifptr > 0 &&
    3fe2:	b17b      	cbz	r3, 4004 <f_lseek+0x66>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
    3fe4:	3b01      	subs	r3, #1
    3fe6:	1e79      	subs	r1, r7, #1
    3fe8:	fbb1 f1f8 	udiv	r1, r1, r8
    3fec:	fbb3 f2f8 	udiv	r2, r3, r8
		}
		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs > 0) {
			bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
    3ff0:	4291      	cmp	r1, r2
    3ff2:	d307      	bcc.n	4004 <f_lseek+0x66>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);	/* start from the current cluster */
    3ff4:	f1c8 0200 	rsb	r2, r8, #0
    3ff8:	ea02 0303 	and.w	r3, r2, r3
    3ffc:	6163      	str	r3, [r4, #20]
				ofs -= fp->fptr;
    3ffe:	1aff      	subs	r7, r7, r3
				clst = fp->clust;
    4000:	69a1      	ldr	r1, [r4, #24]
    4002:	e00f      	b.n	4024 <f_lseek+0x86>
			} else {									/* When seek to back cluster, */
				clst = fp->obj.sclust;					/* start from the first cluster */
    4004:	68a1      	ldr	r1, [r4, #8]
#if !FF_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
    4006:	b961      	cbnz	r1, 4022 <f_lseek+0x84>
					clst = create_chain(&fp->obj, 0);
    4008:	4620      	mov	r0, r4
    400a:	f7ff f993 	bl	3334 <create_chain.clone.3>
					if (clst == 1) ABORT(fs, FR_INT_ERR);
    400e:	2801      	cmp	r0, #1
				clst = fp->clust;
			} else {									/* When seek to back cluster, */
				clst = fp->obj.sclust;					/* start from the first cluster */
#if !FF_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
					clst = create_chain(&fp->obj, 0);
    4010:	4601      	mov	r1, r0
					if (clst == 1) ABORT(fs, FR_INT_ERR);
    4012:	d035      	beq.n	4080 <f_lseek+0xe2>
					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
    4014:	f1b0 3fff 	cmp.w	r0, #4294967295
    4018:	d102      	bne.n	4020 <f_lseek+0x82>
    401a:	2501      	movs	r5, #1
    401c:	7465      	strb	r5, [r4, #17]
    401e:	e062      	b.n	40e6 <f_lseek+0x148>
					fp->obj.sclust = clst;
    4020:	60a0      	str	r0, [r4, #8]
				}
#endif
				fp->clust = clst;
    4022:	61a1      	str	r1, [r4, #24]
			}
			if (clst != 0) {
    4024:	2900      	cmp	r1, #0
    4026:	d032      	beq.n	408e <f_lseek+0xf0>
    4028:	e01c      	b.n	4064 <f_lseek+0xc6>
				while (ofs > bcs) {						/* Cluster following loop */
					ofs -= bcs; fp->fptr += bcs;
    402a:	6963      	ldr	r3, [r4, #20]
    402c:	4443      	add	r3, r8
    402e:	6163      	str	r3, [r4, #20]
#if !FF_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
    4030:	7c23      	ldrb	r3, [r4, #16]
    4032:	f013 0f02 	tst.w	r3, #2
    4036:	d005      	beq.n	4044 <f_lseek+0xa6>
						if (FF_FS_EXFAT && fp->fptr > fp->obj.objsize) {	/* No FAT chain object needs correct objsize to generate FAT value */
							fp->obj.objsize = fp->fptr;
							fp->flag |= FA_MODIFIED;
						}
						clst = create_chain(&fp->obj, clst);	/* Follow chain with forceed stretch */
    4038:	4620      	mov	r0, r4
    403a:	f7ff f97b 	bl	3334 <create_chain.clone.3>
						if (clst == 0) {				/* Clip file size in case of disk full */
    403e:	4601      	mov	r1, r0
    4040:	b920      	cbnz	r0, 404c <f_lseek+0xae>
    4042:	e012      	b.n	406a <f_lseek+0xcc>
							ofs = 0; break;
						}
					} else
#endif
					{
						clst = get_fat(&fp->obj, clst);	/* Follow cluster chain if not in write mode */
    4044:	6820      	ldr	r0, [r4, #0]
    4046:	f7ff f8cd 	bl	31e4 <get_fat.clone.2>
    404a:	4601      	mov	r1, r0
					}
					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
    404c:	f1b1 3fff 	cmp.w	r1, #4294967295
    4050:	d0e3      	beq.n	401a <f_lseek+0x7c>
					if (clst <= 1 || clst >= fs->n_fatent) ABORT(fs, FR_INT_ERR);
    4052:	2901      	cmp	r1, #1
    4054:	d914      	bls.n	4080 <f_lseek+0xe2>
    4056:	9b01      	ldr	r3, [sp, #4]
    4058:	699b      	ldr	r3, [r3, #24]
    405a:	4299      	cmp	r1, r3
    405c:	d210      	bcs.n	4080 <f_lseek+0xe2>
    405e:	ebc8 0707 	rsb	r7, r8, r7
					fp->clust = clst;
    4062:	61a1      	str	r1, [r4, #24]
				}
#endif
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
    4064:	4547      	cmp	r7, r8
    4066:	d8e0      	bhi.n	402a <f_lseek+0x8c>
    4068:	e000      	b.n	406c <f_lseek+0xce>
							fp->obj.objsize = fp->fptr;
							fp->flag |= FA_MODIFIED;
						}
						clst = create_chain(&fp->obj, clst);	/* Follow chain with forceed stretch */
						if (clst == 0) {				/* Clip file size in case of disk full */
							ofs = 0; break;
    406a:	4607      	mov	r7, r0
					}
					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
					if (clst <= 1 || clst >= fs->n_fatent) ABORT(fs, FR_INT_ERR);
					fp->clust = clst;
				}
				fp->fptr += ofs;
    406c:	6963      	ldr	r3, [r4, #20]
				if (ofs % SS(fs)) {
    406e:	05fe      	lsls	r6, r7, #23
					}
					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
					if (clst <= 1 || clst >= fs->n_fatent) ABORT(fs, FR_INT_ERR);
					fp->clust = clst;
				}
				fp->fptr += ofs;
    4070:	19db      	adds	r3, r3, r7
				if (ofs % SS(fs)) {
    4072:	0df6      	lsrs	r6, r6, #23
					}
					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
					if (clst <= 1 || clst >= fs->n_fatent) ABORT(fs, FR_INT_ERR);
					fp->clust = clst;
				}
				fp->fptr += ofs;
    4074:	6163      	str	r3, [r4, #20]
				if (ofs % SS(fs)) {
    4076:	b15e      	cbz	r6, 4090 <f_lseek+0xf2>
					nsect = clst2sect(fs, clst);	/* Current sector */
    4078:	9801      	ldr	r0, [sp, #4]
    407a:	f7fe fce4 	bl	2a46 <clst2sect>
					if (nsect == 0) ABORT(fs, FR_INT_ERR);
    407e:	b908      	cbnz	r0, 4084 <f_lseek+0xe6>
    4080:	2502      	movs	r5, #2
    4082:	e7cb      	b.n	401c <f_lseek+0x7e>
					nsect += (DWORD)(ofs / SS(fs));
    4084:	eb00 2657 	add.w	r6, r0, r7, lsr #9
    4088:	e002      	b.n	4090 <f_lseek+0xf2>
#endif
		if (ofs > fp->obj.objsize && (FF_FS_READONLY || !(fp->flag & FA_WRITE))) {	/* In read-only mode, clip offset with the file size */
			ofs = fp->obj.objsize;
		}
		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
    408a:	463e      	mov	r6, r7
    408c:	e000      	b.n	4090 <f_lseek+0xf2>
    408e:	460e      	mov	r6, r1
					if (nsect == 0) ABORT(fs, FR_INT_ERR);
					nsect += (DWORD)(ofs / SS(fs));
				}
			}
		}
		if (!FF_FS_READONLY && fp->fptr > fp->obj.objsize) {	/* Set file change flag if the file size is extended */
    4090:	6963      	ldr	r3, [r4, #20]
    4092:	68e2      	ldr	r2, [r4, #12]
    4094:	4293      	cmp	r3, r2
    4096:	d904      	bls.n	40a2 <f_lseek+0x104>
			fp->obj.objsize = fp->fptr;
			fp->flag |= FA_MODIFIED;
    4098:	7c22      	ldrb	r2, [r4, #16]
					nsect += (DWORD)(ofs / SS(fs));
				}
			}
		}
		if (!FF_FS_READONLY && fp->fptr > fp->obj.objsize) {	/* Set file change flag if the file size is extended */
			fp->obj.objsize = fp->fptr;
    409a:	60e3      	str	r3, [r4, #12]
			fp->flag |= FA_MODIFIED;
    409c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    40a0:	7422      	strb	r2, [r4, #16]
		}
		if (fp->fptr % SS(fs) && nsect != fp->sect) {	/* Fill sector cache if needed */
    40a2:	05db      	lsls	r3, r3, #23
    40a4:	0ddb      	lsrs	r3, r3, #23
    40a6:	b1f3      	cbz	r3, 40e6 <f_lseek+0x148>
    40a8:	69e2      	ldr	r2, [r4, #28]
    40aa:	4296      	cmp	r6, r2
    40ac:	d01b      	beq.n	40e6 <f_lseek+0x148>
#if !FF_FS_TINY
#if !FF_FS_READONLY
			if (fp->flag & FA_DIRTY) {			/* Write-back dirty sector cache */
    40ae:	f994 3010 	ldrsb.w	r3, [r4, #16]
    40b2:	2b00      	cmp	r3, #0
    40b4:	da0c      	bge.n	40d0 <f_lseek+0x132>
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
    40b6:	9b01      	ldr	r3, [sp, #4]
    40b8:	f104 0128 	add.w	r1, r4, #40	; 0x28
    40bc:	7858      	ldrb	r0, [r3, #1]
    40be:	2301      	movs	r3, #1
    40c0:	f7fe fac0 	bl	2644 <disk_write>
    40c4:	2800      	cmp	r0, #0
    40c6:	d1a8      	bne.n	401a <f_lseek+0x7c>
				fp->flag &= (BYTE)~FA_DIRTY;
    40c8:	7c23      	ldrb	r3, [r4, #16]
    40ca:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    40ce:	7423      	strb	r3, [r4, #16]
			}
#endif
			if (disk_read(fs->pdrv, fp->buf, nsect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
    40d0:	9b01      	ldr	r3, [sp, #4]
    40d2:	f104 0128 	add.w	r1, r4, #40	; 0x28
    40d6:	7858      	ldrb	r0, [r3, #1]
    40d8:	4632      	mov	r2, r6
    40da:	2301      	movs	r3, #1
    40dc:	f7fe fa78 	bl	25d0 <disk_read>
    40e0:	2800      	cmp	r0, #0
    40e2:	d19a      	bne.n	401a <f_lseek+0x7c>
#endif
			fp->sect = nsect;
    40e4:	61e6      	str	r6, [r4, #28]
		}
	}

	LEAVE_FF(fs, res);
}
    40e6:	4628      	mov	r0, r5
    40e8:	e8bd 81fc 	ldmia.w	sp!, {r2, r3, r4, r5, r6, r7, r8, pc}

000040ec <f_opendir>:

FRESULT f_opendir (
	DIR* dp,			/* Pointer to directory object to create */
	const TCHAR* path	/* Pointer to the directory path */
)
{
    40ec:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	FRESULT res;
	FATFS *fs;
	DEF_NAMBUF


	if (!dp) return FR_INVALID_OBJECT;
    40ee:	4604      	mov	r4, r0

FRESULT f_opendir (
	DIR* dp,			/* Pointer to directory object to create */
	const TCHAR* path	/* Pointer to the directory path */
)
{
    40f0:	9101      	str	r1, [sp, #4]
	FRESULT res;
	FATFS *fs;
	DEF_NAMBUF


	if (!dp) return FR_INVALID_OBJECT;
    40f2:	2800      	cmp	r0, #0
    40f4:	d029      	beq.n	414a <f_opendir+0x5e>

	/* Get logical drive */
	res = find_volume(&path, &fs, 0);
    40f6:	a801      	add	r0, sp, #4
    40f8:	a903      	add	r1, sp, #12
    40fa:	2200      	movs	r2, #0
    40fc:	f7fe fe6c 	bl	2dd8 <find_volume>
	if (res == FR_OK) {
    4100:	bb00      	cbnz	r0, 4144 <f_opendir+0x58>
		dp->obj.fs = fs;
    4102:	9b03      	ldr	r3, [sp, #12]
		INIT_NAMBUF(fs);
		res = follow_path(dp, path);			/* Follow the path to the directory */
    4104:	4620      	mov	r0, r4
	if (!dp) return FR_INVALID_OBJECT;

	/* Get logical drive */
	res = find_volume(&path, &fs, 0);
	if (res == FR_OK) {
		dp->obj.fs = fs;
    4106:	6023      	str	r3, [r4, #0]
		INIT_NAMBUF(fs);
		res = follow_path(dp, path);			/* Follow the path to the directory */
    4108:	9901      	ldr	r1, [sp, #4]
    410a:	f7ff fa24 	bl	3556 <follow_path>
		if (res == FR_OK) {						/* Follow completed */
    410e:	b9a0      	cbnz	r0, 413a <f_opendir+0x4e>
			if (!(dp->fn[NSFLAG] & NS_NONAME)) {	/* It is not the origin directory itself */
    4110:	f994 302b 	ldrsb.w	r3, [r4, #43]	; 0x2b
    4114:	2b00      	cmp	r3, #0
    4116:	db09      	blt.n	412c <f_opendir+0x40>
				if (dp->obj.attr & AM_DIR) {		/* This object is a sub-directory */
    4118:	79a3      	ldrb	r3, [r4, #6]
    411a:	f013 0f10 	tst.w	r3, #16
    411e:	d010      	beq.n	4142 <f_opendir+0x56>
						dp->obj.c_ofs = dp->blk_ofs;
						init_alloc_info(fs, &dp->obj);	/* Get object allocation info */
					} else
#endif
					{
						dp->obj.sclust = ld_clust(fs, dp->dir);	/* Get object allocation info */
    4120:	9b03      	ldr	r3, [sp, #12]
    4122:	69e1      	ldr	r1, [r4, #28]
    4124:	7818      	ldrb	r0, [r3, #0]
    4126:	f7ff f837 	bl	3198 <ld_clust.clone.0>
    412a:	60a0      	str	r0, [r4, #8]
				} else {						/* This object is a file */
					res = FR_NO_PATH;
				}
			}
			if (res == FR_OK) {
				dp->obj.id = fs->id;
    412c:	9b03      	ldr	r3, [sp, #12]
				res = dir_sdi(dp, 0);			/* Rewind directory */
    412e:	4620      	mov	r0, r4
				} else {						/* This object is a file */
					res = FR_NO_PATH;
				}
			}
			if (res == FR_OK) {
				dp->obj.id = fs->id;
    4130:	88db      	ldrh	r3, [r3, #6]
				res = dir_sdi(dp, 0);			/* Rewind directory */
    4132:	2100      	movs	r1, #0
				} else {						/* This object is a file */
					res = FR_NO_PATH;
				}
			}
			if (res == FR_OK) {
				dp->obj.id = fs->id;
    4134:	80a3      	strh	r3, [r4, #4]
				res = dir_sdi(dp, 0);			/* Rewind directory */
    4136:	f7ff f8b0 	bl	329a <dir_sdi>
				}
#endif
			}
		}
		FREE_NAMBUF();
		if (res == FR_NO_FILE) res = FR_NO_PATH;
    413a:	2804      	cmp	r0, #4
    413c:	d001      	beq.n	4142 <f_opendir+0x56>
	}
	if (res != FR_OK) dp->obj.fs = 0;		/* Invalidate the directory object if function faild */
    413e:	b128      	cbz	r0, 414c <f_opendir+0x60>
    4140:	e000      	b.n	4144 <f_opendir+0x58>
#endif
					{
						dp->obj.sclust = ld_clust(fs, dp->dir);	/* Get object allocation info */
					}
				} else {						/* This object is a file */
					res = FR_NO_PATH;
    4142:	2005      	movs	r0, #5
			}
		}
		FREE_NAMBUF();
		if (res == FR_NO_FILE) res = FR_NO_PATH;
	}
	if (res != FR_OK) dp->obj.fs = 0;		/* Invalidate the directory object if function faild */
    4144:	2300      	movs	r3, #0
    4146:	6023      	str	r3, [r4, #0]
    4148:	e000      	b.n	414c <f_opendir+0x60>
	FRESULT res;
	FATFS *fs;
	DEF_NAMBUF


	if (!dp) return FR_INVALID_OBJECT;
    414a:	2009      	movs	r0, #9
		if (res == FR_NO_FILE) res = FR_NO_PATH;
	}
	if (res != FR_OK) dp->obj.fs = 0;		/* Invalidate the directory object if function faild */

	LEAVE_FF(fs, res);
}
    414c:	b004      	add	sp, #16
    414e:	bd10      	pop	{r4, pc}

00004150 <f_closedir>:
/*-----------------------------------------------------------------------*/

FRESULT f_closedir (
	DIR *dp		/* Pointer to the directory object to be closed */
)
{
    4150:	b513      	push	{r0, r1, r4, lr}
	FRESULT res;
	FATFS *fs;


	res = validate(&dp->obj, &fs);	/* Check validity of the file object */
    4152:	a901      	add	r1, sp, #4
/*-----------------------------------------------------------------------*/

FRESULT f_closedir (
	DIR *dp		/* Pointer to the directory object to be closed */
)
{
    4154:	4604      	mov	r4, r0
	FRESULT res;
	FATFS *fs;


	res = validate(&dp->obj, &fs);	/* Check validity of the file object */
    4156:	f7fe fdd5 	bl	2d04 <validate>
	if (res == FR_OK) {
    415a:	b900      	cbnz	r0, 415e <f_closedir+0xe>
#if FF_FS_LOCK != 0
		if (dp->obj.lockid) res = dec_lock(dp->obj.lockid);	/* Decrement sub-directory open counter */
		if (res == FR_OK) dp->obj.fs = 0;	/* Invalidate directory object */
#else
		dp->obj.fs = 0;	/* Invalidate directory object */
    415c:	6020      	str	r0, [r4, #0]
#if FF_FS_REENTRANT
		unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
	}
	return res;
}
    415e:	bd1c      	pop	{r2, r3, r4, pc}

00004160 <f_readdir>:

FRESULT f_readdir (
	DIR* dp,			/* Pointer to the open directory object */
	FILINFO* fno		/* Pointer to file information to return */
)
{
    4160:	b537      	push	{r0, r1, r2, r4, r5, lr}
    4162:	460d      	mov	r5, r1
	FRESULT res;
	FATFS *fs;
	DEF_NAMBUF


	res = validate(&dp->obj, &fs);	/* Check validity of the directory object */
    4164:	a901      	add	r1, sp, #4

FRESULT f_readdir (
	DIR* dp,			/* Pointer to the open directory object */
	FILINFO* fno		/* Pointer to file information to return */
)
{
    4166:	4604      	mov	r4, r0
	FRESULT res;
	FATFS *fs;
	DEF_NAMBUF


	res = validate(&dp->obj, &fs);	/* Check validity of the directory object */
    4168:	f7fe fdcc 	bl	2d04 <validate>
	if (res == FR_OK) {
    416c:	4601      	mov	r1, r0
    416e:	b9c0      	cbnz	r0, 41a2 <f_readdir+0x42>
		if (!fno) {
    4170:	b91d      	cbnz	r5, 417a <f_readdir+0x1a>
			res = dir_sdi(dp, 0);			/* Rewind the directory object */
    4172:	4620      	mov	r0, r4
    4174:	f7ff f891 	bl	329a <dir_sdi>
    4178:	e012      	b.n	41a0 <f_readdir+0x40>
		} else {
			INIT_NAMBUF(fs);
			res = DIR_READ_FILE(dp);		/* Read an item */
    417a:	4620      	mov	r0, r4
    417c:	f7ff f9b9 	bl	34f2 <dir_read>
			if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory */
    4180:	2804      	cmp	r0, #4
    4182:	d000      	beq.n	4186 <f_readdir+0x26>
			if (res == FR_OK) {				/* A valid entry is found */
    4184:	b960      	cbnz	r0, 41a0 <f_readdir+0x40>
				get_fileinfo(dp, fno);		/* Get the object information */
    4186:	4620      	mov	r0, r4
    4188:	4629      	mov	r1, r5
    418a:	f7fe fc68 	bl	2a5e <get_fileinfo>
				res = dir_next(dp, 0);		/* Increment index for next */
    418e:	2100      	movs	r1, #0
    4190:	4620      	mov	r0, r4
    4192:	f7ff f94b 	bl	342c <dir_next>
				if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory now */
    4196:	2804      	cmp	r0, #4
    4198:	bf14      	ite	ne
    419a:	4601      	movne	r1, r0
    419c:	2100      	moveq	r1, #0
    419e:	e000      	b.n	41a2 <f_readdir+0x42>
			res = dir_sdi(dp, 0);			/* Rewind the directory object */
		} else {
			INIT_NAMBUF(fs);
			res = DIR_READ_FILE(dp);		/* Read an item */
			if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory */
			if (res == FR_OK) {				/* A valid entry is found */
    41a0:	4601      	mov	r1, r0
			}
			FREE_NAMBUF();
		}
	}
	LEAVE_FF(fs, res);
}
    41a2:	4608      	mov	r0, r1
    41a4:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

000041a6 <f_findnext>:

FRESULT f_findnext (
	DIR* dp,		/* Pointer to the open directory object */
	FILINFO* fno	/* Pointer to the file information structure */
)
{
    41a6:	b570      	push	{r4, r5, r6, lr}
    41a8:	4606      	mov	r6, r0
    41aa:	460d      	mov	r5, r1
	FRESULT res;


	for (;;) {
		res = f_readdir(dp, fno);		/* Get a directory item */
    41ac:	4630      	mov	r0, r6
    41ae:	4629      	mov	r1, r5
    41b0:	f7ff ffd6 	bl	4160 <f_readdir>
		if (res != FR_OK || !fno || !fno->fname[0]) break;	/* Terminate if any error or end of directory */
    41b4:	4604      	mov	r4, r0
    41b6:	b958      	cbnz	r0, 41d0 <f_findnext+0x2a>
    41b8:	b155      	cbz	r5, 41d0 <f_findnext+0x2a>
    41ba:	7a6b      	ldrb	r3, [r5, #9]
    41bc:	b143      	cbz	r3, 41d0 <f_findnext+0x2a>
		if (pattern_matching(dp->pat, fno->fname, 0, 0)) break;		/* Test for the file name */
    41be:	6af0      	ldr	r0, [r6, #44]	; 0x2c
    41c0:	f105 0109 	add.w	r1, r5, #9
    41c4:	4622      	mov	r2, r4
    41c6:	4623      	mov	r3, r4
    41c8:	f7fe fc97 	bl	2afa <pattern_matching>
    41cc:	2800      	cmp	r0, #0
    41ce:	d0ed      	beq.n	41ac <f_findnext+0x6>
#if FF_USE_LFN && FF_USE_FIND == 2
		if (pattern_matching(dp->pat, fno->altname, 0, 0)) break;	/* Test for alternative name if exist */
#endif
	}
	return res;
}
    41d0:	4620      	mov	r0, r4
    41d2:	bd70      	pop	{r4, r5, r6, pc}

000041d4 <f_findfirst>:
	DIR* dp,				/* Pointer to the blank directory object */
	FILINFO* fno,			/* Pointer to the file information structure */
	const TCHAR* path,		/* Pointer to the directory to open */
	const TCHAR* pattern	/* Pointer to the matching pattern */
)
{
    41d4:	b570      	push	{r4, r5, r6, lr}
    41d6:	460d      	mov	r5, r1
	FRESULT res;


	dp->pat = pattern;		/* Save pointer to pattern string */
    41d8:	62c3      	str	r3, [r0, #44]	; 0x2c
	res = f_opendir(dp, path);		/* Open the target directory */
    41da:	4611      	mov	r1, r2
	DIR* dp,				/* Pointer to the blank directory object */
	FILINFO* fno,			/* Pointer to the file information structure */
	const TCHAR* path,		/* Pointer to the directory to open */
	const TCHAR* pattern	/* Pointer to the matching pattern */
)
{
    41dc:	4604      	mov	r4, r0
	FRESULT res;


	dp->pat = pattern;		/* Save pointer to pattern string */
	res = f_opendir(dp, path);		/* Open the target directory */
    41de:	f7ff ff85 	bl	40ec <f_opendir>
	if (res == FR_OK) {
    41e2:	b920      	cbnz	r0, 41ee <f_findfirst+0x1a>
		res = f_findnext(dp, fno);	/* Find the first item */
    41e4:	4620      	mov	r0, r4
    41e6:	4629      	mov	r1, r5
	}
	return res;
}
    41e8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}


	dp->pat = pattern;		/* Save pointer to pattern string */
	res = f_opendir(dp, path);		/* Open the target directory */
	if (res == FR_OK) {
		res = f_findnext(dp, fno);	/* Find the first item */
    41ec:	e7db      	b.n	41a6 <f_findnext>
	}
	return res;
}
    41ee:	bd70      	pop	{r4, r5, r6, pc}

000041f0 <f_stat>:

FRESULT f_stat (
	const TCHAR* path,	/* Pointer to the file path */
	FILINFO* fno		/* Pointer to file information to return */
)
{
    41f0:	b530      	push	{r4, r5, lr}
    41f2:	b08f      	sub	sp, #60	; 0x3c
    41f4:	ab0e      	add	r3, sp, #56	; 0x38
    41f6:	f843 0d34 	str.w	r0, [r3, #-52]!
    41fa:	460c      	mov	r4, r1
	DIR dj;
	DEF_NAMBUF


	/* Get logical drive */
	res = find_volume(&path, &dj.obj.fs, 0);
    41fc:	4618      	mov	r0, r3
    41fe:	a902      	add	r1, sp, #8
    4200:	2200      	movs	r2, #0
    4202:	f7fe fde9 	bl	2dd8 <find_volume>
	if (res == FR_OK) {
    4206:	4605      	mov	r5, r0
    4208:	b980      	cbnz	r0, 422c <f_stat+0x3c>
		INIT_NAMBUF(dj.obj.fs);
		res = follow_path(&dj, path);	/* Follow the file path */
    420a:	a802      	add	r0, sp, #8
    420c:	9901      	ldr	r1, [sp, #4]
    420e:	f7ff f9a2 	bl	3556 <follow_path>
		if (res == FR_OK) {				/* Follow completed */
    4212:	4605      	mov	r5, r0
    4214:	b950      	cbnz	r0, 422c <f_stat+0x3c>
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* It is origin directory */
    4216:	f99d 3033 	ldrsb.w	r3, [sp, #51]	; 0x33
    421a:	2b00      	cmp	r3, #0
    421c:	db05      	blt.n	422a <f_stat+0x3a>
				res = FR_INVALID_NAME;
			} else {							/* Found an object */
				if (fno) get_fileinfo(&dj, fno);
    421e:	b12c      	cbz	r4, 422c <f_stat+0x3c>
    4220:	a802      	add	r0, sp, #8
    4222:	4621      	mov	r1, r4
    4224:	f7fe fc1b 	bl	2a5e <get_fileinfo>
    4228:	e000      	b.n	422c <f_stat+0x3c>
	if (res == FR_OK) {
		INIT_NAMBUF(dj.obj.fs);
		res = follow_path(&dj, path);	/* Follow the file path */
		if (res == FR_OK) {				/* Follow completed */
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* It is origin directory */
				res = FR_INVALID_NAME;
    422a:	2506      	movs	r5, #6
		}
		FREE_NAMBUF();
	}

	LEAVE_FF(dj.obj.fs, res);
}
    422c:	4628      	mov	r0, r5
    422e:	b00f      	add	sp, #60	; 0x3c
    4230:	bd30      	pop	{r4, r5, pc}

00004232 <f_getfree>:
FRESULT f_getfree (
	const TCHAR* path,	/* Logical drive number */
	DWORD* nclst,		/* Pointer to a variable to return number of free clusters */
	FATFS** fatfs		/* Pointer to return pointer to corresponding filesystem object */
)
{
    4232:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    4236:	b085      	sub	sp, #20
    4238:	ab04      	add	r3, sp, #16
    423a:	f843 0d0c 	str.w	r0, [r3, #-12]!
    423e:	460c      	mov	r4, r1
    4240:	4615      	mov	r5, r2
	UINT i;
	FFOBJID obj;


	/* Get logical drive */
	res = find_volume(&path, &fs, 0);
    4242:	4618      	mov	r0, r3
    4244:	a903      	add	r1, sp, #12
    4246:	2200      	movs	r2, #0
    4248:	f7fe fdc6 	bl	2dd8 <find_volume>
	if (res == FR_OK) {
    424c:	4606      	mov	r6, r0
    424e:	2800      	cmp	r0, #0
    4250:	d157      	bne.n	4302 <f_getfree+0xd0>
		*fatfs = fs;				/* Return ptr to the fs object */
    4252:	9f03      	ldr	r7, [sp, #12]
		/* If free_clst is valid, return it without full FAT scan */
		if (fs->free_clst <= fs->n_fatent - 2) {
    4254:	f8d7 8018 	ldr.w	r8, [r7, #24]
    4258:	693b      	ldr	r3, [r7, #16]
    425a:	f1a8 0202 	sub.w	r2, r8, #2
    425e:	4293      	cmp	r3, r2


	/* Get logical drive */
	res = find_volume(&path, &fs, 0);
	if (res == FR_OK) {
		*fatfs = fs;				/* Return ptr to the fs object */
    4260:	602f      	str	r7, [r5, #0]
		/* If free_clst is valid, return it without full FAT scan */
		if (fs->free_clst <= fs->n_fatent - 2) {
    4262:	d801      	bhi.n	4268 <f_getfree+0x36>
			*nclst = fs->free_clst;
    4264:	6023      	str	r3, [r4, #0]
    4266:	e04c      	b.n	4302 <f_getfree+0xd0>
		} else {
			/* Scan FAT to obtain number of free clusters */
			nfree = 0;
			if (fs->fs_type == FS_FAT12) {	/* FAT12: Scan bit field FAT entries */
    4268:	783b      	ldrb	r3, [r7, #0]
    426a:	2b01      	cmp	r3, #1
    426c:	d114      	bne.n	4298 <f_getfree+0x66>
    426e:	f04f 0802 	mov.w	r8, #2
    4272:	4605      	mov	r5, r0
				clst = 2; obj.fs = fs;
				do {
					stat = get_fat(&obj, clst);
    4274:	4638      	mov	r0, r7
    4276:	4641      	mov	r1, r8
    4278:	f7fe ffb4 	bl	31e4 <get_fat.clone.2>
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
    427c:	f1b0 3fff 	cmp.w	r0, #4294967295
    4280:	d033      	beq.n	42ea <f_getfree+0xb8>
					if (stat == 1) { res = FR_INT_ERR; break; }
    4282:	2801      	cmp	r0, #1
    4284:	d033      	beq.n	42ee <f_getfree+0xbc>
					if (stat == 0) nfree++;
    4286:	b900      	cbnz	r0, 428a <f_getfree+0x58>
    4288:	3501      	adds	r5, #1
				} while (++clst < fs->n_fatent);
    428a:	9b03      	ldr	r3, [sp, #12]
    428c:	f108 0801 	add.w	r8, r8, #1
    4290:	699b      	ldr	r3, [r3, #24]
    4292:	4598      	cmp	r8, r3
    4294:	d3ee      	bcc.n	4274 <f_getfree+0x42>
    4296:	e02d      	b.n	42f4 <f_getfree+0xc2>
					} while (clst);
				} else
#endif
				{	/* FAT16/32: Scan WORD/DWORD FAT entries */
					clst = fs->n_fatent;	/* Number of entries */
					sect = fs->fatbase;		/* Top of the FAT */
    4298:	f8d7 9024 	ldr.w	r9, [r7, #36]	; 0x24
		/* If free_clst is valid, return it without full FAT scan */
		if (fs->free_clst <= fs->n_fatent - 2) {
			*nclst = fs->free_clst;
		} else {
			/* Scan FAT to obtain number of free clusters */
			nfree = 0;
    429c:	4605      	mov	r5, r0
				} else
#endif
				{	/* FAT16/32: Scan WORD/DWORD FAT entries */
					clst = fs->n_fatent;	/* Number of entries */
					sect = fs->fatbase;		/* Top of the FAT */
					i = 0;					/* Offset in the sector */
    429e:	4607      	mov	r7, r0
					do {	/* Counts numbuer of entries with zero in the FAT */
						if (i == 0) {
    42a0:	b937      	cbnz	r7, 42b0 <f_getfree+0x7e>
							res = move_window(fs, sect++);
    42a2:	9803      	ldr	r0, [sp, #12]
    42a4:	4649      	mov	r1, r9
    42a6:	f7fe fd45 	bl	2d34 <move_window>
							if (res != FR_OK) break;
    42aa:	bb10      	cbnz	r0, 42f2 <f_getfree+0xc0>
					clst = fs->n_fatent;	/* Number of entries */
					sect = fs->fatbase;		/* Top of the FAT */
					i = 0;					/* Offset in the sector */
					do {	/* Counts numbuer of entries with zero in the FAT */
						if (i == 0) {
							res = move_window(fs, sect++);
    42ac:	f109 0901 	add.w	r9, r9, #1
							if (res != FR_OK) break;
						}
						if (fs->fs_type == FS_FAT16) {
    42b0:	9b03      	ldr	r3, [sp, #12]
    42b2:	f107 0030 	add.w	r0, r7, #48	; 0x30
    42b6:	781a      	ldrb	r2, [r3, #0]
    42b8:	2a02      	cmp	r2, #2
    42ba:	d107      	bne.n	42cc <f_getfree+0x9a>
							if (ld_word(fs->win + i) == 0) nfree++;
    42bc:	1818      	adds	r0, r3, r0
    42be:	3004      	adds	r0, #4
    42c0:	f7fe fb60 	bl	2984 <ld_word>
    42c4:	b900      	cbnz	r0, 42c8 <f_getfree+0x96>
    42c6:	3501      	adds	r5, #1
							i += 2;
    42c8:	3702      	adds	r7, #2
    42ca:	e008      	b.n	42de <f_getfree+0xac>
						} else {
							if ((ld_dword(fs->win + i) & 0x0FFFFFFF) == 0) nfree++;
    42cc:	1818      	adds	r0, r3, r0
    42ce:	3004      	adds	r0, #4
    42d0:	f7fe fb5d 	bl	298e <ld_dword>
    42d4:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
    42d8:	b900      	cbnz	r0, 42dc <f_getfree+0xaa>
    42da:	3501      	adds	r5, #1
							i += 4;
    42dc:	3704      	adds	r7, #4
						}
						i %= SS(fs);
					} while (--clst);
    42de:	f1b8 0801 	subs.w	r8, r8, #1
    42e2:	d007      	beq.n	42f4 <f_getfree+0xc2>
							i += 2;
						} else {
							if ((ld_dword(fs->win + i) & 0x0FFFFFFF) == 0) nfree++;
							i += 4;
						}
						i %= SS(fs);
    42e4:	05ff      	lsls	r7, r7, #23
    42e6:	0dff      	lsrs	r7, r7, #23
    42e8:	e7da      	b.n	42a0 <f_getfree+0x6e>
			nfree = 0;
			if (fs->fs_type == FS_FAT12) {	/* FAT12: Scan bit field FAT entries */
				clst = 2; obj.fs = fs;
				do {
					stat = get_fat(&obj, clst);
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
    42ea:	2601      	movs	r6, #1
    42ec:	e002      	b.n	42f4 <f_getfree+0xc2>
					if (stat == 1) { res = FR_INT_ERR; break; }
    42ee:	2602      	movs	r6, #2
    42f0:	e000      	b.n	42f4 <f_getfree+0xc2>
					clst = fs->n_fatent;	/* Number of entries */
					sect = fs->fatbase;		/* Top of the FAT */
					i = 0;					/* Offset in the sector */
					do {	/* Counts numbuer of entries with zero in the FAT */
						if (i == 0) {
							res = move_window(fs, sect++);
    42f2:	4606      	mov	r6, r0
						i %= SS(fs);
					} while (--clst);
				}
			}
			*nclst = nfree;			/* Return the free clusters */
			fs->free_clst = nfree;	/* Now free_clst is valid */
    42f4:	9b03      	ldr	r3, [sp, #12]
						}
						i %= SS(fs);
					} while (--clst);
				}
			}
			*nclst = nfree;			/* Return the free clusters */
    42f6:	6025      	str	r5, [r4, #0]
			fs->free_clst = nfree;	/* Now free_clst is valid */
			fs->fsi_flag |= 1;		/* FAT32: FSInfo is to be updated */
    42f8:	791a      	ldrb	r2, [r3, #4]
						i %= SS(fs);
					} while (--clst);
				}
			}
			*nclst = nfree;			/* Return the free clusters */
			fs->free_clst = nfree;	/* Now free_clst is valid */
    42fa:	611d      	str	r5, [r3, #16]
			fs->fsi_flag |= 1;		/* FAT32: FSInfo is to be updated */
    42fc:	f042 0201 	orr.w	r2, r2, #1
    4300:	711a      	strb	r2, [r3, #4]
		}
	}

	LEAVE_FF(fs, res);
}
    4302:	4630      	mov	r0, r6
    4304:	b005      	add	sp, #20
    4306:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0000430a <f_truncate>:
/*-----------------------------------------------------------------------*/

FRESULT f_truncate (
	FIL* fp		/* Pointer to the file object */
)
{
    430a:	b573      	push	{r0, r1, r4, r5, r6, lr}
	FRESULT res;
	FATFS *fs;
	DWORD ncl;


	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
    430c:	a901      	add	r1, sp, #4
/*-----------------------------------------------------------------------*/

FRESULT f_truncate (
	FIL* fp		/* Pointer to the file object */
)
{
    430e:	4604      	mov	r4, r0
	FRESULT res;
	FATFS *fs;
	DWORD ncl;


	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
    4310:	f7fe fcf8 	bl	2d04 <validate>
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);
    4314:	4605      	mov	r5, r0
    4316:	2800      	cmp	r0, #0
    4318:	d143      	bne.n	43a2 <f_truncate+0x98>
    431a:	7c65      	ldrb	r5, [r4, #17]
    431c:	2d00      	cmp	r5, #0
    431e:	d140      	bne.n	43a2 <f_truncate+0x98>
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
    4320:	7c23      	ldrb	r3, [r4, #16]
    4322:	f013 0f02 	tst.w	r3, #2
    4326:	d03b      	beq.n	43a0 <f_truncate+0x96>

	if (fp->fptr < fp->obj.objsize) {	/* Process when fptr is not on the eof */
    4328:	6966      	ldr	r6, [r4, #20]
    432a:	68e3      	ldr	r3, [r4, #12]
    432c:	429e      	cmp	r6, r3
    432e:	d238      	bcs.n	43a2 <f_truncate+0x98>
		if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
    4330:	b93e      	cbnz	r6, 4342 <f_truncate+0x38>
			res = remove_chain(&fp->obj, fp->obj.sclust, 0);
    4332:	462a      	mov	r2, r5
    4334:	4620      	mov	r0, r4
    4336:	68a1      	ldr	r1, [r4, #8]
    4338:	f7ff fa18 	bl	376c <remove_chain.clone.4>
			fp->obj.sclust = 0;
    433c:	60a6      	str	r6, [r4, #8]
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */

	if (fp->fptr < fp->obj.objsize) {	/* Process when fptr is not on the eof */
		if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
			res = remove_chain(&fp->obj, fp->obj.sclust, 0);
    433e:	4605      	mov	r5, r0
    4340:	e013      	b.n	436a <f_truncate+0x60>
			fp->obj.sclust = 0;
		} else {				/* When truncate a part of the file, remove remaining clusters */
			ncl = get_fat(&fp->obj, fp->clust);
    4342:	69a1      	ldr	r1, [r4, #24]
    4344:	6820      	ldr	r0, [r4, #0]
    4346:	f7fe ff4d 	bl	31e4 <get_fat.clone.2>
			res = FR_OK;
			if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
    434a:	f1b0 3fff 	cmp.w	r0, #4294967295
	if (fp->fptr < fp->obj.objsize) {	/* Process when fptr is not on the eof */
		if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
			res = remove_chain(&fp->obj, fp->obj.sclust, 0);
			fp->obj.sclust = 0;
		} else {				/* When truncate a part of the file, remove remaining clusters */
			ncl = get_fat(&fp->obj, fp->clust);
    434e:	4601      	mov	r1, r0
			res = FR_OK;
			if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
    4350:	d008      	beq.n	4364 <f_truncate+0x5a>
			if (ncl == 1) res = FR_INT_ERR;
    4352:	2801      	cmp	r0, #1
    4354:	d127      	bne.n	43a6 <f_truncate+0x9c>
    4356:	e007      	b.n	4368 <f_truncate+0x5e>
			if (res == FR_OK && ncl < fs->n_fatent) {
				res = remove_chain(&fp->obj, ncl, fp->clust);
    4358:	4620      	mov	r0, r4
    435a:	69a2      	ldr	r2, [r4, #24]
    435c:	f7ff fa06 	bl	376c <remove_chain.clone.4>
    4360:	4605      	mov	r5, r0
    4362:	e002      	b.n	436a <f_truncate+0x60>
			res = remove_chain(&fp->obj, fp->obj.sclust, 0);
			fp->obj.sclust = 0;
		} else {				/* When truncate a part of the file, remove remaining clusters */
			ncl = get_fat(&fp->obj, fp->clust);
			res = FR_OK;
			if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
    4364:	2501      	movs	r5, #1
    4366:	e000      	b.n	436a <f_truncate+0x60>
			if (ncl == 1) res = FR_INT_ERR;
    4368:	2502      	movs	r5, #2
			if (res == FR_OK && ncl < fs->n_fatent) {
				res = remove_chain(&fp->obj, ncl, fp->clust);
			}
		}
		fp->obj.objsize = fp->fptr;	/* Set file size to current read/write point */
    436a:	6963      	ldr	r3, [r4, #20]
    436c:	60e3      	str	r3, [r4, #12]
		fp->flag |= FA_MODIFIED;
    436e:	7c23      	ldrb	r3, [r4, #16]
    4370:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    4374:	7423      	strb	r3, [r4, #16]
#if !FF_FS_TINY
		if (res == FR_OK && (fp->flag & FA_DIRTY)) {
    4376:	b98d      	cbnz	r5, 439c <f_truncate+0x92>
    4378:	f013 0f80 	tst.w	r3, #128	; 0x80
    437c:	d011      	beq.n	43a2 <f_truncate+0x98>
			if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) {
    437e:	9b01      	ldr	r3, [sp, #4]
    4380:	f104 0128 	add.w	r1, r4, #40	; 0x28
    4384:	7858      	ldrb	r0, [r3, #1]
    4386:	69e2      	ldr	r2, [r4, #28]
    4388:	2301      	movs	r3, #1
    438a:	f7fe f95b 	bl	2644 <disk_write>
    438e:	b920      	cbnz	r0, 439a <f_truncate+0x90>
				res = FR_DISK_ERR;
			} else {
				fp->flag &= (BYTE)~FA_DIRTY;
    4390:	7c23      	ldrb	r3, [r4, #16]
    4392:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    4396:	7423      	strb	r3, [r4, #16]
    4398:	e003      	b.n	43a2 <f_truncate+0x98>
		fp->obj.objsize = fp->fptr;	/* Set file size to current read/write point */
		fp->flag |= FA_MODIFIED;
#if !FF_FS_TINY
		if (res == FR_OK && (fp->flag & FA_DIRTY)) {
			if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) {
				res = FR_DISK_ERR;
    439a:	2501      	movs	r5, #1
			} else {
				fp->flag &= (BYTE)~FA_DIRTY;
			}
		}
#endif
		if (res != FR_OK) ABORT(fs, res);
    439c:	7465      	strb	r5, [r4, #17]
    439e:	e000      	b.n	43a2 <f_truncate+0x98>
	DWORD ncl;


	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
    43a0:	2507      	movs	r5, #7
#endif
		if (res != FR_OK) ABORT(fs, res);
	}

	LEAVE_FF(fs, res);
}
    43a2:	4628      	mov	r0, r5
    43a4:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
		} else {				/* When truncate a part of the file, remove remaining clusters */
			ncl = get_fat(&fp->obj, fp->clust);
			res = FR_OK;
			if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
			if (ncl == 1) res = FR_INT_ERR;
			if (res == FR_OK && ncl < fs->n_fatent) {
    43a6:	9b01      	ldr	r3, [sp, #4]
    43a8:	699b      	ldr	r3, [r3, #24]
    43aa:	4298      	cmp	r0, r3
    43ac:	d2dd      	bcs.n	436a <f_truncate+0x60>
    43ae:	e7d3      	b.n	4358 <f_truncate+0x4e>

000043b0 <f_unlink>:
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
	const TCHAR* path		/* Pointer to the file or directory path */
)
{
    43b0:	b5f0      	push	{r4, r5, r6, r7, lr}
    43b2:	b09d      	sub	sp, #116	; 0x74
    43b4:	ab1c      	add	r3, sp, #112	; 0x70
    43b6:	f843 0d6c 	str.w	r0, [r3, #-108]!
#endif
	DEF_NAMBUF


	/* Get logical drive */
	res = find_volume(&path, &fs, FA_WRITE);
    43ba:	4618      	mov	r0, r3
    43bc:	a91b      	add	r1, sp, #108	; 0x6c
    43be:	2202      	movs	r2, #2
    43c0:	f7fe fd0a 	bl	2dd8 <find_volume>
	if (res == FR_OK) {
    43c4:	4604      	mov	r4, r0
    43c6:	2800      	cmp	r0, #0
    43c8:	d13a      	bne.n	4440 <f_unlink+0x90>
		dj.obj.fs = fs;
    43ca:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    43cc:	a81c      	add	r0, sp, #112	; 0x70
    43ce:	f840 3d34 	str.w	r3, [r0, #-52]!
		INIT_NAMBUF(fs);
		res = follow_path(&dj, path);		/* Follow the file path */
    43d2:	9901      	ldr	r1, [sp, #4]
    43d4:	f7ff f8bf 	bl	3556 <follow_path>
		if (FF_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT)) {
    43d8:	4604      	mov	r4, r0
    43da:	2800      	cmp	r0, #0
    43dc:	d130      	bne.n	4440 <f_unlink+0x90>
    43de:	f89d 3067 	ldrb.w	r3, [sp, #103]	; 0x67
    43e2:	f013 0f20 	tst.w	r3, #32
    43e6:	d02e      	beq.n	4446 <f_unlink+0x96>
			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
    43e8:	1d84      	adds	r4, r0, #6
    43ea:	e029      	b.n	4440 <f_unlink+0x90>
#endif
		if (res == FR_OK) {					/* The object is accessible */
			if (dj.fn[NSFLAG] & NS_NONAME) {
				res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
			} else {
				if (dj.obj.attr & AM_RDO) {
    43ec:	f89d 7042 	ldrb.w	r7, [sp, #66]	; 0x42
    43f0:	f017 0f01 	tst.w	r7, #1
    43f4:	d02b      	beq.n	444e <f_unlink+0x9e>
    43f6:	e015      	b.n	4424 <f_unlink+0x74>
#if FF_FS_LOCK != 0
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Check if it is an open object */
#endif
		if (res == FR_OK) {					/* The object is accessible */
			if (dj.fn[NSFLAG] & NS_NONAME) {
				res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
    43f8:	2406      	movs	r4, #6
    43fa:	e021      	b.n	4440 <f_unlink+0x90>
				{
					dclst = ld_clust(fs, dj.dir);
				}
				if (dj.obj.attr & AM_DIR) {			/* Is it a sub-directory? */
#if FF_FS_RPATH != 0
					if (dclst == fs->cdir) {		 	/* Is it the current directory? */
    43fc:	6973      	ldr	r3, [r6, #20]
    43fe:	429d      	cmp	r5, r3
    4400:	d010      	beq.n	4424 <f_unlink+0x74>
						if (fs->fs_type == FS_EXFAT) {
							sdj.obj.objsize = obj.objsize;
							sdj.obj.stat = obj.stat;
						}
#endif
						res = dir_sdi(&sdj, 0);
    4402:	4621      	mov	r1, r4
    4404:	a803      	add	r0, sp, #12
					if (dclst == fs->cdir) {		 	/* Is it the current directory? */
						res = FR_DENIED;
					} else
#endif
					{
						sdj.obj.fs = fs;				/* Open the sub-directory */
    4406:	9603      	str	r6, [sp, #12]
						sdj.obj.sclust = dclst;
    4408:	9505      	str	r5, [sp, #20]
						if (fs->fs_type == FS_EXFAT) {
							sdj.obj.objsize = obj.objsize;
							sdj.obj.stat = obj.stat;
						}
#endif
						res = dir_sdi(&sdj, 0);
    440a:	f7fe ff46 	bl	329a <dir_sdi>
						if (res == FR_OK) {
    440e:	4604      	mov	r4, r0
    4410:	b9b0      	cbnz	r0, 4440 <f_unlink+0x90>
							res = DIR_READ_FILE(&sdj);			/* Test if the directory is empty */
    4412:	4621      	mov	r1, r4
    4414:	a803      	add	r0, sp, #12
    4416:	f7ff f86c 	bl	34f2 <dir_read>
							if (res == FR_OK) res = FR_DENIED;	/* Not empty? */
    441a:	4604      	mov	r4, r0
    441c:	b110      	cbz	r0, 4424 <f_unlink+0x74>
							if (res == FR_NO_FILE) res = FR_OK;	/* Empty? */
    441e:	2804      	cmp	r0, #4
    4420:	d01e      	beq.n	4460 <f_unlink+0xb0>
    4422:	e00d      	b.n	4440 <f_unlink+0x90>
						}
#endif
						res = dir_sdi(&sdj, 0);
						if (res == FR_OK) {
							res = DIR_READ_FILE(&sdj);			/* Test if the directory is empty */
							if (res == FR_OK) res = FR_DENIED;	/* Not empty? */
    4424:	2407      	movs	r4, #7
    4426:	e00b      	b.n	4440 <f_unlink+0x90>
					}
				}
			}
			if (res == FR_OK) {
				res = dir_remove(&dj);			/* Remove the directory entry */
				if (res == FR_OK && dclst != 0) {	/* Remove the cluster chain if exist */
    4428:	b135      	cbz	r5, 4438 <f_unlink+0x88>
#if FF_FS_EXFAT
					res = remove_chain(&obj, dclst, 0);
#else
					res = remove_chain(&dj.obj, dclst, 0);
    442a:	4622      	mov	r2, r4
    442c:	a80f      	add	r0, sp, #60	; 0x3c
    442e:	4629      	mov	r1, r5
    4430:	f7ff f99c 	bl	376c <remove_chain.clone.4>
#endif
				}
				if (res == FR_OK) res = sync_fs(fs);
    4434:	4604      	mov	r4, r0
    4436:	b918      	cbnz	r0, 4440 <f_unlink+0x90>
    4438:	981b      	ldr	r0, [sp, #108]	; 0x6c
    443a:	f7fe fc1e 	bl	2c7a <sync_fs>
    443e:	4604      	mov	r4, r0
		}
		FREE_NAMBUF();
	}

	LEAVE_FF(fs, res);
}
    4440:	4620      	mov	r0, r4
    4442:	b01d      	add	sp, #116	; 0x74
    4444:	bdf0      	pop	{r4, r5, r6, r7, pc}
		}
#if FF_FS_LOCK != 0
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Check if it is an open object */
#endif
		if (res == FR_OK) {					/* The object is accessible */
			if (dj.fn[NSFLAG] & NS_NONAME) {
    4446:	f013 0f80 	tst.w	r3, #128	; 0x80
    444a:	d0cf      	beq.n	43ec <f_unlink+0x3c>
    444c:	e7d4      	b.n	43f8 <f_unlink+0x48>
					init_alloc_info(fs, &obj);
					dclst = obj.sclust;
				} else
#endif
				{
					dclst = ld_clust(fs, dj.dir);
    444e:	9e1b      	ldr	r6, [sp, #108]	; 0x6c
    4450:	9916      	ldr	r1, [sp, #88]	; 0x58
    4452:	7830      	ldrb	r0, [r6, #0]
    4454:	f7fe fea0 	bl	3198 <ld_clust.clone.0>
				}
				if (dj.obj.attr & AM_DIR) {			/* Is it a sub-directory? */
    4458:	f017 0f10 	tst.w	r7, #16
					init_alloc_info(fs, &obj);
					dclst = obj.sclust;
				} else
#endif
				{
					dclst = ld_clust(fs, dj.dir);
    445c:	4605      	mov	r5, r0
				}
				if (dj.obj.attr & AM_DIR) {			/* Is it a sub-directory? */
    445e:	d1cd      	bne.n	43fc <f_unlink+0x4c>
						}
					}
				}
			}
			if (res == FR_OK) {
				res = dir_remove(&dj);			/* Remove the directory entry */
    4460:	a80f      	add	r0, sp, #60	; 0x3c
    4462:	f7fe fe8b 	bl	317c <dir_remove>
				if (res == FR_OK && dclst != 0) {	/* Remove the cluster chain if exist */
    4466:	4604      	mov	r4, r0
    4468:	2800      	cmp	r0, #0
    446a:	d0dd      	beq.n	4428 <f_unlink+0x78>
    446c:	e7e8      	b.n	4440 <f_unlink+0x90>

0000446e <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR* path		/* Pointer to the directory path */
)
{
    446e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4472:	b094      	sub	sp, #80	; 0x50
    4474:	ab14      	add	r3, sp, #80	; 0x50
    4476:	f843 0d4c 	str.w	r0, [r3, #-76]!
	FATFS *fs;
	DWORD dcl, pcl, tm;
	DEF_NAMBUF


	res = find_volume(&path, &fs, FA_WRITE);	/* Get logical drive */
    447a:	4618      	mov	r0, r3
    447c:	a913      	add	r1, sp, #76	; 0x4c
    447e:	2202      	movs	r2, #2
    4480:	f7fe fcaa 	bl	2dd8 <find_volume>
	if (res == FR_OK) {
    4484:	4604      	mov	r4, r0
    4486:	2800      	cmp	r0, #0
    4488:	d16f      	bne.n	456a <f_mkdir+0xfc>
		dj.obj.fs = fs;
    448a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    448c:	a814      	add	r0, sp, #80	; 0x50
    448e:	f840 3d44 	str.w	r3, [r0, #-68]!
		INIT_NAMBUF(fs);
		res = follow_path(&dj, path);			/* Follow the file path */
    4492:	9901      	ldr	r1, [sp, #4]
    4494:	f7ff f85f 	bl	3556 <follow_path>
		if (res == FR_OK) res = FR_EXIST;		/* Name collision? */
    4498:	b140      	cbz	r0, 44ac <f_mkdir+0x3e>
		if (FF_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT)) {	/* Invalid name? */
    449a:	2804      	cmp	r0, #4
    449c:	d15e      	bne.n	455c <f_mkdir+0xee>
    449e:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
    44a2:	f013 0f20 	tst.w	r3, #32
    44a6:	d064      	beq.n	4572 <f_mkdir+0x104>
			res = FR_INVALID_NAME;
    44a8:	3002      	adds	r0, #2
    44aa:	e057      	b.n	455c <f_mkdir+0xee>
	res = find_volume(&path, &fs, FA_WRITE);	/* Get logical drive */
	if (res == FR_OK) {
		dj.obj.fs = fs;
		INIT_NAMBUF(fs);
		res = follow_path(&dj, path);			/* Follow the file path */
		if (res == FR_OK) res = FR_EXIST;		/* Name collision? */
    44ac:	2008      	movs	r0, #8
    44ae:	e055      	b.n	455c <f_mkdir+0xee>
		if (res == FR_NO_FILE) {				/* It is clear to create a new directory */
			sobj.fs = fs;						/* New object id to create a new chain */
			dcl = create_chain(&sobj, 0);		/* Allocate a cluster for the new directory */
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster? */
			if (dcl == 1) res = FR_INT_ERR;		/* Any insanity? */
    44b0:	2d01      	cmp	r5, #1
    44b2:	d006      	beq.n	44c2 <f_mkdir+0x54>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;	/* Disk error? */
    44b4:	f1a5 3eff 	sub.w	lr, r5, #4294967295
    44b8:	f1de 0400 	rsbs	r4, lr, #0
    44bc:	eb44 040e 	adc.w	r4, r4, lr
    44c0:	e002      	b.n	44c8 <f_mkdir+0x5a>
		if (res == FR_NO_FILE) {				/* It is clear to create a new directory */
			sobj.fs = fs;						/* New object id to create a new chain */
			dcl = create_chain(&sobj, 0);		/* Allocate a cluster for the new directory */
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster? */
			if (dcl == 1) res = FR_INT_ERR;		/* Any insanity? */
    44c2:	2402      	movs	r4, #2
    44c4:	e000      	b.n	44c8 <f_mkdir+0x5a>
		}
		if (res == FR_NO_FILE) {				/* It is clear to create a new directory */
			sobj.fs = fs;						/* New object id to create a new chain */
			dcl = create_chain(&sobj, 0);		/* Allocate a cluster for the new directory */
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster? */
    44c6:	2407      	movs	r4, #7
			if (dcl == 1) res = FR_INT_ERR;		/* Any insanity? */
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;	/* Disk error? */
			tm = GET_FATTIME();
    44c8:	f7fb ff8a 	bl	3e0 <get_fattime>
    44cc:	4680      	mov	r8, r0
			if (res == FR_OK) {
    44ce:	2c00      	cmp	r4, #0
    44d0:	d146      	bne.n	4560 <f_mkdir+0xf2>
				res = dir_clear(fs, dcl);		/* Clean up the new table */
    44d2:	9813      	ldr	r0, [sp, #76]	; 0x4c
    44d4:	4629      	mov	r1, r5
    44d6:	f7fe fba7 	bl	2c28 <dir_clear>
				if (res == FR_OK) {
    44da:	4604      	mov	r4, r0
    44dc:	2800      	cmp	r0, #0
    44de:	d13f      	bne.n	4560 <f_mkdir+0xf2>
					if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {	/* Create dot entries (FAT only) */
						mem_set(fs->win + DIR_Name, ' ', 11);	/* Create "." entry */
    44e0:	9813      	ldr	r0, [sp, #76]	; 0x4c
    44e2:	220b      	movs	r2, #11
    44e4:	3034      	adds	r0, #52	; 0x34
    44e6:	2120      	movs	r1, #32
    44e8:	f7fe fa72 	bl	29d0 <mem_set>
						fs->win[DIR_Name] = '.';
    44ec:	9813      	ldr	r0, [sp, #76]	; 0x4c
    44ee:	342e      	adds	r4, #46	; 0x2e
						fs->win[DIR_Attr] = AM_DIR;
    44f0:	2710      	movs	r7, #16
			if (res == FR_OK) {
				res = dir_clear(fs, dcl);		/* Clean up the new table */
				if (res == FR_OK) {
					if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {	/* Create dot entries (FAT only) */
						mem_set(fs->win + DIR_Name, ' ', 11);	/* Create "." entry */
						fs->win[DIR_Name] = '.';
    44f2:	f880 4034 	strb.w	r4, [r0, #52]	; 0x34
						fs->win[DIR_Attr] = AM_DIR;
    44f6:	f880 703f 	strb.w	r7, [r0, #63]	; 0x3f
						st_dword(fs->win + DIR_ModTime, tm);
    44fa:	4641      	mov	r1, r8
    44fc:	304a      	adds	r0, #74	; 0x4a
    44fe:	f7fe fa55 	bl	29ac <st_dword>
						st_clust(fs, fs->win, dcl);
    4502:	9813      	ldr	r0, [sp, #76]	; 0x4c
    4504:	462a      	mov	r2, r5
    4506:	f100 0134 	add.w	r1, r0, #52	; 0x34
    450a:	f7fe fe57 	bl	31bc <st_clust.clone.1>
						mem_cpy(fs->win + SZDIRE, fs->win, SZDIRE); /* Create ".." entry */
    450e:	9913      	ldr	r1, [sp, #76]	; 0x4c
    4510:	2220      	movs	r2, #32
    4512:	f101 0054 	add.w	r0, r1, #84	; 0x54
    4516:	3134      	adds	r1, #52	; 0x34
    4518:	f7fe fa52 	bl	29c0 <mem_cpy>
						fs->win[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
    451c:	9813      	ldr	r0, [sp, #76]	; 0x4c
						st_clust(fs, fs->win + SZDIRE, pcl);
						fs->wflag = 1;
    451e:	2601      	movs	r6, #1
						fs->win[DIR_Name] = '.';
						fs->win[DIR_Attr] = AM_DIR;
						st_dword(fs->win + DIR_ModTime, tm);
						st_clust(fs, fs->win, dcl);
						mem_cpy(fs->win + SZDIRE, fs->win, SZDIRE); /* Create ".." entry */
						fs->win[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
    4520:	f880 4055 	strb.w	r4, [r0, #85]	; 0x55
						st_clust(fs, fs->win + SZDIRE, pcl);
    4524:	f100 0154 	add.w	r1, r0, #84	; 0x54
    4528:	9a05      	ldr	r2, [sp, #20]
    452a:	f7fe fe47 	bl	31bc <st_clust.clone.1>
						fs->wflag = 1;
    452e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
					}
					res = dir_register(&dj);	/* Register the object to the parent directoy */
    4530:	a803      	add	r0, sp, #12
						st_dword(fs->win + DIR_ModTime, tm);
						st_clust(fs, fs->win, dcl);
						mem_cpy(fs->win + SZDIRE, fs->win, SZDIRE); /* Create ".." entry */
						fs->win[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
						st_clust(fs, fs->win + SZDIRE, pcl);
						fs->wflag = 1;
    4532:	70de      	strb	r6, [r3, #3]
					}
					res = dir_register(&dj);	/* Register the object to the parent directoy */
    4534:	f7ff f96b 	bl	380e <dir_register>
				}
			}
			if (res == FR_OK) {
    4538:	4604      	mov	r4, r0
    453a:	b988      	cbnz	r0, 4560 <f_mkdir+0xf2>
					fs->dirbuf[XDIR_Attr] = AM_DIR;				/* Attribute */
					res = store_xdir(&dj);
				} else
#endif
				{
					st_dword(dj.dir + DIR_ModTime, tm);	/* Created time */
    453c:	980a      	ldr	r0, [sp, #40]	; 0x28
    453e:	4641      	mov	r1, r8
    4540:	3016      	adds	r0, #22
    4542:	f7fe fa33 	bl	29ac <st_dword>
					st_clust(fs, dj.dir, dcl);			/* Table start cluster */
    4546:	9813      	ldr	r0, [sp, #76]	; 0x4c
    4548:	990a      	ldr	r1, [sp, #40]	; 0x28
    454a:	462a      	mov	r2, r5
    454c:	f7fe fe36 	bl	31bc <st_clust.clone.1>
					dj.dir[DIR_Attr] = AM_DIR;			/* Attribute */
    4550:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    4552:	72df      	strb	r7, [r3, #11]
					fs->wflag = 1;
    4554:	9813      	ldr	r0, [sp, #76]	; 0x4c
    4556:	70c6      	strb	r6, [r0, #3]
				}
				if (res == FR_OK) {
					res = sync_fs(fs);
    4558:	f7fe fb8f 	bl	2c7a <sync_fs>
    455c:	4604      	mov	r4, r0
    455e:	e004      	b.n	456a <f_mkdir+0xfc>
				}
			} else {
				remove_chain(&sobj, dcl, 0);		/* Could not register, remove the allocated cluster */
    4560:	a80f      	add	r0, sp, #60	; 0x3c
    4562:	4629      	mov	r1, r5
    4564:	2200      	movs	r2, #0
    4566:	f7ff f901 	bl	376c <remove_chain.clone.4>
		}
		FREE_NAMBUF();
	}

	LEAVE_FF(fs, res);
}
    456a:	4620      	mov	r0, r4
    456c:	b014      	add	sp, #80	; 0x50
    456e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (res == FR_OK) res = FR_EXIST;		/* Name collision? */
		if (FF_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT)) {	/* Invalid name? */
			res = FR_INVALID_NAME;
		}
		if (res == FR_NO_FILE) {				/* It is clear to create a new directory */
			sobj.fs = fs;						/* New object id to create a new chain */
    4572:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    4574:	a814      	add	r0, sp, #80	; 0x50
    4576:	f840 3d14 	str.w	r3, [r0, #-20]!
			dcl = create_chain(&sobj, 0);		/* Allocate a cluster for the new directory */
    457a:	4621      	mov	r1, r4
    457c:	f7fe feda 	bl	3334 <create_chain.clone.3>
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster? */
    4580:	4605      	mov	r5, r0
    4582:	2800      	cmp	r0, #0
    4584:	d09f      	beq.n	44c6 <f_mkdir+0x58>
    4586:	e793      	b.n	44b0 <f_mkdir+0x42>

00004588 <f_rename>:

FRESULT f_rename (
	const TCHAR* path_old,	/* Pointer to the object name to be renamed */
	const TCHAR* path_new	/* Pointer to the new name */
)
{
    4588:	b570      	push	{r4, r5, r6, lr}
    458a:	b0a4      	sub	sp, #144	; 0x90
    458c:	9001      	str	r0, [sp, #4]
    458e:	a824      	add	r0, sp, #144	; 0x90
    4590:	f840 1d90 	str.w	r1, [r0, #-144]!
	BYTE buf[FF_FS_EXFAT ? SZDIRE * 2 : SZDIRE], *dir;
	DWORD dw;
	DEF_NAMBUF


	get_ldnumber(&path_new);						/* Snip the drive number of new name off */
    4594:	4668      	mov	r0, sp
    4596:	f7fe fb00 	bl	2b9a <get_ldnumber>
	res = find_volume(&path_old, &fs, FA_WRITE);	/* Get logical drive of the old object */
    459a:	a801      	add	r0, sp, #4
    459c:	a923      	add	r1, sp, #140	; 0x8c
    459e:	2202      	movs	r2, #2
    45a0:	f7fe fc1a 	bl	2dd8 <find_volume>
	if (res == FR_OK) {
    45a4:	2800      	cmp	r0, #0
    45a6:	d15f      	bne.n	4668 <f_rename+0xe0>
		djo.obj.fs = fs;
    45a8:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    45aa:	ac24      	add	r4, sp, #144	; 0x90
    45ac:	f844 3d54 	str.w	r3, [r4, #-84]!
		INIT_NAMBUF(fs);
		res = follow_path(&djo, path_old);		/* Check old object */
    45b0:	4620      	mov	r0, r4
    45b2:	9901      	ldr	r1, [sp, #4]
    45b4:	f7fe ffcf 	bl	3556 <follow_path>
		if (res == FR_OK && (djo.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check validity of name */
    45b8:	2800      	cmp	r0, #0
    45ba:	d155      	bne.n	4668 <f_rename+0xe0>
    45bc:	f89d 3067 	ldrb.w	r3, [sp, #103]	; 0x67
    45c0:	f013 0fa0 	tst.w	r3, #160	; 0xa0
    45c4:	d052      	beq.n	466c <f_rename+0xe4>
    45c6:	3006      	adds	r0, #6
    45c8:	e04e      	b.n	4668 <f_rename+0xe0>
			{	/* At FAT/FAT32 volume */
				mem_cpy(buf, djo.dir, SZDIRE);			/* Save directory entry of the object */
				mem_cpy(&djn, &djo, sizeof (DIR));		/* Duplicate the directory object */
				res = follow_path(&djn, path_new);		/* Make sure if new object name is not in use */
				if (res == FR_OK) {						/* Is new name already in use by any other object? */
					res = (djn.obj.sclust == djo.obj.sclust && djn.dptr == djo.dptr) ? FR_NO_FILE : FR_EXIST;
    45ca:	9b11      	ldr	r3, [sp, #68]	; 0x44
    45cc:	9a05      	ldr	r2, [sp, #20]
    45ce:	429a      	cmp	r2, r3
    45d0:	d143      	bne.n	465a <f_rename+0xd2>
    45d2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    45d4:	9a07      	ldr	r2, [sp, #28]
    45d6:	429a      	cmp	r2, r3
    45d8:	d13f      	bne.n	465a <f_rename+0xd2>
    45da:	e001      	b.n	45e0 <f_rename+0x58>
				}
				if (res == FR_NO_FILE) { 				/* It is a valid path and no name collision */
    45dc:	2804      	cmp	r0, #4
    45de:	d143      	bne.n	4668 <f_rename+0xe0>
					res = dir_register(&djn);			/* Register the new entry */
    45e0:	a803      	add	r0, sp, #12
    45e2:	f7ff f914 	bl	380e <dir_register>
					if (res == FR_OK) {
    45e6:	2800      	cmp	r0, #0
    45e8:	d13e      	bne.n	4668 <f_rename+0xe0>
						dir = djn.dir;					/* Copy directory entry of the object except name */
    45ea:	9c0a      	ldr	r4, [sp, #40]	; 0x28
						mem_cpy(dir + 13, buf + 13, SZDIRE - 13);
    45ec:	2213      	movs	r2, #19
    45ee:	f104 000d 	add.w	r0, r4, #13
    45f2:	f10d 0179 	add.w	r1, sp, #121	; 0x79
    45f6:	f7fe f9e3 	bl	29c0 <mem_cpy>
						dir[DIR_Attr] = buf[DIR_Attr];
    45fa:	f89d 3077 	ldrb.w	r3, [sp, #119]	; 0x77
						if (!(dir[DIR_Attr] & AM_DIR)) dir[DIR_Attr] |= AM_ARC;	/* Set archive attribute if it is a file */
    45fe:	f013 0f10 	tst.w	r3, #16
				if (res == FR_NO_FILE) { 				/* It is a valid path and no name collision */
					res = dir_register(&djn);			/* Register the new entry */
					if (res == FR_OK) {
						dir = djn.dir;					/* Copy directory entry of the object except name */
						mem_cpy(dir + 13, buf + 13, SZDIRE - 13);
						dir[DIR_Attr] = buf[DIR_Attr];
    4602:	72e3      	strb	r3, [r4, #11]
						if (!(dir[DIR_Attr] & AM_DIR)) dir[DIR_Attr] |= AM_ARC;	/* Set archive attribute if it is a file */
    4604:	bf04      	itt	eq
    4606:	f043 0320 	orreq.w	r3, r3, #32
    460a:	72e3      	strbeq	r3, [r4, #11]
						fs->wflag = 1;
    460c:	9e23      	ldr	r6, [sp, #140]	; 0x8c
    460e:	2501      	movs	r5, #1
    4610:	70f5      	strb	r5, [r6, #3]
						if ((dir[DIR_Attr] & AM_DIR) && djo.obj.sclust != djn.obj.sclust) {	/* Update .. entry in the sub-directory if needed */
    4612:	7ae3      	ldrb	r3, [r4, #11]
    4614:	f013 0f10 	tst.w	r3, #16
    4618:	d039      	beq.n	468e <f_rename+0x106>
    461a:	9b05      	ldr	r3, [sp, #20]
    461c:	9a11      	ldr	r2, [sp, #68]	; 0x44
    461e:	429a      	cmp	r2, r3
    4620:	d035      	beq.n	468e <f_rename+0x106>
							dw = clst2sect(fs, ld_clust(fs, dir));
    4622:	4621      	mov	r1, r4
    4624:	7830      	ldrb	r0, [r6, #0]
    4626:	f7fe fdb7 	bl	3198 <ld_clust.clone.0>
    462a:	4601      	mov	r1, r0
    462c:	4630      	mov	r0, r6
    462e:	f7fe fa0a 	bl	2a46 <clst2sect>
							if (dw == 0) {
    4632:	4601      	mov	r1, r0
    4634:	b198      	cbz	r0, 465e <f_rename+0xd6>
								res = FR_INT_ERR;
							} else {
/* Start of critical section where an interruption can cause a cross-link */
								res = move_window(fs, dw);
    4636:	4630      	mov	r0, r6
    4638:	f7fe fb7c 	bl	2d34 <move_window>
								dir = fs->win + SZDIRE * 1;	/* Ptr to .. entry */
    463c:	9b23      	ldr	r3, [sp, #140]	; 0x8c
								if (res == FR_OK && dir[1] == '.') {
    463e:	b998      	cbnz	r0, 4668 <f_rename+0xe0>
    4640:	f893 2055 	ldrb.w	r2, [r3, #85]	; 0x55
    4644:	2a2e      	cmp	r2, #46	; 0x2e
    4646:	d122      	bne.n	468e <f_rename+0x106>
									st_clust(fs, dir, djn.obj.sclust);
    4648:	4618      	mov	r0, r3
    464a:	f103 0154 	add.w	r1, r3, #84	; 0x54
    464e:	9a05      	ldr	r2, [sp, #20]
    4650:	f7fe fdb4 	bl	31bc <st_clust.clone.1>
									fs->wflag = 1;
    4654:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    4656:	70dd      	strb	r5, [r3, #3]
    4658:	e019      	b.n	468e <f_rename+0x106>
			{	/* At FAT/FAT32 volume */
				mem_cpy(buf, djo.dir, SZDIRE);			/* Save directory entry of the object */
				mem_cpy(&djn, &djo, sizeof (DIR));		/* Duplicate the directory object */
				res = follow_path(&djn, path_new);		/* Make sure if new object name is not in use */
				if (res == FR_OK) {						/* Is new name already in use by any other object? */
					res = (djn.obj.sclust == djo.obj.sclust && djn.dptr == djo.dptr) ? FR_NO_FILE : FR_EXIST;
    465a:	2008      	movs	r0, #8
    465c:	e004      	b.n	4668 <f_rename+0xe0>
						if (!(dir[DIR_Attr] & AM_DIR)) dir[DIR_Attr] |= AM_ARC;	/* Set archive attribute if it is a file */
						fs->wflag = 1;
						if ((dir[DIR_Attr] & AM_DIR) && djo.obj.sclust != djn.obj.sclust) {	/* Update .. entry in the sub-directory if needed */
							dw = clst2sect(fs, ld_clust(fs, dir));
							if (dw == 0) {
								res = FR_INT_ERR;
    465e:	2002      	movs	r0, #2
    4660:	e002      	b.n	4668 <f_rename+0xe0>
				}
			}
			if (res == FR_OK) {
				res = dir_remove(&djo);		/* Remove old entry */
				if (res == FR_OK) {
					res = sync_fs(fs);
    4662:	9823      	ldr	r0, [sp, #140]	; 0x8c
    4664:	f7fe fb09 	bl	2c7a <sync_fs>
		}
		FREE_NAMBUF();
	}

	LEAVE_FF(fs, res);
}
    4668:	b024      	add	sp, #144	; 0x90
    466a:	bd70      	pop	{r4, r5, r6, pc}
					}
				}
			} else
#endif
			{	/* At FAT/FAT32 volume */
				mem_cpy(buf, djo.dir, SZDIRE);			/* Save directory entry of the object */
    466c:	a81b      	add	r0, sp, #108	; 0x6c
    466e:	9916      	ldr	r1, [sp, #88]	; 0x58
    4670:	2220      	movs	r2, #32
    4672:	f7fe f9a5 	bl	29c0 <mem_cpy>
				mem_cpy(&djn, &djo, sizeof (DIR));		/* Duplicate the directory object */
    4676:	a803      	add	r0, sp, #12
    4678:	4621      	mov	r1, r4
    467a:	2230      	movs	r2, #48	; 0x30
    467c:	f7fe f9a0 	bl	29c0 <mem_cpy>
				res = follow_path(&djn, path_new);		/* Make sure if new object name is not in use */
    4680:	a803      	add	r0, sp, #12
    4682:	9900      	ldr	r1, [sp, #0]
    4684:	f7fe ff67 	bl	3556 <follow_path>
				if (res == FR_OK) {						/* Is new name already in use by any other object? */
    4688:	2800      	cmp	r0, #0
    468a:	d09e      	beq.n	45ca <f_rename+0x42>
    468c:	e7a6      	b.n	45dc <f_rename+0x54>
						}
					}
				}
			}
			if (res == FR_OK) {
				res = dir_remove(&djo);		/* Remove old entry */
    468e:	a80f      	add	r0, sp, #60	; 0x3c
    4690:	f7fe fd74 	bl	317c <dir_remove>
				if (res == FR_OK) {
    4694:	2800      	cmp	r0, #0
    4696:	d1e7      	bne.n	4668 <f_rename+0xe0>
    4698:	e7e3      	b.n	4662 <f_rename+0xda>

0000469a <f_chmod>:
FRESULT f_chmod (
	const TCHAR* path,	/* Pointer to the file path */
	BYTE attr,			/* Attribute bits */
	BYTE mask			/* Attribute mask to change */
)
{
    469a:	b530      	push	{r4, r5, lr}
    469c:	b091      	sub	sp, #68	; 0x44
    469e:	ab10      	add	r3, sp, #64	; 0x40
    46a0:	f843 0d3c 	str.w	r0, [r3, #-60]!
    46a4:	460c      	mov	r4, r1
    46a6:	4615      	mov	r5, r2
	DIR dj;
	FATFS *fs;
	DEF_NAMBUF


	res = find_volume(&path, &fs, FA_WRITE);	/* Get logical drive */
    46a8:	4618      	mov	r0, r3
    46aa:	a90f      	add	r1, sp, #60	; 0x3c
    46ac:	2202      	movs	r2, #2
    46ae:	f7fe fb93 	bl	2dd8 <find_volume>
	if (res == FR_OK) {
    46b2:	b968      	cbnz	r0, 46d0 <f_chmod+0x36>
		dj.obj.fs = fs;
    46b4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    46b6:	a810      	add	r0, sp, #64	; 0x40
    46b8:	f840 3d34 	str.w	r3, [r0, #-52]!
		INIT_NAMBUF(fs);
		res = follow_path(&dj, path);	/* Follow the file path */
    46bc:	9901      	ldr	r1, [sp, #4]
    46be:	f7fe ff4a 	bl	3556 <follow_path>
		if (res == FR_OK && (dj.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check object validity */
    46c2:	b928      	cbnz	r0, 46d0 <f_chmod+0x36>
    46c4:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
    46c8:	f013 0fa0 	tst.w	r3, #160	; 0xa0
    46cc:	d002      	beq.n	46d4 <f_chmod+0x3a>
    46ce:	3006      	adds	r0, #6
		}
		FREE_NAMBUF();
	}

	LEAVE_FF(fs, res);
}
    46d0:	b011      	add	sp, #68	; 0x44
    46d2:	bd30      	pop	{r4, r5, pc}
				fs->dirbuf[XDIR_Attr] = (attr & mask) | (fs->dirbuf[XDIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
				res = store_xdir(&dj);
			} else
#endif
			{
				dj.dir[DIR_Attr] = (attr & mask) | (dj.dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
    46d4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
		dj.obj.fs = fs;
		INIT_NAMBUF(fs);
		res = follow_path(&dj, path);	/* Follow the file path */
		if (res == FR_OK && (dj.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check object validity */
		if (res == FR_OK) {
			mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
    46d6:	f005 0527 	and.w	r5, r5, #39	; 0x27
				fs->dirbuf[XDIR_Attr] = (attr & mask) | (fs->dirbuf[XDIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
				res = store_xdir(&dj);
			} else
#endif
			{
				dj.dir[DIR_Attr] = (attr & mask) | (dj.dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
    46da:	7ada      	ldrb	r2, [r3, #11]
    46dc:	ea22 0205 	bic.w	r2, r2, r5
    46e0:	4025      	ands	r5, r4
    46e2:	ea42 0505 	orr.w	r5, r2, r5
    46e6:	72dd      	strb	r5, [r3, #11]
				fs->wflag = 1;
    46e8:	980f      	ldr	r0, [sp, #60]	; 0x3c
    46ea:	2301      	movs	r3, #1
    46ec:	70c3      	strb	r3, [r0, #3]
			}
			if (res == FR_OK) {
				res = sync_fs(fs);
    46ee:	f7fe fac4 	bl	2c7a <sync_fs>
    46f2:	e7ed      	b.n	46d0 <f_chmod+0x36>

000046f4 <f_utime>:

FRESULT f_utime (
	const TCHAR* path,	/* Pointer to the file/directory name */
	const FILINFO* fno	/* Pointer to the timestamp to be set */
)
{
    46f4:	b510      	push	{r4, lr}
    46f6:	b090      	sub	sp, #64	; 0x40
    46f8:	ab10      	add	r3, sp, #64	; 0x40
    46fa:	f843 0d3c 	str.w	r0, [r3, #-60]!
    46fe:	460c      	mov	r4, r1
	DIR dj;
	FATFS *fs;
	DEF_NAMBUF


	res = find_volume(&path, &fs, FA_WRITE);	/* Get logical drive */
    4700:	4618      	mov	r0, r3
    4702:	a90f      	add	r1, sp, #60	; 0x3c
    4704:	2202      	movs	r2, #2
    4706:	f7fe fb67 	bl	2dd8 <find_volume>
	if (res == FR_OK) {
    470a:	b968      	cbnz	r0, 4728 <f_utime+0x34>
		dj.obj.fs = fs;
    470c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    470e:	a810      	add	r0, sp, #64	; 0x40
    4710:	f840 3d34 	str.w	r3, [r0, #-52]!
		INIT_NAMBUF(fs);
		res = follow_path(&dj, path);	/* Follow the file path */
    4714:	9901      	ldr	r1, [sp, #4]
    4716:	f7fe ff1e 	bl	3556 <follow_path>
		if (res == FR_OK && (dj.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check object validity */
    471a:	b928      	cbnz	r0, 4728 <f_utime+0x34>
    471c:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
    4720:	f013 0fa0 	tst.w	r3, #160	; 0xa0
    4724:	d002      	beq.n	472c <f_utime+0x38>
    4726:	3006      	adds	r0, #6
		}
		FREE_NAMBUF();
	}

	LEAVE_FF(fs, res);
}
    4728:	b010      	add	sp, #64	; 0x40
    472a:	bd10      	pop	{r4, pc}
				st_dword(fs->dirbuf + XDIR_ModTime, (DWORD)fno->fdate << 16 | fno->ftime);
				res = store_xdir(&dj);
			} else
#endif
			{
				st_dword(dj.dir + DIR_ModTime, (DWORD)fno->fdate << 16 | fno->ftime);
    472c:	88e3      	ldrh	r3, [r4, #6]
    472e:	88a1      	ldrh	r1, [r4, #4]
    4730:	980a      	ldr	r0, [sp, #40]	; 0x28
    4732:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
    4736:	3016      	adds	r0, #22
    4738:	f7fe f938 	bl	29ac <st_dword>
				fs->wflag = 1;
    473c:	980f      	ldr	r0, [sp, #60]	; 0x3c
    473e:	2301      	movs	r3, #1
    4740:	70c3      	strb	r3, [r0, #3]
			}
			if (res == FR_OK) {
				res = sync_fs(fs);
    4742:	f7fe fa9a 	bl	2c7a <sync_fs>
    4746:	e7ef      	b.n	4728 <f_utime+0x34>

00004748 <f_getlabel>:
FRESULT f_getlabel (
	const TCHAR* path,	/* Logical drive number */
	TCHAR* label,		/* Buffer to store the volume label */
	DWORD* vsn			/* Variable to store the volume serial number */
)
{
    4748:	b570      	push	{r4, r5, r6, lr}
    474a:	b090      	sub	sp, #64	; 0x40
    474c:	ab10      	add	r3, sp, #64	; 0x40
    474e:	f843 0d3c 	str.w	r0, [r3, #-60]!
    4752:	460c      	mov	r4, r1
    4754:	4615      	mov	r5, r2
	FATFS *fs;
	UINT si, di;
	WCHAR wc;

	/* Get logical drive */
	res = find_volume(&path, &fs, 0);
    4756:	4618      	mov	r0, r3
    4758:	a90f      	add	r1, sp, #60	; 0x3c
    475a:	2200      	movs	r2, #0
    475c:	f7fe fb3c 	bl	2dd8 <find_volume>

	/* Get volume label */
	if (res == FR_OK && label) {
    4760:	4606      	mov	r6, r0
    4762:	2800      	cmp	r0, #0
    4764:	d138      	bne.n	47d8 <f_getlabel+0x90>
    4766:	b1fc      	cbz	r4, 47a8 <f_getlabel+0x60>
		dj.obj.fs = fs; dj.obj.sclust = 0;	/* Open root directory */
    4768:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    476a:	9005      	str	r0, [sp, #20]
		res = dir_sdi(&dj, 0);
    476c:	4631      	mov	r1, r6
    476e:	a803      	add	r0, sp, #12
	/* Get logical drive */
	res = find_volume(&path, &fs, 0);

	/* Get volume label */
	if (res == FR_OK && label) {
		dj.obj.fs = fs; dj.obj.sclust = 0;	/* Open root directory */
    4770:	9303      	str	r3, [sp, #12]
		res = dir_sdi(&dj, 0);
    4772:	f7fe fd92 	bl	329a <dir_sdi>
		if (res == FR_OK) {
    4776:	b998      	cbnz	r0, 47a0 <f_getlabel+0x58>
		 	res = DIR_READ_LABEL(&dj);		/* Find a volume label entry */
    4778:	a803      	add	r0, sp, #12
    477a:	2101      	movs	r1, #1
    477c:	f7fe feb9 	bl	34f2 <dir_read>
		 	if (res == FR_OK) {
    4780:	b970      	cbnz	r0, 47a0 <f_getlabel+0x58>
				} else
#endif
				{
					si = di = 0;		/* Extract volume label from AM_VOL entry */
					while (si < 11) {
						wc = dj.dir[si++];
    4782:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    4784:	4633      	mov	r3, r6
						wc = ff_oem2uni(wc, CODEPAGE);					/* Convert it into Unicode */
						if (wc != 0) wc = put_utf(wc, &label[di], 4);	/* Put it in Unicode */
						if (wc == 0) { di = 0; break; }
						di += wc;
#else									/* ANSI/OEM output */
						label[di++] = (TCHAR)wc;
    4786:	5cd1      	ldrb	r1, [r2, r3]
    4788:	54e1      	strb	r1, [r4, r3]
    478a:	3301      	adds	r3, #1
					label[di] = 0;
				} else
#endif
				{
					si = di = 0;		/* Extract volume label from AM_VOL entry */
					while (si < 11) {
    478c:	2b0b      	cmp	r3, #11
    478e:	d1fa      	bne.n	4786 <f_getlabel+0x3e>
#else									/* ANSI/OEM output */
						label[di++] = (TCHAR)wc;
#endif
					}
					do {				/* Truncate trailing spaces */
						label[di] = 0;
    4790:	2200      	movs	r2, #0
    4792:	54e2      	strb	r2, [r4, r3]
						if (di == 0) break;
    4794:	b143      	cbz	r3, 47a8 <f_getlabel+0x60>
					} while (label[--di] == ' ');
    4796:	3b01      	subs	r3, #1
    4798:	5ce2      	ldrb	r2, [r4, r3]
    479a:	2a20      	cmp	r2, #32
    479c:	d0f8      	beq.n	4790 <f_getlabel+0x48>
    479e:	e003      	b.n	47a8 <f_getlabel+0x60>
				}
			}
		}
		if (res == FR_NO_FILE) {	/* No label entry and return nul string */
    47a0:	2804      	cmp	r0, #4
    47a2:	d118      	bne.n	47d6 <f_getlabel+0x8e>
			label[0] = 0;
    47a4:	2300      	movs	r3, #0
    47a6:	7023      	strb	r3, [r4, #0]
			res = FR_OK;
		}
	}

	/* Get volume serial number */
	if (res == FR_OK && vsn) {
    47a8:	b1b5      	cbz	r5, 47d8 <f_getlabel+0x90>
		res = move_window(fs, fs->volbase);
    47aa:	980f      	ldr	r0, [sp, #60]	; 0x3c
    47ac:	6a01      	ldr	r1, [r0, #32]
    47ae:	f7fe fac1 	bl	2d34 <move_window>
		if (res == FR_OK) {
    47b2:	4606      	mov	r6, r0
    47b4:	b980      	cbnz	r0, 47d8 <f_getlabel+0x90>
			switch (fs->fs_type) {
    47b6:	980f      	ldr	r0, [sp, #60]	; 0x3c
    47b8:	7803      	ldrb	r3, [r0, #0]
    47ba:	3b03      	subs	r3, #3
    47bc:	b2db      	uxtb	r3, r3
    47be:	2b01      	cmp	r3, #1
    47c0:	bf9a      	itte	ls
    47c2:	4a07      	ldrls	r2, [pc, #28]	; (47e0 <f_getlabel+0x98>)
    47c4:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
    47c8:	2327      	movhi	r3, #39	; 0x27
				di = BS_VolID32; break;

			default:
				di = BS_VolID;
			}
			*vsn = ld_dword(fs->win + di);
    47ca:	18c0      	adds	r0, r0, r3
    47cc:	3034      	adds	r0, #52	; 0x34
    47ce:	f7fe f8de 	bl	298e <ld_dword>
    47d2:	6028      	str	r0, [r5, #0]
    47d4:	e000      	b.n	47d8 <f_getlabel+0x90>
						if (di == 0) break;
					} while (label[--di] == ' ');
				}
			}
		}
		if (res == FR_NO_FILE) {	/* No label entry and return nul string */
    47d6:	4606      	mov	r6, r0
			*vsn = ld_dword(fs->win + di);
		}
	}

	LEAVE_FF(fs, res);
}
    47d8:	4630      	mov	r0, r6
    47da:	b010      	add	sp, #64	; 0x40
    47dc:	bd70      	pop	{r4, r5, r6, pc}
    47de:	bf00      	nop
    47e0:	00005ca4 	.word	0x00005ca4

000047e4 <f_setlabel>:
/*-----------------------------------------------------------------------*/

FRESULT f_setlabel (
	const TCHAR* label	/* Volume label to set with heading logical drive number */
)
{
    47e4:	b5f0      	push	{r4, r5, r6, r7, lr}
    47e6:	b097      	sub	sp, #92	; 0x5c
    47e8:	ab16      	add	r3, sp, #88	; 0x58
    47ea:	f843 0d54 	str.w	r0, [r3, #-84]!
#if FF_USE_LFN
	DWORD dc;
#endif

	/* Get logical drive */
	res = find_volume(&label, &fs, FA_WRITE);
    47ee:	4618      	mov	r0, r3
    47f0:	a915      	add	r1, sp, #84	; 0x54
    47f2:	2202      	movs	r2, #2
    47f4:	f7fe faf0 	bl	2dd8 <find_volume>
    47f8:	4604      	mov	r4, r0
    47fa:	4605      	mov	r5, r0
	if (res != FR_OK) LEAVE_FF(fs, res);
    47fc:	2800      	cmp	r0, #0
    47fe:	f040 8081 	bne.w	4904 <f_setlabel+0x120>
			st_word(dirvn + di * 2, (WCHAR)dc); di++;
		}
	} else
#endif
	{	/* On the FAT/FAT32 volume */
		mem_set(dirvn, ' ', 11);
    4802:	a80f      	add	r0, sp, #60	; 0x3c
    4804:	2120      	movs	r1, #32
    4806:	220b      	movs	r2, #11
    4808:	f7fe f8e2 	bl	29d0 <mem_set>
		di = 0;
		while ((UINT)*label >= ' ') {	/* Create volume label */
    480c:	e033      	b.n	4876 <f_setlabel+0x92>
#if FF_USE_LFN
			dc = tchar2uni(&label);
			wc = (dc < 0x10000) ? ff_uni2oem(ff_wtoupper(dc), CODEPAGE) : 0;
#else									/* ANSI/OEM input */
			wc = (BYTE)*label++;
    480e:	1c77      	adds	r7, r6, #1
			if (dbc_1st((BYTE)wc)) wc = dbc_2nd((BYTE)*label) ? wc << 8 | (BYTE)*label++ : 0;
    4810:	4628      	mov	r0, r5
		while ((UINT)*label >= ' ') {	/* Create volume label */
#if FF_USE_LFN
			dc = tchar2uni(&label);
			wc = (dc < 0x10000) ? ff_uni2oem(ff_wtoupper(dc), CODEPAGE) : 0;
#else									/* ANSI/OEM input */
			wc = (BYTE)*label++;
    4812:	9701      	str	r7, [sp, #4]
			if (dbc_1st((BYTE)wc)) wc = dbc_2nd((BYTE)*label) ? wc << 8 | (BYTE)*label++ : 0;
    4814:	f7fe f8f5 	bl	2a02 <dbc_1st>
    4818:	b150      	cbz	r0, 4830 <f_setlabel+0x4c>
    481a:	7876      	ldrb	r6, [r6, #1]
    481c:	4630      	mov	r0, r6
    481e:	f7fe f901 	bl	2a24 <dbc_2nd>
    4822:	b120      	cbz	r0, 482e <f_setlabel+0x4a>
    4824:	3701      	adds	r7, #1
    4826:	ea46 2505 	orr.w	r5, r6, r5, lsl #8
    482a:	9701      	str	r7, [sp, #4]
    482c:	e000      	b.n	4830 <f_setlabel+0x4c>
    482e:	4605      	mov	r5, r0
			if (IsLower(wc)) wc -= 0x20;		/* To upper ASCII characters */
    4830:	f1a5 0361 	sub.w	r3, r5, #97	; 0x61
    4834:	b29b      	uxth	r3, r3
    4836:	2b19      	cmp	r3, #25
    4838:	d802      	bhi.n	4840 <f_setlabel+0x5c>
    483a:	3d20      	subs	r5, #32
    483c:	b2ad      	uxth	r5, r5
    483e:	e001      	b.n	4844 <f_setlabel+0x60>
			if (ExCvt && wc >= 0x80) wc = ExCvt[wc - 0x80];	/* To upper extended characters (SBCS cfg) */
#elif FF_CODE_PAGE < 900
			if (wc >= 0x80) wc = ExCvt[wc - 0x80];	/* To upper extended characters (SBCS cfg) */
#endif
#endif
			if (wc == 0 || chk_chr(badchr + 0, (int)wc) || di >= (UINT)((wc >= 0x100) ? 10 : 11)) {	/* Reject invalid characters for volume label */
    4840:	2d00      	cmp	r5, #0
    4842:	d05c      	beq.n	48fe <f_setlabel+0x11a>
    4844:	4831      	ldr	r0, [pc, #196]	; (490c <f_setlabel+0x128>)
    4846:	4629      	mov	r1, r5
    4848:	f7fe f8d4 	bl	29f4 <chk_chr>
    484c:	2800      	cmp	r0, #0
    484e:	d156      	bne.n	48fe <f_setlabel+0x11a>
    4850:	2dff      	cmp	r5, #255	; 0xff
    4852:	bf94      	ite	ls
    4854:	230b      	movls	r3, #11
    4856:	230a      	movhi	r3, #10
    4858:	429c      	cmp	r4, r3
    485a:	d250      	bcs.n	48fe <f_setlabel+0x11a>
				LEAVE_FF(fs, FR_INVALID_NAME);
			}
			if (wc >= 0x100) dirvn[di++] = (BYTE)(wc >> 8);
    485c:	2dff      	cmp	r5, #255	; 0xff
    485e:	d905      	bls.n	486c <f_setlabel+0x88>
    4860:	aa16      	add	r2, sp, #88	; 0x58
    4862:	1913      	adds	r3, r2, r4
    4864:	0a2a      	lsrs	r2, r5, #8
    4866:	f803 2c1c 	strb.w	r2, [r3, #-28]
    486a:	3401      	adds	r4, #1
			dirvn[di++] = (BYTE)wc;
    486c:	aa16      	add	r2, sp, #88	; 0x58
    486e:	1913      	adds	r3, r2, r4
    4870:	f803 5c1c 	strb.w	r5, [r3, #-28]
    4874:	3401      	adds	r4, #1
	} else
#endif
	{	/* On the FAT/FAT32 volume */
		mem_set(dirvn, ' ', 11);
		di = 0;
		while ((UINT)*label >= ' ') {	/* Create volume label */
    4876:	9e01      	ldr	r6, [sp, #4]
    4878:	7835      	ldrb	r5, [r6, #0]
    487a:	2d1f      	cmp	r5, #31
    487c:	d8c7      	bhi.n	480e <f_setlabel+0x2a>
				LEAVE_FF(fs, FR_INVALID_NAME);
			}
			if (wc >= 0x100) dirvn[di++] = (BYTE)(wc >> 8);
			dirvn[di++] = (BYTE)wc;
		}
		if (dirvn[0] == DDEM) LEAVE_FF(fs, FR_INVALID_NAME);	/* Reject illegal name (heading DDEM) */
    487e:	f89d 303c 	ldrb.w	r3, [sp, #60]	; 0x3c
    4882:	2be5      	cmp	r3, #229	; 0xe5
    4884:	d101      	bne.n	488a <f_setlabel+0xa6>
    4886:	e03a      	b.n	48fe <f_setlabel+0x11a>
		while (di && dirvn[di - 1] == ' ') di--;				/* Snip trailing spaces */
    4888:	3c01      	subs	r4, #1
    488a:	b12c      	cbz	r4, 4898 <f_setlabel+0xb4>
#if !FF_FS_READONLY
/*-----------------------------------------------------------------------*/
/* Set Volume Label                                                      */
/*-----------------------------------------------------------------------*/

FRESULT f_setlabel (
    488c:	aa16      	add	r2, sp, #88	; 0x58
    488e:	1913      	adds	r3, r2, r4
			}
			if (wc >= 0x100) dirvn[di++] = (BYTE)(wc >> 8);
			dirvn[di++] = (BYTE)wc;
		}
		if (dirvn[0] == DDEM) LEAVE_FF(fs, FR_INVALID_NAME);	/* Reject illegal name (heading DDEM) */
		while (di && dirvn[di - 1] == ' ') di--;				/* Snip trailing spaces */
    4890:	f813 3c1d 	ldrb.w	r3, [r3, #-29]
    4894:	2b20      	cmp	r3, #32
    4896:	d0f7      	beq.n	4888 <f_setlabel+0xa4>
	}

	/* Set volume label */
	dj.obj.fs = fs; dj.obj.sclust = 0;	/* Open root directory */
    4898:	9b15      	ldr	r3, [sp, #84]	; 0x54
    489a:	2100      	movs	r1, #0
	res = dir_sdi(&dj, 0);
    489c:	a803      	add	r0, sp, #12
		if (dirvn[0] == DDEM) LEAVE_FF(fs, FR_INVALID_NAME);	/* Reject illegal name (heading DDEM) */
		while (di && dirvn[di - 1] == ' ') di--;				/* Snip trailing spaces */
	}

	/* Set volume label */
	dj.obj.fs = fs; dj.obj.sclust = 0;	/* Open root directory */
    489e:	9303      	str	r3, [sp, #12]
    48a0:	9105      	str	r1, [sp, #20]
	res = dir_sdi(&dj, 0);
    48a2:	f7fe fcfa 	bl	329a <dir_sdi>
	if (res == FR_OK) {
    48a6:	4605      	mov	r5, r0
    48a8:	2800      	cmp	r0, #0
    48aa:	d12b      	bne.n	4904 <f_setlabel+0x120>
		res = DIR_READ_LABEL(&dj);	/* Get volume label entry */
    48ac:	a803      	add	r0, sp, #12
    48ae:	2101      	movs	r1, #1
    48b0:	f7fe fe1f 	bl	34f2 <dir_read>
		if (res == FR_OK) {
    48b4:	b940      	cbnz	r0, 48c8 <f_setlabel+0xe4>
			if (FF_FS_EXFAT && fs->fs_type == FS_EXFAT) {
				dj.dir[XDIR_NumLabel] = (BYTE)di;	/* Change the volume label */
				mem_cpy(dj.dir + XDIR_Label, dirvn, 22);
			} else {
				if (di != 0) {
    48b6:	b11c      	cbz	r4, 48c0 <f_setlabel+0xdc>
					mem_cpy(dj.dir, dirvn, 11);	/* Change the volume label */
    48b8:	980a      	ldr	r0, [sp, #40]	; 0x28
    48ba:	a90f      	add	r1, sp, #60	; 0x3c
    48bc:	220b      	movs	r2, #11
    48be:	e016      	b.n	48ee <f_setlabel+0x10a>
				} else {
					dj.dir[DIR_Name] = DDEM;	/* Remove the volume label */
    48c0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    48c2:	22e5      	movs	r2, #229	; 0xe5
    48c4:	701a      	strb	r2, [r3, #0]
    48c6:	e014      	b.n	48f2 <f_setlabel+0x10e>
				}
			}
			fs->wflag = 1;
			res = sync_fs(fs);
		} else {			/* No volume label entry or an error */
			if (res == FR_NO_FILE) {
    48c8:	2804      	cmp	r0, #4
    48ca:	d11a      	bne.n	4902 <f_setlabel+0x11e>
				res = FR_OK;
				if (di != 0) {	/* Create a volume label entry */
    48cc:	b1d4      	cbz	r4, 4904 <f_setlabel+0x120>
					res = dir_alloc(&dj, 1);	/* Allocate an entry */
    48ce:	a803      	add	r0, sp, #12
    48d0:	f7fe ff83 	bl	37da <dir_alloc.clone.5>
					if (res == FR_OK) {
    48d4:	4605      	mov	r5, r0
    48d6:	b9a8      	cbnz	r0, 4904 <f_setlabel+0x120>
						mem_set(dj.dir, 0, SZDIRE);	/* Clean the entry */
    48d8:	980a      	ldr	r0, [sp, #40]	; 0x28
    48da:	4629      	mov	r1, r5
    48dc:	2220      	movs	r2, #32
    48de:	f7fe f877 	bl	29d0 <mem_set>
						if (FF_FS_EXFAT && fs->fs_type == FS_EXFAT) {
							dj.dir[XDIR_Type] = ET_VLABEL;	/* Create volume label entry */
							dj.dir[XDIR_NumLabel] = (BYTE)di;
							mem_cpy(dj.dir + XDIR_Label, dirvn, 22);
						} else {
							dj.dir[DIR_Attr] = AM_VOL;		/* Create volume label entry */
    48e2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    48e4:	2208      	movs	r2, #8
    48e6:	72da      	strb	r2, [r3, #11]
							mem_cpy(dj.dir, dirvn, 11);
    48e8:	980a      	ldr	r0, [sp, #40]	; 0x28
    48ea:	a90f      	add	r1, sp, #60	; 0x3c
    48ec:	3203      	adds	r2, #3
    48ee:	f7fe f867 	bl	29c0 <mem_cpy>
						}
						fs->wflag = 1;
    48f2:	9815      	ldr	r0, [sp, #84]	; 0x54
    48f4:	2301      	movs	r3, #1
    48f6:	70c3      	strb	r3, [r0, #3]
						res = sync_fs(fs);
    48f8:	f7fe f9bf 	bl	2c7a <sync_fs>
    48fc:	e001      	b.n	4902 <f_setlabel+0x11e>
				LEAVE_FF(fs, FR_INVALID_NAME);
			}
			if (wc >= 0x100) dirvn[di++] = (BYTE)(wc >> 8);
			dirvn[di++] = (BYTE)wc;
		}
		if (dirvn[0] == DDEM) LEAVE_FF(fs, FR_INVALID_NAME);	/* Reject illegal name (heading DDEM) */
    48fe:	2506      	movs	r5, #6
    4900:	e000      	b.n	4904 <f_setlabel+0x120>
				}
			}
			fs->wflag = 1;
			res = sync_fs(fs);
		} else {			/* No volume label entry or an error */
			if (res == FR_NO_FILE) {
    4902:	4605      	mov	r5, r0
			}
		}
	}

	LEAVE_FF(fs, res);
}
    4904:	4628      	mov	r0, r5
    4906:	b017      	add	sp, #92	; 0x5c
    4908:	bdf0      	pop	{r4, r5, r6, r7, pc}
    490a:	bf00      	nop
    490c:	00005cac 	.word	0x00005cac

00004910 <f_mkfs>:
	BYTE opt,			/* Format option */
	DWORD au,			/* Size of allocation unit (cluster) [byte] */
	void* work,			/* Pointer to working buffer (null: use heap memory) */
	UINT len			/* Size of working buffer [byte] */
)
{
    4910:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4914:	b08d      	sub	sp, #52	; 0x34
    4916:	af0c      	add	r7, sp, #48	; 0x30
    4918:	f847 0d0c 	str.w	r0, [r7, #-12]!
	DWORD tbl[3];
#endif


	/* Check mounted drive and clear work area */
	vol = get_ldnumber(&path);					/* Get target logical drive */
    491c:	4638      	mov	r0, r7
	BYTE opt,			/* Format option */
	DWORD au,			/* Size of allocation unit (cluster) [byte] */
	void* work,			/* Pointer to working buffer (null: use heap memory) */
	UINT len			/* Size of working buffer [byte] */
)
{
    491e:	460e      	mov	r6, r1
    4920:	4615      	mov	r5, r2
    4922:	461c      	mov	r4, r3
    4924:	f8dd 8058 	ldr.w	r8, [sp, #88]	; 0x58
	DWORD tbl[3];
#endif


	/* Check mounted drive and clear work area */
	vol = get_ldnumber(&path);					/* Get target logical drive */
    4928:	f7fe f937 	bl	2b9a <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
    492c:	2800      	cmp	r0, #0
    492e:	f2c0 829b 	blt.w	4e68 <f_mkfs+0x558>
	if (FatFs[vol]) FatFs[vol]->fs_type = 0;	/* Clear the volume if mounted */
    4932:	4ba7      	ldr	r3, [pc, #668]	; (4bd0 <f_mkfs+0x2c0>)
    4934:	eb03 0380 	add.w	r3, r3, r0, lsl #2
    4938:	685b      	ldr	r3, [r3, #4]
    493a:	b10b      	cbz	r3, 4940 <f_mkfs+0x30>
    493c:	2200      	movs	r2, #0
    493e:	701a      	strb	r2, [r3, #0]
	pdrv = LD2PD(vol);	/* Physical drive */
    4940:	fa5f f980 	uxtb.w	r9, r0
	part = LD2PT(vol);	/* Partition (0:create as new, 1-4:get from partition table) */

	/* Check physical drive status */
	stat = disk_initialize(pdrv);
    4944:	4648      	mov	r0, r9
    4946:	f7fd fd61 	bl	240c <disk_initialize>
	if (stat & STA_NOINIT) return FR_NOT_READY;
    494a:	f010 0f01 	tst.w	r0, #1
    494e:	f040 828d 	bne.w	4e6c <f_mkfs+0x55c>
	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
    4952:	f010 0f04 	tst.w	r0, #4
    4956:	f040 828b 	bne.w	4e70 <f_mkfs+0x560>
	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &sz_blk) != RES_OK || !sz_blk || sz_blk > 32768 || (sz_blk & (sz_blk - 1))) sz_blk = 1;	/* Erase block to align data area */
    495a:	4648      	mov	r0, r9
    495c:	2103      	movs	r1, #3
    495e:	aa0b      	add	r2, sp, #44	; 0x2c
    4960:	f7fd fec4 	bl	26ec <disk_ioctl>
    4964:	b938      	cbnz	r0, 4976 <f_mkfs+0x66>
    4966:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    4968:	b12b      	cbz	r3, 4976 <f_mkfs+0x66>
    496a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    496e:	d802      	bhi.n	4976 <f_mkfs+0x66>
    4970:	1e5a      	subs	r2, r3, #1
    4972:	421a      	tst	r2, r3
    4974:	d001      	beq.n	497a <f_mkfs+0x6a>
    4976:	2301      	movs	r3, #1
    4978:	930b      	str	r3, [sp, #44]	; 0x2c
	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &ss) != RES_OK) return FR_DISK_ERR;
	if (ss > FF_MAX_SS || ss < FF_MIN_SS || (ss & (ss - 1))) return FR_DISK_ERR;
#else
	ss = FF_MAX_SS;
#endif
	if ((au != 0 && au < ss) || au > 0x1000000 || (au & (au - 1))) return FR_INVALID_PARAMETER;	/* Check if au is valid */
    497a:	b13d      	cbz	r5, 498c <f_mkfs+0x7c>
    497c:	f5b5 7f00 	cmp.w	r5, #512	; 0x200
    4980:	f0c0 827a 	bcc.w	4e78 <f_mkfs+0x568>
    4984:	f1b5 7f80 	cmp.w	r5, #16777216	; 0x1000000
    4988:	f200 8276 	bhi.w	4e78 <f_mkfs+0x568>
    498c:	1e6b      	subs	r3, r5, #1
    498e:	422b      	tst	r3, r5
    4990:	f040 8272 	bne.w	4e78 <f_mkfs+0x568>
	{
		buf = (BYTE*)work;		/* Working buffer */
		sz_buf = len / ss;		/* Size of working buffer (sector) */
		szb_buf = sz_buf * ss;	/* Size of working buffer (byte) */
	}
	if (!buf || sz_buf == 0) return FR_NOT_ENOUGH_CORE;
    4994:	2c00      	cmp	r4, #0
    4996:	f000 826d 	beq.w	4e74 <f_mkfs+0x564>
    499a:	ea5f 2858 	movs.w	r8, r8, lsr #9
    499e:	f8cd 8014 	str.w	r8, [sp, #20]
    49a2:	f000 8267 	beq.w	4e74 <f_mkfs+0x564>
		if (pte[PTE_System] == 0) LEAVE_MKFS(FR_MKFS_ABORTED);	/* No partition? */
		b_vol = ld_dword(pte + PTE_StLba);		/* Get volume start sector */
		sz_vol = ld_dword(pte + PTE_SizLba);	/* Get volume size */
	} else {
		/* Create a single-partition in this function */
		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_vol) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
    49a6:	4648      	mov	r0, r9
    49a8:	2101      	movs	r1, #1
    49aa:	aa0a      	add	r2, sp, #40	; 0x28
    49ac:	f7fd fe9e 	bl	26ec <disk_ioctl>
    49b0:	2800      	cmp	r0, #0
    49b2:	f040 8265 	bne.w	4e80 <f_mkfs+0x570>
		b_vol = (opt & FM_SFD) ? 0 : 63;		/* Volume start sector */
    49b6:	f016 0008 	ands.w	r0, r6, #8
		if (sz_vol < b_vol) LEAVE_MKFS(FR_MKFS_ABORTED);
    49ba:	9b0a      	ldr	r3, [sp, #40]	; 0x28
		b_vol = ld_dword(pte + PTE_StLba);		/* Get volume start sector */
		sz_vol = ld_dword(pte + PTE_SizLba);	/* Get volume size */
	} else {
		/* Create a single-partition in this function */
		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_vol) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
		b_vol = (opt & FM_SFD) ? 0 : 63;		/* Volume start sector */
    49bc:	bf0c      	ite	eq
    49be:	f04f 083f 	moveq.w	r8, #63	; 0x3f
    49c2:	f04f 0800 	movne.w	r8, #0
		if (sz_vol < b_vol) LEAVE_MKFS(FR_MKFS_ABORTED);
    49c6:	4543      	cmp	r3, r8
		b_vol = ld_dword(pte + PTE_StLba);		/* Get volume start sector */
		sz_vol = ld_dword(pte + PTE_SizLba);	/* Get volume size */
	} else {
		/* Create a single-partition in this function */
		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_vol) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
		b_vol = (opt & FM_SFD) ? 0 : 63;		/* Volume start sector */
    49c8:	9001      	str	r0, [sp, #4]
		if (sz_vol < b_vol) LEAVE_MKFS(FR_MKFS_ABORTED);
    49ca:	f0c0 8257 	bcc.w	4e7c <f_mkfs+0x56c>
		sz_vol -= b_vol;						/* Volume size */
    49ce:	ebc8 0303 	rsb	r3, r8, r3
	}
	if (sz_vol < 128) LEAVE_MKFS(FR_MKFS_ABORTED);	/* Check if volume size is >=128s */
    49d2:	2b7f      	cmp	r3, #127	; 0x7f
	} else {
		/* Create a single-partition in this function */
		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_vol) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
		b_vol = (opt & FM_SFD) ? 0 : 63;		/* Volume start sector */
		if (sz_vol < b_vol) LEAVE_MKFS(FR_MKFS_ABORTED);
		sz_vol -= b_vol;						/* Volume size */
    49d4:	930a      	str	r3, [sp, #40]	; 0x28
	}
	if (sz_vol < 128) LEAVE_MKFS(FR_MKFS_ABORTED);	/* Check if volume size is >=128s */
    49d6:	f240 8251 	bls.w	4e7c <f_mkfs+0x56c>
	if (ss > FF_MAX_SS || ss < FF_MIN_SS || (ss & (ss - 1))) return FR_DISK_ERR;
#else
	ss = FF_MAX_SS;
#endif
	if ((au != 0 && au < ss) || au > 0x1000000 || (au & (au - 1))) return FR_INVALID_PARAMETER;	/* Check if au is valid */
	au /= ss;	/* Cluster size in unit of sector */
    49da:	0a6a      	lsrs	r2, r5, #9
		if (FF_FS_EXFAT && (opt & FM_EXFAT)) {	/* exFAT possible? */
			if ((opt & FM_ANY) == FM_EXFAT || sz_vol >= 0x4000000 || au > 128) {	/* exFAT only, vol >= 64Ms or au > 128s ? */
				fmt = FS_EXFAT; break;
			}
		}
		if (au > 128) LEAVE_MKFS(FR_INVALID_PARAMETER);	/* Too large au for FAT/FAT32 */
    49dc:	2a80      	cmp	r2, #128	; 0x80
    49de:	f200 824b 	bhi.w	4e78 <f_mkfs+0x568>
		if (opt & FM_FAT32) {	/* FAT32 possible? */
    49e2:	f016 0102 	ands.w	r1, r6, #2
    49e6:	9102      	str	r1, [sp, #8]
    49e8:	d006      	beq.n	49f8 <f_mkfs+0xe8>
			if ((opt & FM_ANY) == FM_FAT32 || !(opt & FM_FAT)) {	/* FAT32 only or no-FAT? */
    49ea:	f006 0107 	and.w	r1, r6, #7
    49ee:	2902      	cmp	r1, #2
    49f0:	d008      	beq.n	4a04 <f_mkfs+0xf4>
    49f2:	f016 0f01 	tst.w	r6, #1
    49f6:	d005      	beq.n	4a04 <f_mkfs+0xf4>
				fmt = FS_FAT32; break;
			}
		}
		if (!(opt & FM_FAT)) LEAVE_MKFS(FR_INVALID_PARAMETER);	/* no-FAT? */
    49f8:	f016 0f01 	tst.w	r6, #1
    49fc:	f000 823c 	beq.w	4e78 <f_mkfs+0x568>
		fmt = FS_FAT16;
    4a00:	2502      	movs	r5, #2
    4a02:	e000      	b.n	4a06 <f_mkfs+0xf6>
			}
		}
		if (au > 128) LEAVE_MKFS(FR_INVALID_PARAMETER);	/* Too large au for FAT/FAT32 */
		if (opt & FM_FAT32) {	/* FAT32 possible? */
			if ((opt & FM_ANY) == FM_FAT32 || !(opt & FM_FAT)) {	/* FAT32 only or no-FAT? */
				fmt = FS_FAT32; break;
    4a04:	2503      	movs	r5, #3
			}
			b_fat = b_vol + sz_rsv;						/* FAT base */
			b_data = b_fat + sz_fat * n_fats + sz_dir;	/* Data base */

			/* Align data base to erase block boundary (for flash memory media) */
			n = ((b_data + sz_blk - 1) & ~(sz_blk - 1)) - b_data;	/* Next nearest erase block from current data base */
    4a06:	990b      	ldr	r1, [sp, #44]	; 0x2c
		do {
			pau = au;
			/* Pre-determine number of clusters and FAT sub-type */
			if (fmt == FS_FAT32) {	/* FAT32 volume */
				if (pau == 0) {	/* au auto-selection */
					n = sz_vol / 0x20000;	/* Volume size in unit of 128KS */
    4a08:	0c5f      	lsrs	r7, r3, #17
			}
			b_fat = b_vol + sz_rsv;						/* FAT base */
			b_data = b_fat + sz_fat * n_fats + sz_dir;	/* Data base */

			/* Align data base to erase block boundary (for flash memory media) */
			n = ((b_data + sz_blk - 1) & ~(sz_blk - 1)) - b_data;	/* Next nearest erase block from current data base */
    4a0a:	1e48      	subs	r0, r1, #1
				sz_rsv = 32;	/* Number of reserved sectors */
				sz_dir = 0;		/* No static directory */
				if (n_clst <= MAX_FAT16 || n_clst > MAX_FAT32) LEAVE_MKFS(FR_MKFS_ABORTED);
			} else {				/* FAT volume */
				if (pau == 0) {	/* au auto-selection */
					n = sz_vol / 0x1000;	/* Volume size in unit of 4KS */
    4a0c:	ea4f 3b13 	mov.w	fp, r3, lsr #12
#endif	/* FF_FS_EXFAT */
	{	/* Create an FAT/FAT32 volume */
		do {
			pau = au;
			/* Pre-determine number of clusters and FAT sub-type */
			if (fmt == FS_FAT32) {	/* FAT32 volume */
    4a10:	2d03      	cmp	r5, #3
				if (pau == 0) {	/* au auto-selection */
					n = sz_vol / 0x20000;	/* Volume size in unit of 128KS */
    4a12:	9706      	str	r7, [sp, #24]
				sz_rsv = 32;	/* Number of reserved sectors */
				sz_dir = 0;		/* No static directory */
				if (n_clst <= MAX_FAT16 || n_clst > MAX_FAT32) LEAVE_MKFS(FR_MKFS_ABORTED);
			} else {				/* FAT volume */
				if (pau == 0) {	/* au auto-selection */
					n = sz_vol / 0x1000;	/* Volume size in unit of 4KS */
    4a14:	f8cd b01c 	str.w	fp, [sp, #28]
			}
			b_fat = b_vol + sz_rsv;						/* FAT base */
			b_data = b_fat + sz_fat * n_fats + sz_dir;	/* Data base */

			/* Align data base to erase block boundary (for flash memory media) */
			n = ((b_data + sz_blk - 1) & ~(sz_blk - 1)) - b_data;	/* Next nearest erase block from current data base */
    4a18:	9008      	str	r0, [sp, #32]
    4a1a:	f1c1 0c00 	rsb	ip, r1, #0
#endif	/* FF_FS_EXFAT */
	{	/* Create an FAT/FAT32 volume */
		do {
			pau = au;
			/* Pre-determine number of clusters and FAT sub-type */
			if (fmt == FS_FAT32) {	/* FAT32 volume */
    4a1e:	d128      	bne.n	4a72 <f_mkfs+0x162>
    4a20:	e002      	b.n	4a28 <f_mkfs+0x118>
					LEAVE_MKFS(FR_MKFS_ABORTED);
				}
			}
			if (fmt == FS_FAT16) {
				if (n_clst > MAX_FAT16) {	/* Too many clusters for FAT16 */
					if (au == 0 && (pau * 2) <= 64) {
    4a22:	460a      	mov	r2, r1
    4a24:	e025      	b.n	4a72 <f_mkfs+0x162>
						au = pau * 2; continue;		/* Adjust cluster size and retry */
					}
					if ((opt & FM_FAT32)) {
						fmt = FS_FAT32; continue;	/* Switch type to FAT32 and retry */
    4a26:	2503      	movs	r5, #3
	{	/* Create an FAT/FAT32 volume */
		do {
			pau = au;
			/* Pre-determine number of clusters and FAT sub-type */
			if (fmt == FS_FAT32) {	/* FAT32 volume */
				if (pau == 0) {	/* au auto-selection */
    4a28:	b952      	cbnz	r2, 4a40 <f_mkfs+0x130>
    4a2a:	496a      	ldr	r1, [pc, #424]	; (4bd4 <f_mkfs+0x2c4>)
					n = sz_vol / 0x20000;	/* Volume size in unit of 128KS */
					for (i = 0, pau = 1; cst32[i] && cst32[i] <= n; i++, pau <<= 1) ;	/* Get from table */
    4a2c:	2601      	movs	r6, #1
    4a2e:	e000      	b.n	4a32 <f_mkfs+0x122>
    4a30:	0076      	lsls	r6, r6, #1
    4a32:	f831 0f02 	ldrh.w	r0, [r1, #2]!
    4a36:	b120      	cbz	r0, 4a42 <f_mkfs+0x132>
    4a38:	9f06      	ldr	r7, [sp, #24]
    4a3a:	42b8      	cmp	r0, r7
    4a3c:	d9f8      	bls.n	4a30 <f_mkfs+0x120>
    4a3e:	e000      	b.n	4a42 <f_mkfs+0x132>
	{	/* Create an FAT/FAT32 volume */
		do {
			pau = au;
			/* Pre-determine number of clusters and FAT sub-type */
			if (fmt == FS_FAT32) {	/* FAT32 volume */
				if (pau == 0) {	/* au auto-selection */
    4a40:	4616      	mov	r6, r2
					n = sz_vol / 0x20000;	/* Volume size in unit of 128KS */
					for (i = 0, pau = 1; cst32[i] && cst32[i] <= n; i++, pau <<= 1) ;	/* Get from table */
				}
				n_clst = sz_vol / pau;	/* Number of clusters */
    4a42:	fbb3 faf6 	udiv	sl, r3, r6
				sz_fat = (n_clst * 4 + 8 + ss - 1) / ss;	/* FAT size [sector] */
				sz_rsv = 32;	/* Number of reserved sectors */
				sz_dir = 0;		/* No static directory */
				if (n_clst <= MAX_FAT16 || n_clst > MAX_FAT32) LEAVE_MKFS(FR_MKFS_ABORTED);
    4a46:	f5aa 417e 	sub.w	r1, sl, #65024	; 0xfe00
    4a4a:	4863      	ldr	r0, [pc, #396]	; (4bd8 <f_mkfs+0x2c8>)
    4a4c:	f5a1 71fb 	sub.w	r1, r1, #502	; 0x1f6
    4a50:	4281      	cmp	r1, r0
    4a52:	f200 8213 	bhi.w	4e7c <f_mkfs+0x56c>
				if (pau == 0) {	/* au auto-selection */
					n = sz_vol / 0x20000;	/* Volume size in unit of 128KS */
					for (i = 0, pau = 1; cst32[i] && cst32[i] <= n; i++, pau <<= 1) ;	/* Get from table */
				}
				n_clst = sz_vol / pau;	/* Number of clusters */
				sz_fat = (n_clst * 4 + 8 + ss - 1) / ss;	/* FAT size [sector] */
    4a56:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
    4a5a:	f50a 7a00 	add.w	sl, sl, #512	; 0x200
    4a5e:	f10a 0a07 	add.w	sl, sl, #7
				sz_rsv = 32;	/* Number of reserved sectors */
				sz_dir = 0;		/* No static directory */
    4a62:	f04f 0b00 	mov.w	fp, #0
				if (pau == 0) {	/* au auto-selection */
					n = sz_vol / 0x20000;	/* Volume size in unit of 128KS */
					for (i = 0, pau = 1; cst32[i] && cst32[i] <= n; i++, pau <<= 1) ;	/* Get from table */
				}
				n_clst = sz_vol / pau;	/* Number of clusters */
				sz_fat = (n_clst * 4 + 8 + ss - 1) / ss;	/* FAT size [sector] */
    4a66:	ea4f 2a5a 	mov.w	sl, sl, lsr #9
				sz_rsv = 32;	/* Number of reserved sectors */
				sz_dir = 0;		/* No static directory */
    4a6a:	f8cd b010 	str.w	fp, [sp, #16]
					n = sz_vol / 0x20000;	/* Volume size in unit of 128KS */
					for (i = 0, pau = 1; cst32[i] && cst32[i] <= n; i++, pau <<= 1) ;	/* Get from table */
				}
				n_clst = sz_vol / pau;	/* Number of clusters */
				sz_fat = (n_clst * 4 + 8 + ss - 1) / ss;	/* FAT size [sector] */
				sz_rsv = 32;	/* Number of reserved sectors */
    4a6e:	2720      	movs	r7, #32
    4a70:	e02a      	b.n	4ac8 <f_mkfs+0x1b8>
				sz_dir = 0;		/* No static directory */
				if (n_clst <= MAX_FAT16 || n_clst > MAX_FAT32) LEAVE_MKFS(FR_MKFS_ABORTED);
			} else {				/* FAT volume */
				if (pau == 0) {	/* au auto-selection */
    4a72:	b952      	cbnz	r2, 4a8a <f_mkfs+0x17a>
    4a74:	4959      	ldr	r1, [pc, #356]	; (4bdc <f_mkfs+0x2cc>)
					n = sz_vol / 0x1000;	/* Volume size in unit of 4KS */
					for (i = 0, pau = 1; cst[i] && cst[i] <= n; i++, pau <<= 1) ;	/* Get from table */
    4a76:	2601      	movs	r6, #1
    4a78:	e000      	b.n	4a7c <f_mkfs+0x16c>
    4a7a:	0076      	lsls	r6, r6, #1
    4a7c:	f831 0f02 	ldrh.w	r0, [r1, #2]!
    4a80:	b120      	cbz	r0, 4a8c <f_mkfs+0x17c>
    4a82:	9d07      	ldr	r5, [sp, #28]
    4a84:	42a8      	cmp	r0, r5
    4a86:	d9f8      	bls.n	4a7a <f_mkfs+0x16a>
    4a88:	e000      	b.n	4a8c <f_mkfs+0x17c>
				sz_fat = (n_clst * 4 + 8 + ss - 1) / ss;	/* FAT size [sector] */
				sz_rsv = 32;	/* Number of reserved sectors */
				sz_dir = 0;		/* No static directory */
				if (n_clst <= MAX_FAT16 || n_clst > MAX_FAT32) LEAVE_MKFS(FR_MKFS_ABORTED);
			} else {				/* FAT volume */
				if (pau == 0) {	/* au auto-selection */
    4a8a:	4616      	mov	r6, r2
					n = sz_vol / 0x1000;	/* Volume size in unit of 4KS */
					for (i = 0, pau = 1; cst[i] && cst[i] <= n; i++, pau <<= 1) ;	/* Get from table */
				}
				n_clst = sz_vol / pau;
    4a8c:	fbb3 faf6 	udiv	sl, r3, r6
				if (n_clst > MAX_FAT12) {
    4a90:	f640 71f5 	movw	r1, #4085	; 0xff5
    4a94:	458a      	cmp	sl, r1
    4a96:	d905      	bls.n	4aa4 <f_mkfs+0x194>
					n = n_clst * 2 + 4;		/* FAT size [byte] */
    4a98:	f10a 0a02 	add.w	sl, sl, #2
    4a9c:	ea4f 0a4a 	mov.w	sl, sl, lsl #1
    4aa0:	2502      	movs	r5, #2
    4aa2:	e008      	b.n	4ab6 <f_mkfs+0x1a6>
				} else {
					fmt = FS_FAT12;
					n = (n_clst * 3 + 1) / 2 + 3;	/* FAT size [byte] */
    4aa4:	eb0a 0a4a 	add.w	sl, sl, sl, lsl #1
    4aa8:	f10a 0a01 	add.w	sl, sl, #1
    4aac:	ea4f 0a5a 	mov.w	sl, sl, lsr #1
    4ab0:	f10a 0a03 	add.w	sl, sl, #3
				}
				n_clst = sz_vol / pau;
				if (n_clst > MAX_FAT12) {
					n = n_clst * 2 + 4;		/* FAT size [byte] */
				} else {
					fmt = FS_FAT12;
    4ab4:	2501      	movs	r5, #1
					n = (n_clst * 3 + 1) / 2 + 3;	/* FAT size [byte] */
				}
				sz_fat = (n + ss - 1) / ss;		/* FAT size [sector] */
    4ab6:	f50a 7afe 	add.w	sl, sl, #508	; 0x1fc
				sz_rsv = 1;						/* Number of reserved sectors */
				sz_dir = (DWORD)n_rootdir * SZDIRE / ss;	/* Rootdir size [sector] */
    4aba:	2720      	movs	r7, #32
					n = n_clst * 2 + 4;		/* FAT size [byte] */
				} else {
					fmt = FS_FAT12;
					n = (n_clst * 3 + 1) / 2 + 3;	/* FAT size [byte] */
				}
				sz_fat = (n + ss - 1) / ss;		/* FAT size [sector] */
    4abc:	f10a 0a03 	add.w	sl, sl, #3
				sz_rsv = 1;						/* Number of reserved sectors */
				sz_dir = (DWORD)n_rootdir * SZDIRE / ss;	/* Rootdir size [sector] */
    4ac0:	9704      	str	r7, [sp, #16]
					n = n_clst * 2 + 4;		/* FAT size [byte] */
				} else {
					fmt = FS_FAT12;
					n = (n_clst * 3 + 1) / 2 + 3;	/* FAT size [byte] */
				}
				sz_fat = (n + ss - 1) / ss;		/* FAT size [sector] */
    4ac2:	ea4f 2a5a 	mov.w	sl, sl, lsr #9
				sz_rsv = 1;						/* Number of reserved sectors */
    4ac6:	3f1f      	subs	r7, #31
				sz_dir = (DWORD)n_rootdir * SZDIRE / ss;	/* Rootdir size [sector] */
			}
			b_fat = b_vol + sz_rsv;						/* FAT base */
			b_data = b_fat + sz_fat * n_fats + sz_dir;	/* Data base */
    4ac8:	9804      	ldr	r0, [sp, #16]
				}
				sz_fat = (n + ss - 1) / ss;		/* FAT size [sector] */
				sz_rsv = 1;						/* Number of reserved sectors */
				sz_dir = (DWORD)n_rootdir * SZDIRE / ss;	/* Rootdir size [sector] */
			}
			b_fat = b_vol + sz_rsv;						/* FAT base */
    4aca:	eb07 0b08 	add.w	fp, r7, r8
			b_data = b_fat + sz_fat * n_fats + sz_dir;	/* Data base */
    4ace:	eb00 010a 	add.w	r1, r0, sl
    4ad2:	4459      	add	r1, fp
				}
				sz_fat = (n + ss - 1) / ss;		/* FAT size [sector] */
				sz_rsv = 1;						/* Number of reserved sectors */
				sz_dir = (DWORD)n_rootdir * SZDIRE / ss;	/* Rootdir size [sector] */
			}
			b_fat = b_vol + sz_rsv;						/* FAT base */
    4ad4:	f8cd b00c 	str.w	fp, [sp, #12]
			b_data = b_fat + sz_fat * n_fats + sz_dir;	/* Data base */

			/* Align data base to erase block boundary (for flash memory media) */
			n = ((b_data + sz_blk - 1) & ~(sz_blk - 1)) - b_data;	/* Next nearest erase block from current data base */
    4ad8:	f8dd b020 	ldr.w	fp, [sp, #32]
			if (fmt == FS_FAT32) {		/* FAT32: Move FAT base */
    4adc:	2d03      	cmp	r5, #3
			}
			b_fat = b_vol + sz_rsv;						/* FAT base */
			b_data = b_fat + sz_fat * n_fats + sz_dir;	/* Data base */

			/* Align data base to erase block boundary (for flash memory media) */
			n = ((b_data + sz_blk - 1) & ~(sz_blk - 1)) - b_data;	/* Next nearest erase block from current data base */
    4ade:	eb01 000b 	add.w	r0, r1, fp
    4ae2:	ea00 000c 	and.w	r0, r0, ip
    4ae6:	ebc1 0000 	rsb	r0, r1, r0
			if (fmt == FS_FAT32) {		/* FAT32: Move FAT base */
    4aea:	d106      	bne.n	4afa <f_mkfs+0x1ea>
				sz_rsv += n; b_fat += n;
    4aec:	f8dd b00c 	ldr.w	fp, [sp, #12]
    4af0:	183f      	adds	r7, r7, r0
    4af2:	4483      	add	fp, r0
    4af4:	f8cd b00c 	str.w	fp, [sp, #12]
    4af8:	e000      	b.n	4afc <f_mkfs+0x1ec>
			} else {					/* FAT: Expand FAT size */
				sz_fat += n / n_fats;
    4afa:	4482      	add	sl, r0
			}

			/* Determine number of clusters and final check of validity of the FAT sub-type */
			if (sz_vol < b_data + pau * 16 - b_vol) LEAVE_MKFS(FR_MKFS_ABORTED);	/* Too small volume */
    4afc:	0130      	lsls	r0, r6, #4
    4afe:	ebc8 0000 	rsb	r0, r8, r0
    4b02:	1841      	adds	r1, r0, r1
    4b04:	428b      	cmp	r3, r1
    4b06:	f0c0 81b9 	bcc.w	4e7c <f_mkfs+0x56c>
			n_clst = (sz_vol - sz_rsv - sz_fat * n_fats - sz_dir) / pau;
    4b0a:	ebc7 0b03 	rsb	fp, r7, r3
    4b0e:	9804      	ldr	r0, [sp, #16]
    4b10:	ebca 0b0b 	rsb	fp, sl, fp
    4b14:	ebc0 0b0b 	rsb	fp, r0, fp
			if (fmt == FS_FAT32) {
    4b18:	2d03      	cmp	r5, #3
				sz_fat += n / n_fats;
			}

			/* Determine number of clusters and final check of validity of the FAT sub-type */
			if (sz_vol < b_data + pau * 16 - b_vol) LEAVE_MKFS(FR_MKFS_ABORTED);	/* Too small volume */
			n_clst = (sz_vol - sz_rsv - sz_fat * n_fats - sz_dir) / pau;
    4b1a:	fbbb fbf6 	udiv	fp, fp, r6
			if (fmt == FS_FAT32) {
    4b1e:	d10a      	bne.n	4b36 <f_mkfs+0x226>
				if (n_clst <= MAX_FAT16) {	/* Too few clusters for FAT32 */
    4b20:	f64f 71f5 	movw	r1, #65525	; 0xfff5
    4b24:	458b      	cmp	fp, r1
    4b26:	d827      	bhi.n	4b78 <f_mkfs+0x268>
					if (au == 0 && (au = pau / 2) != 0) continue;	/* Adjust cluster size and retry */
    4b28:	2a00      	cmp	r2, #0
    4b2a:	f040 81a7 	bne.w	4e7c <f_mkfs+0x56c>
    4b2e:	0872      	lsrs	r2, r6, #1
    4b30:	f47f af7a 	bne.w	4a28 <f_mkfs+0x118>
    4b34:	e1a2      	b.n	4e7c <f_mkfs+0x56c>
					LEAVE_MKFS(FR_MKFS_ABORTED);
				}
			}
			if (fmt == FS_FAT16) {
    4b36:	2d02      	cmp	r5, #2
    4b38:	d116      	bne.n	4b68 <f_mkfs+0x258>
				if (n_clst > MAX_FAT16) {	/* Too many clusters for FAT16 */
    4b3a:	f64f 71f5 	movw	r1, #65525	; 0xfff5
    4b3e:	458b      	cmp	fp, r1
    4b40:	d907      	bls.n	4b52 <f_mkfs+0x242>
					if (au == 0 && (pau * 2) <= 64) {
    4b42:	b91a      	cbnz	r2, 4b4c <f_mkfs+0x23c>
    4b44:	0071      	lsls	r1, r6, #1
    4b46:	2940      	cmp	r1, #64	; 0x40
    4b48:	f67f af6b 	bls.w	4a22 <f_mkfs+0x112>
						au = pau * 2; continue;		/* Adjust cluster size and retry */
					}
					if ((opt & FM_FAT32)) {
    4b4c:	9902      	ldr	r1, [sp, #8]
    4b4e:	b121      	cbz	r1, 4b5a <f_mkfs+0x24a>
    4b50:	e769      	b.n	4a26 <f_mkfs+0x116>
						fmt = FS_FAT32; continue;	/* Switch type to FAT32 and retry */
					}
					if (au == 0 && (au = pau * 2) <= 128) continue;	/* Adjust cluster size and retry */
					LEAVE_MKFS(FR_MKFS_ABORTED);
				}
				if  (n_clst <= MAX_FAT12) {	/* Too few clusters for FAT16 */
    4b52:	f640 71f5 	movw	r1, #4085	; 0xff5
    4b56:	458b      	cmp	fp, r1
    4b58:	d80e      	bhi.n	4b78 <f_mkfs+0x268>
					if (au == 0 && (au = pau * 2) <= 128) continue;	/* Adjust cluster size and retry */
    4b5a:	2a00      	cmp	r2, #0
    4b5c:	f040 818e 	bne.w	4e7c <f_mkfs+0x56c>
    4b60:	0072      	lsls	r2, r6, #1
    4b62:	2a80      	cmp	r2, #128	; 0x80
    4b64:	d985      	bls.n	4a72 <f_mkfs+0x162>
    4b66:	e189      	b.n	4e7c <f_mkfs+0x56c>
					LEAVE_MKFS(FR_MKFS_ABORTED);
				}
			}
			if (fmt == FS_FAT12 && n_clst > MAX_FAT12) LEAVE_MKFS(FR_MKFS_ABORTED);	/* Too many clusters for FAT12 */
    4b68:	2d01      	cmp	r5, #1
    4b6a:	d104      	bne.n	4b76 <f_mkfs+0x266>
    4b6c:	f640 73f5 	movw	r3, #4085	; 0xff5
    4b70:	459b      	cmp	fp, r3
    4b72:	d901      	bls.n	4b78 <f_mkfs+0x268>
    4b74:	e182      	b.n	4e7c <f_mkfs+0x56c>
    4b76:	2500      	movs	r5, #0
#if FF_USE_TRIM
		tbl[0] = b_vol; tbl[1] = b_vol + sz_vol - 1;	/* Inform the device the volume area can be erased */
		disk_ioctl(pdrv, CTRL_TRIM, tbl);
#endif
		/* Create FAT VBR */
		mem_set(buf, 0, ss);
    4b78:	2100      	movs	r1, #0
    4b7a:	4620      	mov	r0, r4
    4b7c:	f44f 7200 	mov.w	r2, #512	; 0x200
    4b80:	f7fd ff26 	bl	29d0 <mem_set>
		mem_cpy(buf + BS_JmpBoot, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code (x86), OEM name */
    4b84:	220b      	movs	r2, #11
    4b86:	4620      	mov	r0, r4
    4b88:	4915      	ldr	r1, [pc, #84]	; (4be0 <f_mkfs+0x2d0>)
    4b8a:	f7fd ff19 	bl	29c0 <mem_cpy>
		st_word(buf + BPB_BytsPerSec, ss);				/* Sector size [byte] */
    4b8e:	f104 000b 	add.w	r0, r4, #11
    4b92:	f44f 7100 	mov.w	r1, #512	; 0x200
    4b96:	f7fd ff05 	bl	29a4 <st_word>
		buf[BPB_SecPerClus] = (BYTE)pau;				/* Cluster size [sector] */
		st_word(buf + BPB_RsvdSecCnt, (WORD)sz_rsv);	/* Size of reserved area */
    4b9a:	f104 000e 	add.w	r0, r4, #14
    4b9e:	b2b9      	uxth	r1, r7
#endif
		/* Create FAT VBR */
		mem_set(buf, 0, ss);
		mem_cpy(buf + BS_JmpBoot, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code (x86), OEM name */
		st_word(buf + BPB_BytsPerSec, ss);				/* Sector size [byte] */
		buf[BPB_SecPerClus] = (BYTE)pau;				/* Cluster size [sector] */
    4ba0:	7366      	strb	r6, [r4, #13]
		st_word(buf + BPB_RsvdSecCnt, (WORD)sz_rsv);	/* Size of reserved area */
    4ba2:	f7fd feff 	bl	29a4 <st_word>
		buf[BPB_NumFATs] = (BYTE)n_fats;				/* Number of FATs */
    4ba6:	2301      	movs	r3, #1
		st_word(buf + BPB_RootEntCnt, (WORD)((fmt == FS_FAT32) ? 0 : n_rootdir));	/* Number of root directory entries */
    4ba8:	2d03      	cmp	r5, #3
    4baa:	bf14      	ite	ne
    4bac:	f44f 7100 	movne.w	r1, #512	; 0x200
    4bb0:	2100      	moveq	r1, #0
		mem_set(buf, 0, ss);
		mem_cpy(buf + BS_JmpBoot, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code (x86), OEM name */
		st_word(buf + BPB_BytsPerSec, ss);				/* Sector size [byte] */
		buf[BPB_SecPerClus] = (BYTE)pau;				/* Cluster size [sector] */
		st_word(buf + BPB_RsvdSecCnt, (WORD)sz_rsv);	/* Size of reserved area */
		buf[BPB_NumFATs] = (BYTE)n_fats;				/* Number of FATs */
    4bb2:	7423      	strb	r3, [r4, #16]
		st_word(buf + BPB_RootEntCnt, (WORD)((fmt == FS_FAT32) ? 0 : n_rootdir));	/* Number of root directory entries */
    4bb4:	f104 0011 	add.w	r0, r4, #17
    4bb8:	f7fd fef4 	bl	29a4 <st_word>
		if (sz_vol < 0x10000) {
    4bbc:	990a      	ldr	r1, [sp, #40]	; 0x28
    4bbe:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
    4bc2:	d20f      	bcs.n	4be4 <f_mkfs+0x2d4>
			st_word(buf + BPB_TotSec16, (WORD)sz_vol);	/* Volume size in 16-bit LBA */
    4bc4:	f104 0013 	add.w	r0, r4, #19
    4bc8:	b289      	uxth	r1, r1
    4bca:	f7fd feeb 	bl	29a4 <st_word>
    4bce:	e00d      	b.n	4bec <f_mkfs+0x2dc>
    4bd0:	1000012c 	.word	0x1000012c
    4bd4:	00005cbc 	.word	0x00005cbc
    4bd8:	0ffeffff 	.word	0x0ffeffff
    4bdc:	00005cca 	.word	0x00005cca
    4be0:	00005ceb 	.word	0x00005ceb
		} else {
			st_dword(buf + BPB_TotSec32, sz_vol);		/* Volume size in 32-bit LBA */
    4be4:	f104 0020 	add.w	r0, r4, #32
    4be8:	f7fd fee0 	bl	29ac <st_dword>
		}
		buf[BPB_Media] = 0xF8;							/* Media descriptor byte */
    4bec:	23f8      	movs	r3, #248	; 0xf8
    4bee:	7563      	strb	r3, [r4, #21]
		st_word(buf + BPB_SecPerTrk, 63);				/* Number of sectors per track (for int13) */
    4bf0:	213f      	movs	r1, #63	; 0x3f
    4bf2:	f104 0018 	add.w	r0, r4, #24
    4bf6:	f7fd fed5 	bl	29a4 <st_word>
		st_word(buf + BPB_NumHeads, 255);				/* Number of heads (for int13) */
    4bfa:	21ff      	movs	r1, #255	; 0xff
    4bfc:	f104 001a 	add.w	r0, r4, #26
    4c00:	f7fd fed0 	bl	29a4 <st_word>
		st_dword(buf + BPB_HiddSec, b_vol);				/* Volume offset in the physical drive [sector] */
    4c04:	f104 001c 	add.w	r0, r4, #28
    4c08:	4641      	mov	r1, r8
    4c0a:	f7fd fecf 	bl	29ac <st_dword>
		if (fmt == FS_FAT32) {
    4c0e:	2d03      	cmp	r5, #3
    4c10:	d124      	bne.n	4c5c <f_mkfs+0x34c>
			st_dword(buf + BS_VolID32, GET_FATTIME());	/* VSN */
    4c12:	f7fb fbe5 	bl	3e0 <get_fattime>
    4c16:	4601      	mov	r1, r0
    4c18:	f104 0043 	add.w	r0, r4, #67	; 0x43
    4c1c:	f7fd fec6 	bl	29ac <st_dword>
			st_dword(buf + BPB_FATSz32, sz_fat);		/* FAT size [sector] */
    4c20:	f104 0024 	add.w	r0, r4, #36	; 0x24
    4c24:	4651      	mov	r1, sl
    4c26:	f7fd fec1 	bl	29ac <st_dword>
			st_dword(buf + BPB_RootClus32, 2);			/* Root directory cluster # (2) */
    4c2a:	f104 002c 	add.w	r0, r4, #44	; 0x2c
    4c2e:	2102      	movs	r1, #2
    4c30:	f7fd febc 	bl	29ac <st_dword>
			st_word(buf + BPB_FSInfo32, 1);				/* Offset of FSINFO sector (VBR + 1) */
    4c34:	f104 0030 	add.w	r0, r4, #48	; 0x30
    4c38:	2101      	movs	r1, #1
    4c3a:	f7fd feb3 	bl	29a4 <st_word>
			st_word(buf + BPB_BkBootSec32, 6);			/* Offset of backup VBR (VBR + 6) */
    4c3e:	f104 0032 	add.w	r0, r4, #50	; 0x32
    4c42:	2106      	movs	r1, #6
    4c44:	f7fd feae 	bl	29a4 <st_word>
			buf[BS_DrvNum32] = 0x80;					/* Drive number (for int13) */
    4c48:	2380      	movs	r3, #128	; 0x80
    4c4a:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
			buf[BS_BootSig32] = 0x29;					/* Extended boot signature */
    4c4e:	3b57      	subs	r3, #87	; 0x57
    4c50:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
			mem_cpy(buf + BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
    4c54:	f104 0047 	add.w	r0, r4, #71	; 0x47
    4c58:	498c      	ldr	r1, [pc, #560]	; (4e8c <f_mkfs+0x57c>)
    4c5a:	e015      	b.n	4c88 <f_mkfs+0x378>
		} else {
			st_dword(buf + BS_VolID, GET_FATTIME());	/* VSN */
    4c5c:	f7fb fbc0 	bl	3e0 <get_fattime>
    4c60:	4601      	mov	r1, r0
    4c62:	f104 0027 	add.w	r0, r4, #39	; 0x27
    4c66:	f7fd fea1 	bl	29ac <st_dword>
			st_word(buf + BPB_FATSz16, (WORD)sz_fat);	/* FAT size [sector] */
    4c6a:	f104 0016 	add.w	r0, r4, #22
    4c6e:	fa1f f18a 	uxth.w	r1, sl
    4c72:	f7fd fe97 	bl	29a4 <st_word>
			buf[BS_DrvNum] = 0x80;						/* Drive number (for int13) */
    4c76:	2380      	movs	r3, #128	; 0x80
    4c78:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
			buf[BS_BootSig] = 0x29;						/* Extended boot signature */
			mem_cpy(buf + BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
    4c7c:	4984      	ldr	r1, [pc, #528]	; (4e90 <f_mkfs+0x580>)
			mem_cpy(buf + BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
		} else {
			st_dword(buf + BS_VolID, GET_FATTIME());	/* VSN */
			st_word(buf + BPB_FATSz16, (WORD)sz_fat);	/* FAT size [sector] */
			buf[BS_DrvNum] = 0x80;						/* Drive number (for int13) */
			buf[BS_BootSig] = 0x29;						/* Extended boot signature */
    4c7e:	3b57      	subs	r3, #87	; 0x57
    4c80:	f884 3026 	strb.w	r3, [r4, #38]	; 0x26
			mem_cpy(buf + BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
    4c84:	f104 002b 	add.w	r0, r4, #43	; 0x2b
    4c88:	2213      	movs	r2, #19
    4c8a:	f7fd fe99 	bl	29c0 <mem_cpy>
		}
		st_word(buf + BS_55AA, 0xAA55);					/* Signature (offset is fixed here regardless of sector size) */
    4c8e:	f504 73ff 	add.w	r3, r4, #510	; 0x1fe
    4c92:	4618      	mov	r0, r3
    4c94:	f64a 2155 	movw	r1, #43605	; 0xaa55
    4c98:	9302      	str	r3, [sp, #8]
    4c9a:	f7fd fe83 	bl	29a4 <st_word>
		if (disk_write(pdrv, buf, b_vol, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);	/* Write it to the VBR sector */
    4c9e:	4648      	mov	r0, r9
    4ca0:	4621      	mov	r1, r4
    4ca2:	4642      	mov	r2, r8
    4ca4:	2301      	movs	r3, #1
    4ca6:	f7fd fccd 	bl	2644 <disk_write>
    4caa:	4607      	mov	r7, r0
    4cac:	2800      	cmp	r0, #0
    4cae:	f040 80e7 	bne.w	4e80 <f_mkfs+0x570>

		/* Create FSINFO record if needed */
		if (fmt == FS_FAT32) {
    4cb2:	2d03      	cmp	r5, #3
    4cb4:	d133      	bne.n	4d1e <f_mkfs+0x40e>
			disk_write(pdrv, buf, b_vol + 6, 1);		/* Write backup VBR (VBR + 6) */
    4cb6:	2301      	movs	r3, #1
    4cb8:	4621      	mov	r1, r4
    4cba:	f108 0206 	add.w	r2, r8, #6
    4cbe:	4648      	mov	r0, r9
    4cc0:	f7fd fcc0 	bl	2644 <disk_write>
			mem_set(buf, 0, ss);
    4cc4:	f44f 7200 	mov.w	r2, #512	; 0x200
    4cc8:	4620      	mov	r0, r4
    4cca:	4639      	mov	r1, r7
    4ccc:	f7fd fe80 	bl	29d0 <mem_set>
			st_dword(buf + FSI_LeadSig, 0x41615252);
    4cd0:	4620      	mov	r0, r4
    4cd2:	4970      	ldr	r1, [pc, #448]	; (4e94 <f_mkfs+0x584>)
    4cd4:	f7fd fe6a 	bl	29ac <st_dword>
			st_dword(buf + FSI_StrucSig, 0x61417272);
    4cd8:	f504 70f2 	add.w	r0, r4, #484	; 0x1e4
    4cdc:	496e      	ldr	r1, [pc, #440]	; (4e98 <f_mkfs+0x588>)
    4cde:	f7fd fe65 	bl	29ac <st_dword>
			st_dword(buf + FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
    4ce2:	f504 70f4 	add.w	r0, r4, #488	; 0x1e8
    4ce6:	f10b 31ff 	add.w	r1, fp, #4294967295
    4cea:	f7fd fe5f 	bl	29ac <st_dword>
			st_dword(buf + FSI_Nxt_Free, 2);			/* Last allocated cluster# */
    4cee:	f504 70f6 	add.w	r0, r4, #492	; 0x1ec
    4cf2:	2102      	movs	r1, #2
    4cf4:	f7fd fe5a 	bl	29ac <st_dword>
			st_word(buf + BS_55AA, 0xAA55);
    4cf8:	9802      	ldr	r0, [sp, #8]
    4cfa:	f64a 2155 	movw	r1, #43605	; 0xaa55
    4cfe:	f7fd fe51 	bl	29a4 <st_word>
			disk_write(pdrv, buf, b_vol + 7, 1);		/* Write backup FSINFO (VBR + 7) */
    4d02:	4621      	mov	r1, r4
    4d04:	f108 0207 	add.w	r2, r8, #7
    4d08:	2301      	movs	r3, #1
    4d0a:	4648      	mov	r0, r9
    4d0c:	f7fd fc9a 	bl	2644 <disk_write>
			disk_write(pdrv, buf, b_vol + 1, 1);		/* Write original FSINFO (VBR + 1) */
    4d10:	4648      	mov	r0, r9
    4d12:	4621      	mov	r1, r4
    4d14:	f108 0201 	add.w	r2, r8, #1
    4d18:	2301      	movs	r3, #1
    4d1a:	f7fd fc93 	bl	2644 <disk_write>
		}

		/* Initialize FAT area */
		mem_set(buf, 0, (UINT)szb_buf);
    4d1e:	9f05      	ldr	r7, [sp, #20]
    4d20:	2100      	movs	r1, #0
    4d22:	027a      	lsls	r2, r7, #9
    4d24:	4620      	mov	r0, r4
    4d26:	f7fd fe53 	bl	29d0 <mem_set>
		sect = b_fat;		/* FAT start sector */
		for (i = 0; i < n_fats; i++) {			/* Initialize FATs each */
			if (fmt == FS_FAT32) {
    4d2a:	2d03      	cmp	r5, #3
    4d2c:	d10e      	bne.n	4d4c <f_mkfs+0x43c>
				st_dword(buf + 0, 0xFFFFFFF8);	/* Entry 0 */
    4d2e:	4620      	mov	r0, r4
    4d30:	f06f 0107 	mvn.w	r1, #7
    4d34:	f7fd fe3a 	bl	29ac <st_dword>
				st_dword(buf + 4, 0xFFFFFFFF);	/* Entry 1 */
    4d38:	1d20      	adds	r0, r4, #4
    4d3a:	f04f 31ff 	mov.w	r1, #4294967295
    4d3e:	f7fd fe35 	bl	29ac <st_dword>
				st_dword(buf + 8, 0x0FFFFFFF);	/* Entry 2 (root directory) */
    4d42:	f104 0008 	add.w	r0, r4, #8
    4d46:	f06f 4170 	mvn.w	r1, #4026531840	; 0xf0000000
    4d4a:	e005      	b.n	4d58 <f_mkfs+0x448>
			} else {
				st_dword(buf + 0, (fmt == FS_FAT12) ? 0xFFFFF8 : 0xFFFFFFF8);	/* Entry 0 and 1 */
    4d4c:	4953      	ldr	r1, [pc, #332]	; (4e9c <f_mkfs+0x58c>)
    4d4e:	2d01      	cmp	r5, #1
    4d50:	4620      	mov	r0, r4
    4d52:	bf18      	it	ne
    4d54:	f06f 0107 	mvnne.w	r1, #7
    4d58:	f7fd fe28 	bl	29ac <st_dword>
    4d5c:	9f03      	ldr	r7, [sp, #12]
    4d5e:	46d3      	mov	fp, sl
    4d60:	46aa      	mov	sl, r5
			}
			nsect = sz_fat;		/* Number of FAT sectors */
			do {	/* Fill FAT sectors */
				n = (nsect > sz_buf) ? sz_buf : nsect;
    4d62:	9d05      	ldr	r5, [sp, #20]
				if (disk_write(pdrv, buf, sect, (UINT)n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
    4d64:	4621      	mov	r1, r4
			} else {
				st_dword(buf + 0, (fmt == FS_FAT12) ? 0xFFFFF8 : 0xFFFFFFF8);	/* Entry 0 and 1 */
			}
			nsect = sz_fat;		/* Number of FAT sectors */
			do {	/* Fill FAT sectors */
				n = (nsect > sz_buf) ? sz_buf : nsect;
    4d66:	45ab      	cmp	fp, r5
    4d68:	bf38      	it	cc
    4d6a:	465d      	movcc	r5, fp
				if (disk_write(pdrv, buf, sect, (UINT)n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
    4d6c:	4648      	mov	r0, r9
    4d6e:	463a      	mov	r2, r7
    4d70:	462b      	mov	r3, r5
    4d72:	f7fd fc67 	bl	2644 <disk_write>
    4d76:	4601      	mov	r1, r0
    4d78:	2800      	cmp	r0, #0
    4d7a:	f040 8081 	bne.w	4e80 <f_mkfs+0x570>
				mem_set(buf, 0, ss);
    4d7e:	4620      	mov	r0, r4
    4d80:	f44f 7200 	mov.w	r2, #512	; 0x200
    4d84:	f7fd fe24 	bl	29d0 <mem_set>
				sect += n; nsect -= n;
			} while (nsect);
    4d88:	ebbb 0b05 	subs.w	fp, fp, r5
			nsect = sz_fat;		/* Number of FAT sectors */
			do {	/* Fill FAT sectors */
				n = (nsect > sz_buf) ? sz_buf : nsect;
				if (disk_write(pdrv, buf, sect, (UINT)n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
				mem_set(buf, 0, ss);
				sect += n; nsect -= n;
    4d8c:	442f      	add	r7, r5
			} while (nsect);
    4d8e:	d1e8      	bne.n	4d62 <f_mkfs+0x452>
    4d90:	4655      	mov	r5, sl
		}

		/* Initialize root directory (fill with zero) */
		nsect = (fmt == FS_FAT32) ? pau : sz_dir;	/* Number of root directory sectors */
    4d92:	f8dd a010 	ldr.w	sl, [sp, #16]
    4d96:	2d03      	cmp	r5, #3
    4d98:	bf08      	it	eq
    4d9a:	46b2      	moveq	sl, r6
    4d9c:	462e      	mov	r6, r5
		do {
			n = (nsect > sz_buf) ? sz_buf : nsect;
    4d9e:	9d05      	ldr	r5, [sp, #20]
			if (disk_write(pdrv, buf, sect, (UINT)n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
    4da0:	4648      	mov	r0, r9
		}

		/* Initialize root directory (fill with zero) */
		nsect = (fmt == FS_FAT32) ? pau : sz_dir;	/* Number of root directory sectors */
		do {
			n = (nsect > sz_buf) ? sz_buf : nsect;
    4da2:	45aa      	cmp	sl, r5
    4da4:	bf38      	it	cc
    4da6:	4655      	movcc	r5, sl
			if (disk_write(pdrv, buf, sect, (UINT)n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
    4da8:	4621      	mov	r1, r4
    4daa:	463a      	mov	r2, r7
    4dac:	462b      	mov	r3, r5
    4dae:	f7fd fc49 	bl	2644 <disk_write>
    4db2:	2800      	cmp	r0, #0
    4db4:	d164      	bne.n	4e80 <f_mkfs+0x570>
			sect += n; nsect -= n;
		} while (nsect);
    4db6:	ebba 0a05 	subs.w	sl, sl, r5
    4dba:	d001      	beq.n	4dc0 <f_mkfs+0x4b0>
		/* Initialize root directory (fill with zero) */
		nsect = (fmt == FS_FAT32) ? pau : sz_dir;	/* Number of root directory sectors */
		do {
			n = (nsect > sz_buf) ? sz_buf : nsect;
			if (disk_write(pdrv, buf, sect, (UINT)n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
			sect += n; nsect -= n;
    4dbc:	197f      	adds	r7, r7, r5
    4dbe:	e7ee      	b.n	4d9e <f_mkfs+0x48e>

	/* Determine system ID in the partition table */
	if (FF_FS_EXFAT && fmt == FS_EXFAT) {
		sys = 0x07;			/* HPFS/NTFS/exFAT */
	} else {
		if (fmt == FS_FAT32) {
    4dc0:	2e03      	cmp	r6, #3
    4dc2:	d008      	beq.n	4dd6 <f_mkfs+0x4c6>
			sys = 0x0C;		/* FAT32X */
		} else {
			if (sz_vol >= 0x10000) {
    4dc4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    4dc6:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
    4dca:	d206      	bcs.n	4dda <f_mkfs+0x4ca>
				sys = 0x06;	/* FAT12/16 (large) */
			} else {
				sys = (fmt == FS_FAT16) ? 0x04 : 0x01;	/* FAT16 : FAT12 */
    4dcc:	2e02      	cmp	r6, #2
    4dce:	bf14      	ite	ne
    4dd0:	2501      	movne	r5, #1
    4dd2:	2504      	moveq	r5, #4
    4dd4:	e002      	b.n	4ddc <f_mkfs+0x4cc>
	/* Determine system ID in the partition table */
	if (FF_FS_EXFAT && fmt == FS_EXFAT) {
		sys = 0x07;			/* HPFS/NTFS/exFAT */
	} else {
		if (fmt == FS_FAT32) {
			sys = 0x0C;		/* FAT32X */
    4dd6:	250c      	movs	r5, #12
    4dd8:	e000      	b.n	4ddc <f_mkfs+0x4cc>
		} else {
			if (sz_vol >= 0x10000) {
				sys = 0x06;	/* FAT12/16 (large) */
    4dda:	2506      	movs	r5, #6
		/* Update system ID in the partition table */
		if (disk_read(pdrv, buf, 0, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);	/* Read the MBR */
		buf[MBR_Table + (part - 1) * SZ_PTE + PTE_System] = sys;		/* Set system ID */
		if (disk_write(pdrv, buf, 0, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);	/* Write it back to the MBR */
	} else {								/* Created as a new single partition */
		if (!(opt & FM_SFD)) {	/* Create partition table if in FDISK format */
    4ddc:	9801      	ldr	r0, [sp, #4]
    4dde:	2800      	cmp	r0, #0
    4de0:	d139      	bne.n	4e56 <f_mkfs+0x546>
			mem_set(buf, 0, ss);
    4de2:	f44f 7200 	mov.w	r2, #512	; 0x200
    4de6:	4620      	mov	r0, r4
    4de8:	9901      	ldr	r1, [sp, #4]
    4dea:	f7fd fdf1 	bl	29d0 <mem_set>
			st_word(buf + BS_55AA, 0xAA55);		/* MBR signature */
    4dee:	9802      	ldr	r0, [sp, #8]
    4df0:	f64a 2155 	movw	r1, #43605	; 0xaa55
    4df4:	f7fd fdd6 	bl	29a4 <st_word>
			pte[PTE_Boot] = 0;					/* Boot indicator */
			pte[PTE_StHead] = 1;				/* Start head */
			pte[PTE_StSec] = 1;					/* Start sector */
			pte[PTE_StCyl] = 0;					/* Start cylinder */
			pte[PTE_System] = sys;				/* System type */
			n = (b_vol + sz_vol) / (63 * 255);	/* (End CHS may be invalid) */
    4df8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    4dfa:	f643 62c1 	movw	r2, #16065	; 0x3ec1
    4dfe:	4443      	add	r3, r8
    4e00:	fbb3 f3f2 	udiv	r3, r3, r2
			pte[PTE_EdHead] = 254;				/* End head */
    4e04:	22fe      	movs	r2, #254	; 0xfe
	} else {								/* Created as a new single partition */
		if (!(opt & FM_SFD)) {	/* Create partition table if in FDISK format */
			mem_set(buf, 0, ss);
			st_word(buf + BS_55AA, 0xAA55);		/* MBR signature */
			pte = buf + MBR_Table;				/* Create partition table for single partition in the drive */
			pte[PTE_Boot] = 0;					/* Boot indicator */
    4e06:	9901      	ldr	r1, [sp, #4]
			pte[PTE_StHead] = 1;				/* Start head */
			pte[PTE_StSec] = 1;					/* Start sector */
			pte[PTE_StCyl] = 0;					/* Start cylinder */
			pte[PTE_System] = sys;				/* System type */
			n = (b_vol + sz_vol) / (63 * 255);	/* (End CHS may be invalid) */
			pte[PTE_EdHead] = 254;				/* End head */
    4e08:	f884 21c3 	strb.w	r2, [r4, #451]	; 0x1c3
			pte[PTE_EdSec] = (BYTE)(((n >> 2) & 0xC0) | 63);	/* End sector */
    4e0c:	089a      	lsrs	r2, r3, #2
    4e0e:	f042 023f 	orr.w	r2, r2, #63	; 0x3f
		if (!(opt & FM_SFD)) {	/* Create partition table if in FDISK format */
			mem_set(buf, 0, ss);
			st_word(buf + BS_55AA, 0xAA55);		/* MBR signature */
			pte = buf + MBR_Table;				/* Create partition table for single partition in the drive */
			pte[PTE_Boot] = 0;					/* Boot indicator */
			pte[PTE_StHead] = 1;				/* Start head */
    4e12:	2601      	movs	r6, #1
		if (disk_write(pdrv, buf, 0, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);	/* Write it back to the MBR */
	} else {								/* Created as a new single partition */
		if (!(opt & FM_SFD)) {	/* Create partition table if in FDISK format */
			mem_set(buf, 0, ss);
			st_word(buf + BS_55AA, 0xAA55);		/* MBR signature */
			pte = buf + MBR_Table;				/* Create partition table for single partition in the drive */
    4e14:	f504 77df 	add.w	r7, r4, #446	; 0x1be
			pte[PTE_StSec] = 1;					/* Start sector */
			pte[PTE_StCyl] = 0;					/* Start cylinder */
			pte[PTE_System] = sys;				/* System type */
			n = (b_vol + sz_vol) / (63 * 255);	/* (End CHS may be invalid) */
			pte[PTE_EdHead] = 254;				/* End head */
			pte[PTE_EdSec] = (BYTE)(((n >> 2) & 0xC0) | 63);	/* End sector */
    4e18:	f884 21c4 	strb.w	r2, [r4, #452]	; 0x1c4
			pte[PTE_EdCyl] = (BYTE)n;			/* End cylinder */
    4e1c:	f884 31c5 	strb.w	r3, [r4, #453]	; 0x1c5
	} else {								/* Created as a new single partition */
		if (!(opt & FM_SFD)) {	/* Create partition table if in FDISK format */
			mem_set(buf, 0, ss);
			st_word(buf + BS_55AA, 0xAA55);		/* MBR signature */
			pte = buf + MBR_Table;				/* Create partition table for single partition in the drive */
			pte[PTE_Boot] = 0;					/* Boot indicator */
    4e20:	f884 11be 	strb.w	r1, [r4, #446]	; 0x1be
			pte[PTE_StHead] = 1;				/* Start head */
			pte[PTE_StSec] = 1;					/* Start sector */
			pte[PTE_StCyl] = 0;					/* Start cylinder */
    4e24:	f884 11c1 	strb.w	r1, [r4, #449]	; 0x1c1
			pte[PTE_System] = sys;				/* System type */
			n = (b_vol + sz_vol) / (63 * 255);	/* (End CHS may be invalid) */
			pte[PTE_EdHead] = 254;				/* End head */
			pte[PTE_EdSec] = (BYTE)(((n >> 2) & 0xC0) | 63);	/* End sector */
			pte[PTE_EdCyl] = (BYTE)n;			/* End cylinder */
			st_dword(pte + PTE_StLba, b_vol);	/* Start offset in LBA */
    4e28:	f107 0008 	add.w	r0, r7, #8
    4e2c:	4641      	mov	r1, r8
		if (!(opt & FM_SFD)) {	/* Create partition table if in FDISK format */
			mem_set(buf, 0, ss);
			st_word(buf + BS_55AA, 0xAA55);		/* MBR signature */
			pte = buf + MBR_Table;				/* Create partition table for single partition in the drive */
			pte[PTE_Boot] = 0;					/* Boot indicator */
			pte[PTE_StHead] = 1;				/* Start head */
    4e2e:	f884 61bf 	strb.w	r6, [r4, #447]	; 0x1bf
			pte[PTE_StSec] = 1;					/* Start sector */
    4e32:	f884 61c0 	strb.w	r6, [r4, #448]	; 0x1c0
			pte[PTE_StCyl] = 0;					/* Start cylinder */
			pte[PTE_System] = sys;				/* System type */
    4e36:	f884 51c2 	strb.w	r5, [r4, #450]	; 0x1c2
			n = (b_vol + sz_vol) / (63 * 255);	/* (End CHS may be invalid) */
			pte[PTE_EdHead] = 254;				/* End head */
			pte[PTE_EdSec] = (BYTE)(((n >> 2) & 0xC0) | 63);	/* End sector */
			pte[PTE_EdCyl] = (BYTE)n;			/* End cylinder */
			st_dword(pte + PTE_StLba, b_vol);	/* Start offset in LBA */
    4e3a:	f7fd fdb7 	bl	29ac <st_dword>
			st_dword(pte + PTE_SizLba, sz_vol);	/* Size in sectors */
    4e3e:	f107 000c 	add.w	r0, r7, #12
    4e42:	990a      	ldr	r1, [sp, #40]	; 0x28
    4e44:	f7fd fdb2 	bl	29ac <st_dword>
			if (disk_write(pdrv, buf, 0, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);	/* Write it to the MBR */
    4e48:	4648      	mov	r0, r9
    4e4a:	4621      	mov	r1, r4
    4e4c:	9a01      	ldr	r2, [sp, #4]
    4e4e:	4633      	mov	r3, r6
    4e50:	f7fd fbf8 	bl	2644 <disk_write>
    4e54:	b9b0      	cbnz	r0, 4e84 <f_mkfs+0x574>
		}
	}

	if (disk_ioctl(pdrv, CTRL_SYNC, 0) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
    4e56:	2100      	movs	r1, #0
    4e58:	4648      	mov	r0, r9
    4e5a:	460a      	mov	r2, r1
    4e5c:	f7fd fc46 	bl	26ec <disk_ioctl>
#endif


	/* Check mounted drive and clear work area */
	vol = get_ldnumber(&path);					/* Get target logical drive */
	if (vol < 0) return FR_INVALID_DRIVE;
    4e60:	3800      	subs	r0, #0
    4e62:	bf18      	it	ne
    4e64:	2001      	movne	r0, #1
    4e66:	e00e      	b.n	4e86 <f_mkfs+0x576>
    4e68:	200b      	movs	r0, #11
    4e6a:	e00c      	b.n	4e86 <f_mkfs+0x576>
	pdrv = LD2PD(vol);	/* Physical drive */
	part = LD2PT(vol);	/* Partition (0:create as new, 1-4:get from partition table) */

	/* Check physical drive status */
	stat = disk_initialize(pdrv);
	if (stat & STA_NOINIT) return FR_NOT_READY;
    4e6c:	2003      	movs	r0, #3
    4e6e:	e00a      	b.n	4e86 <f_mkfs+0x576>
	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
    4e70:	200a      	movs	r0, #10
    4e72:	e008      	b.n	4e86 <f_mkfs+0x576>
	{
		buf = (BYTE*)work;		/* Working buffer */
		sz_buf = len / ss;		/* Size of working buffer (sector) */
		szb_buf = sz_buf * ss;	/* Size of working buffer (byte) */
	}
	if (!buf || sz_buf == 0) return FR_NOT_ENOUGH_CORE;
    4e74:	2011      	movs	r0, #17
    4e76:	e006      	b.n	4e86 <f_mkfs+0x576>
		if (opt & FM_FAT32) {	/* FAT32 possible? */
			if ((opt & FM_ANY) == FM_FAT32 || !(opt & FM_FAT)) {	/* FAT32 only or no-FAT? */
				fmt = FS_FAT32; break;
			}
		}
		if (!(opt & FM_FAT)) LEAVE_MKFS(FR_INVALID_PARAMETER);	/* no-FAT? */
    4e78:	2013      	movs	r0, #19
    4e7a:	e004      	b.n	4e86 <f_mkfs+0x576>
				if  (n_clst <= MAX_FAT12) {	/* Too few clusters for FAT16 */
					if (au == 0 && (au = pau * 2) <= 128) continue;	/* Adjust cluster size and retry */
					LEAVE_MKFS(FR_MKFS_ABORTED);
				}
			}
			if (fmt == FS_FAT12 && n_clst > MAX_FAT12) LEAVE_MKFS(FR_MKFS_ABORTED);	/* Too many clusters for FAT12 */
    4e7c:	200e      	movs	r0, #14
    4e7e:	e002      	b.n	4e86 <f_mkfs+0x576>

		/* Initialize root directory (fill with zero) */
		nsect = (fmt == FS_FAT32) ? pau : sz_dir;	/* Number of root directory sectors */
		do {
			n = (nsect > sz_buf) ? sz_buf : nsect;
			if (disk_write(pdrv, buf, sect, (UINT)n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
    4e80:	2001      	movs	r0, #1
    4e82:	e000      	b.n	4e86 <f_mkfs+0x576>
			pte[PTE_EdHead] = 254;				/* End head */
			pte[PTE_EdSec] = (BYTE)(((n >> 2) & 0xC0) | 63);	/* End sector */
			pte[PTE_EdCyl] = (BYTE)n;			/* End cylinder */
			st_dword(pte + PTE_StLba, b_vol);	/* Start offset in LBA */
			st_dword(pte + PTE_SizLba, sz_vol);	/* Size in sectors */
			if (disk_write(pdrv, buf, 0, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);	/* Write it to the MBR */
    4e84:	4630      	mov	r0, r6
	}

	if (disk_ioctl(pdrv, CTRL_SYNC, 0) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);

	LEAVE_MKFS(FR_OK);
}
    4e86:	b00d      	add	sp, #52	; 0x34
    4e88:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4e8c:	00005cf7 	.word	0x00005cf7
    4e90:	00005d0b 	.word	0x00005d0b
    4e94:	41615252 	.word	0x41615252
    4e98:	61417272 	.word	0x61417272
    4e9c:	00fffff8 	.word	0x00fffff8

00004ea0 <memset>:
    4ea0:	2a03      	cmp	r2, #3
    4ea2:	b2c9      	uxtb	r1, r1
    4ea4:	b470      	push	{r4, r5, r6}
    4ea6:	d808      	bhi.n	4eba <memset+0x1a>
    4ea8:	b12a      	cbz	r2, 4eb6 <memset+0x16>
    4eaa:	4603      	mov	r3, r0
    4eac:	1812      	adds	r2, r2, r0
    4eae:	f803 1b01 	strb.w	r1, [r3], #1
    4eb2:	4293      	cmp	r3, r2
    4eb4:	d1fb      	bne.n	4eae <memset+0xe>
    4eb6:	bc70      	pop	{r4, r5, r6}
    4eb8:	4770      	bx	lr
    4eba:	1882      	adds	r2, r0, r2
    4ebc:	4604      	mov	r4, r0
    4ebe:	e001      	b.n	4ec4 <memset+0x24>
    4ec0:	f804 1b01 	strb.w	r1, [r4], #1
    4ec4:	f014 0f03 	tst.w	r4, #3
    4ec8:	d1fa      	bne.n	4ec0 <memset+0x20>
    4eca:	f04f 3301 	mov.w	r3, #16843009	; 0x1010101
    4ece:	fb03 f301 	mul.w	r3, r3, r1
    4ed2:	e01f      	b.n	4f14 <memset+0x74>
    4ed4:	f844 3c40 	str.w	r3, [r4, #-64]
    4ed8:	f844 3c3c 	str.w	r3, [r4, #-60]
    4edc:	f844 3c38 	str.w	r3, [r4, #-56]
    4ee0:	f844 3c34 	str.w	r3, [r4, #-52]
    4ee4:	f844 3c30 	str.w	r3, [r4, #-48]
    4ee8:	f844 3c2c 	str.w	r3, [r4, #-44]
    4eec:	f844 3c28 	str.w	r3, [r4, #-40]
    4ef0:	f844 3c24 	str.w	r3, [r4, #-36]
    4ef4:	f844 3c20 	str.w	r3, [r4, #-32]
    4ef8:	f844 3c1c 	str.w	r3, [r4, #-28]
    4efc:	f844 3c18 	str.w	r3, [r4, #-24]
    4f00:	f844 3c14 	str.w	r3, [r4, #-20]
    4f04:	f844 3c10 	str.w	r3, [r4, #-16]
    4f08:	f844 3c0c 	str.w	r3, [r4, #-12]
    4f0c:	f844 3c08 	str.w	r3, [r4, #-8]
    4f10:	f844 3c04 	str.w	r3, [r4, #-4]
    4f14:	1b16      	subs	r6, r2, r4
    4f16:	4625      	mov	r5, r4
    4f18:	3440      	adds	r4, #64	; 0x40
    4f1a:	2e3f      	cmp	r6, #63	; 0x3f
    4f1c:	dcda      	bgt.n	4ed4 <memset+0x34>
    4f1e:	462c      	mov	r4, r5
    4f20:	e007      	b.n	4f32 <memset+0x92>
    4f22:	f844 3c10 	str.w	r3, [r4, #-16]
    4f26:	f844 3c0c 	str.w	r3, [r4, #-12]
    4f2a:	f844 3c08 	str.w	r3, [r4, #-8]
    4f2e:	f844 3c04 	str.w	r3, [r4, #-4]
    4f32:	1b16      	subs	r6, r2, r4
    4f34:	4625      	mov	r5, r4
    4f36:	3410      	adds	r4, #16
    4f38:	2e0f      	cmp	r6, #15
    4f3a:	dcf2      	bgt.n	4f22 <memset+0x82>
    4f3c:	e001      	b.n	4f42 <memset+0xa2>
    4f3e:	f845 3b04 	str.w	r3, [r5], #4
    4f42:	1b54      	subs	r4, r2, r5
    4f44:	2c03      	cmp	r4, #3
    4f46:	dcfa      	bgt.n	4f3e <memset+0x9e>
    4f48:	e001      	b.n	4f4e <memset+0xae>
    4f4a:	f805 1b01 	strb.w	r1, [r5], #1
    4f4e:	4295      	cmp	r5, r2
    4f50:	d3fb      	bcc.n	4f4a <memset+0xaa>
    4f52:	e7b0      	b.n	4eb6 <memset+0x16>

00004f54 <strchr>:
    4f54:	b2c9      	uxtb	r1, r1
    4f56:	b4f0      	push	{r4, r5, r6, r7}
    4f58:	2900      	cmp	r1, #0
    4f5a:	d050      	beq.n	4ffe <strchr+0xaa>
    4f5c:	f010 0f03 	tst.w	r0, #3
    4f60:	d010      	beq.n	4f84 <strchr+0x30>
    4f62:	7803      	ldrb	r3, [r0, #0]
    4f64:	2b00      	cmp	r3, #0
    4f66:	d079      	beq.n	505c <strchr+0x108>
    4f68:	4299      	cmp	r1, r3
    4f6a:	d046      	beq.n	4ffa <strchr+0xa6>
    4f6c:	1c43      	adds	r3, r0, #1
    4f6e:	e005      	b.n	4f7c <strchr+0x28>
    4f70:	f813 2b01 	ldrb.w	r2, [r3], #1
    4f74:	2a00      	cmp	r2, #0
    4f76:	d03f      	beq.n	4ff8 <strchr+0xa4>
    4f78:	4291      	cmp	r1, r2
    4f7a:	d03e      	beq.n	4ffa <strchr+0xa6>
    4f7c:	f013 0f03 	tst.w	r3, #3
    4f80:	4618      	mov	r0, r3
    4f82:	d1f5      	bne.n	4f70 <strchr+0x1c>
    4f84:	6803      	ldr	r3, [r0, #0]
    4f86:	ea41 2701 	orr.w	r7, r1, r1, lsl #8
    4f8a:	4606      	mov	r6, r0
    4f8c:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
    4f90:	ea47 4707 	orr.w	r7, r7, r7, lsl #16
    4f94:	ea22 0203 	bic.w	r2, r2, r3
    4f98:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    4f9c:	d11d      	bne.n	4fda <strchr+0x86>
    4f9e:	ea87 0303 	eor.w	r3, r7, r3
    4fa2:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
    4fa6:	ea22 0303 	bic.w	r3, r2, r3
    4faa:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
    4fae:	d114      	bne.n	4fda <strchr+0x86>
    4fb0:	3004      	adds	r0, #4
    4fb2:	e002      	b.n	4fba <strchr+0x66>
    4fb4:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    4fb8:	d10f      	bne.n	4fda <strchr+0x86>
    4fba:	4606      	mov	r6, r0
    4fbc:	f850 3b04 	ldr.w	r3, [r0], #4
    4fc0:	f1a3 3501 	sub.w	r5, r3, #16843009	; 0x1010101
    4fc4:	ea87 0203 	eor.w	r2, r7, r3
    4fc8:	ea25 0303 	bic.w	r3, r5, r3
    4fcc:	f1a2 3401 	sub.w	r4, r2, #16843009	; 0x1010101
    4fd0:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
    4fd4:	ea24 0202 	bic.w	r2, r4, r2
    4fd8:	d0ec      	beq.n	4fb4 <strchr+0x60>
    4fda:	7833      	ldrb	r3, [r6, #0]
    4fdc:	4630      	mov	r0, r6
    4fde:	2b00      	cmp	r3, #0
    4fe0:	d03c      	beq.n	505c <strchr+0x108>
    4fe2:	4299      	cmp	r1, r3
    4fe4:	d009      	beq.n	4ffa <strchr+0xa6>
    4fe6:	1c73      	adds	r3, r6, #1
    4fe8:	e001      	b.n	4fee <strchr+0x9a>
    4fea:	4291      	cmp	r1, r2
    4fec:	d005      	beq.n	4ffa <strchr+0xa6>
    4fee:	4618      	mov	r0, r3
    4ff0:	f813 2b01 	ldrb.w	r2, [r3], #1
    4ff4:	2a00      	cmp	r2, #0
    4ff6:	d1f8      	bne.n	4fea <strchr+0x96>
    4ff8:	4610      	mov	r0, r2
    4ffa:	bcf0      	pop	{r4, r5, r6, r7}
    4ffc:	4770      	bx	lr
    4ffe:	f010 0f03 	tst.w	r0, #3
    5002:	d00c      	beq.n	501e <strchr+0xca>
    5004:	7803      	ldrb	r3, [r0, #0]
    5006:	2b00      	cmp	r3, #0
    5008:	d0f7      	beq.n	4ffa <strchr+0xa6>
    500a:	1c43      	adds	r3, r0, #1
    500c:	e003      	b.n	5016 <strchr+0xc2>
    500e:	f813 2b01 	ldrb.w	r2, [r3], #1
    5012:	2a00      	cmp	r2, #0
    5014:	d0f1      	beq.n	4ffa <strchr+0xa6>
    5016:	f013 0f03 	tst.w	r3, #3
    501a:	4618      	mov	r0, r3
    501c:	d1f7      	bne.n	500e <strchr+0xba>
    501e:	6802      	ldr	r2, [r0, #0]
    5020:	4603      	mov	r3, r0
    5022:	f1a2 3101 	sub.w	r1, r2, #16843009	; 0x1010101
    5026:	ea21 0202 	bic.w	r2, r1, r2
    502a:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    502e:	d10a      	bne.n	5046 <strchr+0xf2>
    5030:	3004      	adds	r0, #4
    5032:	4603      	mov	r3, r0
    5034:	f850 2b04 	ldr.w	r2, [r0], #4
    5038:	f1a2 3101 	sub.w	r1, r2, #16843009	; 0x1010101
    503c:	ea21 0202 	bic.w	r2, r1, r2
    5040:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    5044:	d0f5      	beq.n	5032 <strchr+0xde>
    5046:	781a      	ldrb	r2, [r3, #0]
    5048:	4618      	mov	r0, r3
    504a:	2a00      	cmp	r2, #0
    504c:	d0d5      	beq.n	4ffa <strchr+0xa6>
    504e:	3301      	adds	r3, #1
    5050:	4618      	mov	r0, r3
    5052:	f813 2b01 	ldrb.w	r2, [r3], #1
    5056:	2a00      	cmp	r2, #0
    5058:	d1fa      	bne.n	5050 <strchr+0xfc>
    505a:	e7ce      	b.n	4ffa <strchr+0xa6>
    505c:	4618      	mov	r0, r3
    505e:	e7cc      	b.n	4ffa <strchr+0xa6>

00005060 <strcpy>:
    5060:	ea80 0201 	eor.w	r2, r0, r1
    5064:	4684      	mov	ip, r0
    5066:	f012 0f03 	tst.w	r2, #3
    506a:	d14f      	bne.n	510c <strcpy+0xac>
    506c:	f011 0f03 	tst.w	r1, #3
    5070:	d132      	bne.n	50d8 <strcpy+0x78>
    5072:	f84d 4d04 	str.w	r4, [sp, #-4]!
    5076:	f011 0f04 	tst.w	r1, #4
    507a:	f851 3b04 	ldr.w	r3, [r1], #4
    507e:	d00b      	beq.n	5098 <strcpy+0x38>
    5080:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
    5084:	439a      	bics	r2, r3
    5086:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    508a:	bf04      	itt	eq
    508c:	f84c 3b04 	streq.w	r3, [ip], #4
    5090:	f851 3b04 	ldreq.w	r3, [r1], #4
    5094:	d116      	bne.n	50c4 <strcpy+0x64>
    5096:	bf00      	nop
    5098:	f851 4b04 	ldr.w	r4, [r1], #4
    509c:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
    50a0:	439a      	bics	r2, r3
    50a2:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    50a6:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
    50aa:	d10b      	bne.n	50c4 <strcpy+0x64>
    50ac:	f84c 3b04 	str.w	r3, [ip], #4
    50b0:	43a2      	bics	r2, r4
    50b2:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    50b6:	bf04      	itt	eq
    50b8:	f851 3b04 	ldreq.w	r3, [r1], #4
    50bc:	f84c 4b04 	streq.w	r4, [ip], #4
    50c0:	d0ea      	beq.n	5098 <strcpy+0x38>
    50c2:	4623      	mov	r3, r4
    50c4:	f80c 3b01 	strb.w	r3, [ip], #1
    50c8:	f013 0fff 	tst.w	r3, #255	; 0xff
    50cc:	ea4f 2333 	mov.w	r3, r3, ror #8
    50d0:	d1f8      	bne.n	50c4 <strcpy+0x64>
    50d2:	f85d 4b04 	ldr.w	r4, [sp], #4
    50d6:	4770      	bx	lr
    50d8:	f011 0f01 	tst.w	r1, #1
    50dc:	d006      	beq.n	50ec <strcpy+0x8c>
    50de:	f811 2b01 	ldrb.w	r2, [r1], #1
    50e2:	f80c 2b01 	strb.w	r2, [ip], #1
    50e6:	2a00      	cmp	r2, #0
    50e8:	bf08      	it	eq
    50ea:	4770      	bxeq	lr
    50ec:	f011 0f02 	tst.w	r1, #2
    50f0:	d0bf      	beq.n	5072 <strcpy+0x12>
    50f2:	f831 2b02 	ldrh.w	r2, [r1], #2
    50f6:	f012 0fff 	tst.w	r2, #255	; 0xff
    50fa:	bf16      	itet	ne
    50fc:	f82c 2b02 	strhne.w	r2, [ip], #2
    5100:	f88c 2000 	strbeq.w	r2, [ip]
    5104:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
    5108:	d1b3      	bne.n	5072 <strcpy+0x12>
    510a:	4770      	bx	lr
    510c:	f811 2b01 	ldrb.w	r2, [r1], #1
    5110:	f80c 2b01 	strb.w	r2, [ip], #1
    5114:	2a00      	cmp	r2, #0
    5116:	d1f9      	bne.n	510c <strcpy+0xac>
    5118:	4770      	bx	lr
    511a:	bf00      	nop

0000511c <strlen>:
    511c:	f020 0103 	bic.w	r1, r0, #3
    5120:	f010 0003 	ands.w	r0, r0, #3
    5124:	f1c0 0000 	rsb	r0, r0, #0
    5128:	f851 3b04 	ldr.w	r3, [r1], #4
    512c:	f100 0c04 	add.w	ip, r0, #4
    5130:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
    5134:	f06f 0200 	mvn.w	r2, #0
    5138:	bf1c      	itt	ne
    513a:	fa22 f20c 	lsrne.w	r2, r2, ip
    513e:	4313      	orrne	r3, r2
    5140:	f04f 0c01 	mov.w	ip, #1
    5144:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
    5148:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
    514c:	eba3 020c 	sub.w	r2, r3, ip
    5150:	ea22 0203 	bic.w	r2, r2, r3
    5154:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
    5158:	bf04      	itt	eq
    515a:	f851 3b04 	ldreq.w	r3, [r1], #4
    515e:	3004      	addeq	r0, #4
    5160:	d0f4      	beq.n	514c <strlen+0x30>
    5162:	f013 0fff 	tst.w	r3, #255	; 0xff
    5166:	bf1f      	itttt	ne
    5168:	3001      	addne	r0, #1
    516a:	f413 4f7f 	tstne.w	r3, #65280	; 0xff00
    516e:	3001      	addne	r0, #1
    5170:	f413 0f7f 	tstne.w	r3, #16711680	; 0xff0000
    5174:	bf18      	it	ne
    5176:	3001      	addne	r0, #1
    5178:	4770      	bx	lr
    517a:	bf00      	nop
    517c:	44004b4f 	.word	0x44004b4f
    5180:	5f4b5349 	.word	0x5f4b5349
    5184:	00525245 	.word	0x00525245
    5188:	5f544e49 	.word	0x5f544e49
    518c:	00525245 	.word	0x00525245
    5190:	5f544f4e 	.word	0x5f544f4e
    5194:	44414552 	.word	0x44414552
    5198:	4f4e0059 	.word	0x4f4e0059
    519c:	4c49465f 	.word	0x4c49465f
    51a0:	4f4e0045 	.word	0x4f4e0045
    51a4:	5441505f 	.word	0x5441505f
    51a8:	4e490048 	.word	0x4e490048
    51ac:	494c4156 	.word	0x494c4156
    51b0:	414e5f44 	.word	0x414e5f44
    51b4:	4400454d 	.word	0x4400454d
    51b8:	45494e45 	.word	0x45494e45
    51bc:	58450044 	.word	0x58450044
    51c0:	00545349 	.word	0x00545349
    51c4:	41564e49 	.word	0x41564e49
    51c8:	5f44494c 	.word	0x5f44494c
    51cc:	454a424f 	.word	0x454a424f
    51d0:	57005443 	.word	0x57005443
    51d4:	45544952 	.word	0x45544952
    51d8:	4f52505f 	.word	0x4f52505f
    51dc:	54434554 	.word	0x54434554
    51e0:	49004445 	.word	0x49004445
    51e4:	4c41564e 	.word	0x4c41564e
    51e8:	445f4449 	.word	0x445f4449
    51ec:	45564952 	.word	0x45564952
    51f0:	544f4e00 	.word	0x544f4e00
    51f4:	414e455f 	.word	0x414e455f
    51f8:	44454c42 	.word	0x44454c42
    51fc:	5f4f4e00 	.word	0x5f4f4e00
    5200:	454c4946 	.word	0x454c4946
    5204:	5359535f 	.word	0x5359535f
    5208:	004d4554 	.word	0x004d4554
    520c:	53464b4d 	.word	0x53464b4d
    5210:	4f42415f 	.word	0x4f42415f
    5214:	44455452 	.word	0x44455452
    5218:	4d495400 	.word	0x4d495400
    521c:	54554f45 	.word	0x54554f45
    5220:	434f4c00 	.word	0x434f4c00
    5224:	0044454b 	.word	0x0044454b
    5228:	5f544f4e 	.word	0x5f544f4e
    522c:	554f4e45 	.word	0x554f4e45
    5230:	435f4847 	.word	0x435f4847
    5234:	0045524f 	.word	0x0045524f
    5238:	5f4f4f54 	.word	0x5f4f4f54
    523c:	594e414d 	.word	0x594e414d
    5240:	45504f5f 	.word	0x45504f5f
    5244:	49465f4e 	.word	0x49465f4e
    5248:	0053454c 	.word	0x0053454c
    524c:	41564e49 	.word	0x41564e49
    5250:	5f44494c 	.word	0x5f44494c
    5254:	41524150 	.word	0x41524150
    5258:	4554454d 	.word	0x4554454d
    525c:	0052      	.short	0x0052
	...

0000525f <HelpMsg>:
    525f:	445b 7369 206b 6f63 746e 726f 736c 0a5d     [Disk contorls].
    526f:	6420 2069 703c 2364 203e 202d 6e49 7469      di <pd#> - Init
    527f:	6169 696c 657a 6420 7369 0a6b 6420 2064     ialize disk. dd 
    528f:	3c5b 6470 3e23 3c20 626c 3e61 205d 202d     [<pd#> <lba>] - 
    529f:	7544 706d 6120 7320 6365 7472 726f 200a     Dump a secrtor. 
    52af:	7364 3c20 6470 3e23 2d20 5320 6f68 2077     ds <pd#> - Show 
    52bf:	6964 6b73 7320 6174 7574 0a73 425b 6675     disk status.[Buf
    52cf:	6566 2072 6f63 746e 6f72 736c 0a5d 6220     fer controls]. b
    52df:	2064 6f3c 7366 203e 202d 7544 706d 7720     d <ofs> - Dump w
    52ef:	726f 696b 676e 6220 6675 6566 0a72 6220     orking buffer. b
    52ff:	2065 6f3c 7366 203e 3c5b 6164 6174 5d3e     e <ofs> [<data>]
    530f:	2e20 2e2e 2d20 4520 6964 2074 6f77 6b72      ... - Edit work
    531f:	6e69 2067 7562 6666 7265 200a 7262 3c20     ing buffer. br <
    532f:	6470 3e23 3c20 626c 3e61 5b20 633c 756f     pd#> <lba> [<cou
    533f:	746e 5d3e 2d20 5220 6165 2064 6964 6b73     nt>] - Read disk
    534f:	6920 746e 206f 6f77 6b72 6e69 2067 7562      into working bu
    535f:	6666 7265 200a 7762 3c20 6470 3e23 3c20     ffer. bw <pd#> <
    536f:	626c 3e61 5b20 633c 756f 746e 5d3e 2d20     lba> [<count>] -
    537f:	5720 6972 6574 7720 726f 696b 676e 6220      Write working b
    538f:	6675 6566 2072 6e69 6f74 6420 7369 0a6b     uffer into disk.
    539f:	6220 2066 763c 6c61 203e 202d 6946 6c6c      bf <val> - Fill
    53af:	7720 726f 696b 676e 6220 6675 6566 0a72      working buffer.
    53bf:	465b 6c69 2065 7973 7473 6d65 6320 6e6f     [File system con
    53cf:	7274 6c6f 5d73 200a 6966 3c20 646c 3e23     trols]. fi <ld#>
    53df:	5b20 6d3c 756f 746e 5d3e 202d 6f46 6372      [<mount>]- Forc
    53ef:	2065 6e69 7469 6169 696c 657a 2064 6874     e initialized th
    53ff:	2065 6f76 756c 656d 200a 7366 5b20 703c     e volume. fs [<p
    540f:	7461 3e68 205d 202d 6853 776f 7620 6c6f     ath>] - Show vol
    541f:	6d75 2065 7473 7461 7375 200a 6c66 5b20     ume status. fl [
    542f:	703c 7461 3e68 205d 202d 6853 776f 6120     <path>] - Show a
    543f:	6420 7269 6365 6f74 7972 200a 4c66 3c20      directory. fL <
    544f:	6170 6874 203e 703c 7461 203e 202d 6553     path> <pat> - Se
    545f:	7261 6863 6420 7269 6365 6f74 7972 200a     arch directory. 
    546f:	6f66 3c20 6f6d 6564 203e 663c 6c69 3e65     fo <mode> <file>
    547f:	2d20 4f20 6570 206e 2061 6966 656c 200a      - Open a file. 
    548f:	6366 2d20 4320 6f6c 6573 7420 6568 6620     fc - Close the f
    549f:	6c69 0a65 6620 2065 6f3c 7366 203e 202d     ile. fe <ofs> - 
    54af:	6f4d 6576 6620 2070 6e69 6e20 726f 616d     Move fp in norma
    54bf:	206c 6573 6b65 200a 6466 3c20 656c 3e6e     l seek. fd <len>
    54cf:	2d20 5220 6165 2064 6e61 2064 7564 706d      - Read and dump
    54df:	7420 6568 6620 6c69 0a65 6620 2072 6c3c      the file. fr <l
    54ef:	6e65 203e 202d 6552 6461 7420 6568 6620     en> - Read the f
    54ff:	6c69 0a65 6620 2077 6c3c 6e65 203e 763c     ile. fw <len> <v
    550f:	6c61 203e 202d 7257 7469 2065 6f74 7420     al> - Write to t
    551f:	6568 6620 6c69 0a65 6620 206e 6f3c 6772     he file. fn <org
    552f:	6e2e 6d61 3e65 3c20 656e 2e77 616e 656d     .name> <new.name
    553f:	203e 202d 6552 616e 656d 6120 206e 626f     > - Rename an ob
    554f:	656a 7463 200a 7566 3c20 616e 656d 203e     ject. fu <name> 
    555f:	202d 6e55 696c 6b6e 6120 206e 626f 656a     - Unlink an obje
    556f:	7463 200a 7666 2d20 5420 7572 636e 7461     ct. fv - Truncat
    557f:	2065 6874 2065 6966 656c 6120 2074 7563     e the file at cu
    558f:	7272 6e65 2074 7066 200a 6b66 3c20 616e     rrent fp. fk <na
    559f:	656d 203e 202d 7243 6165 6574 6120 6420     me> - Create a d
    55af:	7269 6365 6f74 7972 200a 6166 3c20 7461     irectory. fa <at
    55bf:	7272 203e 6d3c 7361 3e6b 3c20 626f 656a     rr> <mask> <obje
    55cf:	7463 6e20 6d61 3e65 2d20 4320 6168 676e     ct name> - Chang
    55df:	2065 7461 7274 6269 7475 2065 666f 6120     e attribute of a
    55ef:	206e 626f 656a 7463 200a 7466 3c20 6579     n object. ft <ye
    55ff:	7261 203e 6d3c 6e6f 6874 203e 643c 7961     ar> <month> <day
    560f:	203e 683c 756f 3e72 3c20 696d 3e6e 3c20     > <hour> <min> <
    561f:	6573 3e63 3c20 616e 656d 203e 202d 6843     sec> <name> - Ch
    562f:	6e61 6567 7420 6d69 7365 6174 706d 6f20     ange timestamp o
    563f:	2066 6e61 6f20 6a62 6365 0a74 6620 2078     f an object. fx 
    564f:	733c 6372 662e 6c69 3e65 3c20 7364 2e74     <src.file> <dst.
    565f:	6966 656c 203e 202d 6f43 7970 6120 6620     file> - Copy a f
    566f:	6c69 0a65 6620 2067 703c 7461 3e68 2d20     ile. fg <path> -
    567f:	4320 6168 676e 2065 7563 7272 6e65 2074      Change current 
    568f:	6964 6572 7463 726f 0a79 6620 2071 202d     directory. fq - 
    569f:	6853 776f 6320 7275 6572 746e 6420 7269     Show current dir
    56af:	6365 6f74 7972 200a 6266 3c20 616e 656d     ectory. fb <name
    56bf:	203e 202d 6553 2074 6f76 756c 656d 6c20     > - Set volume l
    56cf:	6261 6c65 200a 6d66 3c20 646c 3e23 3c20     abel. fm <ld#> <
    56df:	7974 6570 203e 633c 6973 657a 203e 202d     type> <csize> - 
    56ef:	7243 6165 6574 6620 6c69 2065 7973 7473     Create file syst
    56ff:	6d65 200a 7a66 5b20 6c3c 6e65 5d3e 2d20     em. fz [<len>] -
    570f:	4320 6168 676e 2f65 6853 776f 5220 572f      Change/Show R/W
    571f:	6c20 6e65 7467 2068 6f66 2072 7266 662f      length for fr/f
    572f:	2f77 7866 6320 6d6f 616d 646e 5b0a 694d     w/fx command.[Mi
    573f:	6373 6320 6d6f 616d 646e 5d73 200a 2070     sc commands]. p 
    574f:	773c 7661 6966 656c 203e 202d 6c50 7961     <wavfile> - Play
    575f:	5220 4649 2d46 4157 4556 6620 6c69 0a65      RIFF-WAVE file.
    576f:	6d20 5b64 7c62 7c68 5d77 3c20 6461 7264      md[b|h|w] <addr
    577f:	203e 3c5b 6f63 6e75 3e74 205d 202d 7544     > [<count>] - Du
    578f:	706d 6d20 6d65 726f 0a79 6d20 2066 613c     mp memory. mf <a
    579f:	6464 3e72 3c20 6176 756c 3e65 3c20 6f63     ddr> <value> <co
    57af:	6e75 3e74 2d20 4620 6c69 206c 656d 6f6d     unt> - Fill memo
    57bf:	7972 200a 656d 625b 687c 777c 205d 613c     ry. me[b|h|w] <a
    57cf:	6464 3e72 5b20 763c 6c61 6575 203e 2e2e     ddr> [<value> ..
    57df:	5d2e 2d20 4520 6964 2074 656d 6f6d 7972     .] - Edit memory
    57ef:	200a 2074 3c5b 6579 7261 203e 6d3c 6e6f     . t [<year> <mon
    57ff:	203e 6d3c 6164 3e79 3c20 6f68 7275 203e     > <mday> <hour> 
    580f:	6d3c 6e69 203e 733c 6365 5d3e 2d20 5320     <min> <sec>] - S
    581f:	7465 532f 6f68 2077 5452 0a43 000a 0000     et/Show RTC.....
	...

00005830 <ft.1992>:
    5830:	5a3e 0000 5c10 0000 5c16 0000 5c1c 0000     >Z...\...\...\..
    5840:	5c22 0000 6372 253d 2075 5246 255f 0a73     "\..rc=%u FR_%s.
    5850:	5600 6c6f 6d75 2065 616e 656d 6920 2073     .Volume name is 
    5860:	7325 000a 6f4e 7620 6c6f 6d75 2065 616c     %s..No volume la
    5870:	6562 0a6c 4c00 4350 3731 3836 7420 7365     bel..LPC1768 tes
    5880:	2074 6f6d 696e 6f74 0a72 4c00 4e46 253d     t monitor..LFN=%
    5890:	2c73 4320 3d50 7525 000a 6944 6173 6c62     s, CP=%u..Disabl
    58a0:	6465 2500 3830 2058 7830 3025 5838 002d     ed.%08X 0x%08X-.
    58b0:	3025 5838 3020 2578 3430 2d58 2500 3830     %08X 0x%04X-.%08
    58c0:	2058 7830 3025 5832 002d 6372 253d 0a64     X 0x%02X-.rc=%d.
    58d0:	5000 2344 253a 2075 424c 3a41 6c25 0a75     .PD#:%u LBA:%lu.
    58e0:	4400 6972 6576 7320 7a69 3a65 2520 756c     .Drive size: %lu
    58f0:	7320 6365 6f74 7372 000a 6c42 636f 206b      sectors..Block 
    5900:	6973 657a 203a 6c25 2075 6573 7463 726f     size: %lu sector
    5910:	0a73 4d00 6465 6169 7420 7079 3a65 2520     s..Media type: %
    5920:	0a75 4300 4453 0a3a 4300 4449 0a3a 4f00     u..CSD:..CID:..O
    5930:	5243 0a3a 5300 2044 7453 7461 7375 0a3a     CR:..SD Status:.
    5940:	2500 3430 2058 3025 5832 002d 3f3f 0a3f     .%04X %02X-.???.
    5950:	7200 3d63 7525 000a 4146 2054 7974 6570     .rc=%u..FAT type
    5960:	3d20 2520 0a73 4200 7479 7365 432f 756c      = %s..Bytes/Clu
    5970:	7473 7265 3d20 2520 756c 000a 754e 626d     ster = %lu..Numb
    5980:	7265 6f20 2066 4146 7354 3d20 2520 0a75     er of FATs = %u.
    5990:	5200 6f6f 2074 4944 2052 6e65 7274 6569     .Root DIR entrie
    59a0:	2073 203d 7525 000a 6553 7463 726f 2f73     s = %u..Sectors/
    59b0:	4146 2054 203d 6c25 0a75 4e00 6d75 6562     FAT = %lu..Numbe
    59c0:	2072 666f 6320 756c 7473 7265 2073 203d     r of clusters = 
    59d0:	6c25 0a75 5600 6c6f 6d75 2065 7473 7261     %lu..Volume star
    59e0:	2074 6c28 6162 2029 203d 6c25 0a75 4600     t (lba) = %lu..F
    59f0:	5441 7320 6174 7472 2820 626c 2961 3d20     AT start (lba) =
    5a00:	2520 756c 000a 4446 5249 7320 6174 7472      %lu..FDIR start
    5a10:	2820 626c 2c61 6c63 7375 6f74 2972 3d20      (lba,clustor) =
    5a20:	2520 756c 000a 6144 6174 7320 6174 7472      %lu..Data start
    5a30:	2820 626c 2961 3d20 2520 756c 0a0a 5600      (lba) = %lu...V
    5a40:	6c6f 6d75 2065 2f53 204e 7369 2520 3430     olume S/N is %04
    5a50:	2d58 3025 5834 000a 250d 2075 6966 656c     X-%04X...%u file
    5a60:	2c73 2520 756c 6220 7479 7365 0a2e 7525     s, %lu bytes..%u
    5a70:	6620 6c6f 6564 7372 0a2e 6c25 2075 694b      folders..%lu Ki
    5a80:	2042 6f74 6174 206c 6964 6b73 7320 6170     B total disk spa
    5a90:	6563 0a2e 6c25 2075 694b 2042 7661 6961     ce..%lu KiB avai
    5aa0:	616c 6c62 2e65 000a 6325 6325 6325 6325     lable...%c%c%c%c
    5ab0:	6325 2520 2f75 3025 7532 252f 3230 2075     %c %u/%02u/%02u 
    5ac0:	3025 7532 253a 3230 2075 3925 756c 2020     %02u:%02u %9lu  
    5ad0:	7325 000a 3425 2075 6946 656c 7328 2c29     %s..%4u File(s),
    5ae0:	3125 6c30 2075 7962 6574 2073 6f74 6174     %10lu bytes tota
    5af0:	0a6c 3425 2075 6944 2872 2973 2c00 2520     l.%4u Dir(s)., %
    5b00:	3031 756c 6220 7479 7365 6620 6572 0a65     10lu bytes free.
    5b10:	6600 7470 3d72 6c25 2875 7830 6c25 2958     .fptr=%lu(0x%lX)
    5b20:	000a 6c25 2075 7962 6574 2073 6572 6461     ..%lu bytes read
    5b30:	6120 2074 6c25 2075 426b 732f 6365 0a2e      at %lu kB/sec..
    5b40:	2500 756c 6220 7479 7365 7720 6972 7474     .%lu bytes writt
    5b50:	6e65 6120 2074 6c25 2075 426b 732f 6365     en at %lu kB/sec
    5b60:	0a2e 4f00 6570 696e 676e 2220 7325 0022     ...Opening "%s".
    5b70:	7243 6165 6974 676e 2220 7325 0022 6f43     Creating "%s".Co
    5b80:	7970 6e69 2067 6966 656c 2e2e 002e 250a     pying file.....%
    5b90:	756c 6220 7479 7365 6320 706f 6569 2064     lu bytes copied 
    5ba0:	7461 2520 756c 6b20 2f42 6573 2e63 000a     at %lu kB/sec...
    5bb0:	6854 2065 6f76 756c 656d 7720 6c69 206c     The volume will 
    5bc0:	6562 6620 726f 616d 7474 6465 202e 7241     be formatted. Ar
    5bd0:	2065 6f79 2075 7573 6572 203f 5928 6e2f     e you sure? (Y/n
    5be0:	3d29 6200 656c 3d6e 7525 000a 4157 2056     )=.blen=%u..WAV 
    5bf0:	6c50 7961 7265 2500 2f75 7525 252f 2075     Player.%u/%u/%u 
    5c00:	3025 7532 253a 3230 3a75 3025 7532 000a     %02u:%02u:%02u..
    5c10:	4146 3154 0032 4146 3154 0036 4146 3354     FAT12.FAT16.FAT3
    5c20:	0032 7865 4146 0054 7453 7265 6f65 4d00     2.exFAT.Stereo.M
    5c30:	6e6f 006f 2a2a 2a2a 2520 2073 2a2a 2a2a     ono.**** %s ****
    5c40:	000a 4149 5452 253d 0a73 4e49 4d41 253d     ..IART=%s.INAM=%
    5c50:	0a73 5300 6d61 6c70 3d65 7525 252e 6b75     s..Sample=%u.%uk
    5c60:	7a48 252f 6275 7469 252f 0a73 654c 676e     Hz/%ubit/%s.Leng
    5c70:	6874 253d 3a75 3025 7532 000a 540d 6d69     th=%u:%02u...Tim
    5c80:	3d65 7525 253a 3230 0075 3025 6c38 3a58     e=%u:%02u.%08lX:
    5c90:	2000 3025 5832 2000 3025 5834 2000 3025     . %02X. %04X. %0
    5ca0:	4c38 0058                                   8LX.

00005ca4 <CSWTCH.75>:
    5ca4:	0043 0000 0064 0000                         C...d...

00005cac <badchr.2054>:
    5cac:	2e2b 3b2c 5b3d 2f5d 225c 3a2a 3e3c 7c3f     +.,;=[]/\"*:<>?|
    5cbc:	007f                                        ..

00005cbe <cst32.2071>:
    5cbe:	0001 0002 0004 0008 0010 0020 0000          .......... ...

00005ccc <cst.2070>:
    5ccc:	0001 0004 0010 0040 0100 0200 0000 0000     ......@.........
    5cdc:	2a22 2c2b 3b3a 3d3c 3f3e 5d5b 7f7c eb00     "*+,:;<=>?[]|...
    5cec:	90fe 534d 4f44 3553 302e 4e00 204f 414e     ..MSDOS5.0.NO NA
    5cfc:	454d 2020 2020 4146 3354 2032 2020 4e00     ME    FAT32   .N
    5d0c:	204f 414e 454d 2020 2020 4146 2054 2020     O NAME    FAT   
    5d1c:	2020 0000                                          .
